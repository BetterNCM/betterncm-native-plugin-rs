/* automatically generated by rust-bindgen 0.63.0 */

pub const CEF_STRING_TYPE_UTF16: u32 = 1;
pub type wchar_t = ::core::ffi::c_ushort;
pub type int64 = ::core::ffi::c_longlong;
pub type uint64 = ::core::ffi::c_ulonglong;
pub type int32 = ::core::ffi::c_int;
pub type uint32 = ::core::ffi::c_uint;
pub type uint16 = ::core::ffi::c_ushort;
pub type char16 = wchar_t;
#[doc = " CEF string type definitions. Whomever allocates |str| is responsible for\n providing an appropriate |dtor| implementation that will free the string in\n the same memory space. When reusing an existing string structure make sure\n to call |dtor| for the old value before assigning new |str| and |dtor|\n values. Static strings will have a NULL |dtor| value. Using the below\n functions if you want this managed for you."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_string_wide_t {
    pub str_: *mut wchar_t,
    pub length: usize,
    pub dtor: ::core::option::Option<unsafe extern "C" fn(str_: *mut wchar_t)>,
}
#[test]
fn bindgen_test_layout__cef_string_wide_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_string_wide_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_string_wide_t>(),
        24usize,
        concat!("Size of: ", stringify!(_cef_string_wide_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_string_wide_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_string_wide_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).str_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_string_wide_t),
            "::",
            stringify!(str_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_string_wide_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dtor) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_string_wide_t),
            "::",
            stringify!(dtor)
        )
    );
}
#[doc = " CEF string type definitions. Whomever allocates |str| is responsible for\n providing an appropriate |dtor| implementation that will free the string in\n the same memory space. When reusing an existing string structure make sure\n to call |dtor| for the old value before assigning new |str| and |dtor|\n values. Static strings will have a NULL |dtor| value. Using the below\n functions if you want this managed for you."]
pub type cef_string_wide_t = _cef_string_wide_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_string_utf8_t {
    pub str_: *mut ::core::ffi::c_char,
    pub length: usize,
    pub dtor: ::core::option::Option<unsafe extern "C" fn(str_: *mut ::core::ffi::c_char)>,
}
#[test]
fn bindgen_test_layout__cef_string_utf8_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_string_utf8_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_string_utf8_t>(),
        24usize,
        concat!("Size of: ", stringify!(_cef_string_utf8_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_string_utf8_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_string_utf8_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).str_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_string_utf8_t),
            "::",
            stringify!(str_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_string_utf8_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dtor) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_string_utf8_t),
            "::",
            stringify!(dtor)
        )
    );
}
pub type cef_string_utf8_t = _cef_string_utf8_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_string_utf16_t {
    pub str_: *mut char16,
    pub length: usize,
    pub dtor: ::core::option::Option<unsafe extern "C" fn(str_: *mut char16)>,
}
#[test]
fn bindgen_test_layout__cef_string_utf16_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_string_utf16_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_string_utf16_t>(),
        24usize,
        concat!("Size of: ", stringify!(_cef_string_utf16_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_string_utf16_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_string_utf16_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).str_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_string_utf16_t),
            "::",
            stringify!(str_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_string_utf16_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dtor) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_string_utf16_t),
            "::",
            stringify!(dtor)
        )
    );
}
pub type cef_string_utf16_t = _cef_string_utf16_t;
#[doc = "\n It is sometimes necessary for the system to allocate string structures with\n the expectation that the user will free them. The userfree types act as a\n hint that the user is responsible for freeing the structure.\n"]
pub type cef_string_userfree_wide_t = *mut cef_string_wide_t;
pub type cef_string_userfree_utf8_t = *mut cef_string_utf8_t;
pub type cef_string_userfree_utf16_t = *mut cef_string_utf16_t;
pub type cef_char_t = char16;
pub type cef_string_userfree_t = cef_string_userfree_utf16_t;
pub type cef_string_t = cef_string_utf16_t;
#[doc = "\n CEF string maps are a set of key/value string pairs.\n"]
pub type cef_string_list_t = *mut ::core::ffi::c_void;
#[doc = "\n CEF string maps are a set of key/value string pairs.\n"]
pub type cef_string_map_t = *mut ::core::ffi::c_void;
#[doc = "\n CEF string multimaps are a set of key/value string pairs.\n More than one value can be assigned to a single key.\n"]
pub type cef_string_multimap_t = *mut ::core::ffi::c_void;
pub type __time64_t = ::core::ffi::c_longlong;
pub type time_t = __time64_t;
#[doc = "\n Time information. Values should always be in UTC.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_time_t {
    #[doc = " Four or five digit year \"2007\" (1601 to 30827 on\n   Windows, 1970 to 2038 on 32-bit POSIX)"]
    pub year: ::core::ffi::c_int,
    #[doc = " 1-based month (values 1 = January, etc.)"]
    pub month: ::core::ffi::c_int,
    #[doc = " 0-based day of week (0 = Sunday, etc.)"]
    pub day_of_week: ::core::ffi::c_int,
    #[doc = " 1-based day of month (1-31)"]
    pub day_of_month: ::core::ffi::c_int,
    #[doc = " Hour within the current day (0-23)"]
    pub hour: ::core::ffi::c_int,
    #[doc = " Minute within the current hour (0-59)"]
    pub minute: ::core::ffi::c_int,
    #[doc = " Second within the current minute (0-59 plus leap\n   seconds which may take it up to 60)."]
    pub second: ::core::ffi::c_int,
    #[doc = " Milliseconds within the current second (0-999)"]
    pub millisecond: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout__cef_time_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_time_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_time_t>(),
        32usize,
        concat!("Size of: ", stringify!(_cef_time_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_time_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_cef_time_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).year) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_time_t),
            "::",
            stringify!(year)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).month) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_time_t),
            "::",
            stringify!(month)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).day_of_week) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_time_t),
            "::",
            stringify!(day_of_week)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).day_of_month) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_time_t),
            "::",
            stringify!(day_of_month)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hour) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_time_t),
            "::",
            stringify!(hour)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).minute) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_time_t),
            "::",
            stringify!(minute)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).second) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_time_t),
            "::",
            stringify!(second)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).millisecond) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_time_t),
            "::",
            stringify!(millisecond)
        )
    );
}
#[doc = "\n Time information. Values should always be in UTC.\n"]
pub type cef_time_t = _cef_time_t;
pub type DWORD = ::core::ffi::c_ulong;
pub type UINT = ::core::ffi::c_uint;
pub type UINT_PTR = ::core::ffi::c_ulonglong;
pub type LONG_PTR = ::core::ffi::c_longlong;
pub type LONG = ::core::ffi::c_long;
pub type WPARAM = UINT_PTR;
pub type LPARAM = LONG_PTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HINSTANCE__ {
    pub unused: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_HINSTANCE__() {
    const UNINIT: ::core::mem::MaybeUninit<HINSTANCE__> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<HINSTANCE__>(),
        4usize,
        concat!("Size of: ", stringify!(HINSTANCE__))
    );
    assert_eq!(
        ::core::mem::align_of::<HINSTANCE__>(),
        4usize,
        concat!("Alignment of ", stringify!(HINSTANCE__))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HINSTANCE__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HINSTANCE = *mut HINSTANCE__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HWND__ {
    pub unused: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_HWND__() {
    const UNINIT: ::core::mem::MaybeUninit<HWND__> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<HWND__>(),
        4usize,
        concat!("Size of: ", stringify!(HWND__))
    );
    assert_eq!(
        ::core::mem::align_of::<HWND__>(),
        4usize,
        concat!("Alignment of ", stringify!(HWND__))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HWND__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HWND = *mut HWND__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HICON__ {
    pub unused: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_HICON__() {
    const UNINIT: ::core::mem::MaybeUninit<HICON__> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<HICON__>(),
        4usize,
        concat!("Size of: ", stringify!(HICON__))
    );
    assert_eq!(
        ::core::mem::align_of::<HICON__>(),
        4usize,
        concat!("Alignment of ", stringify!(HICON__))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HICON__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HICON = *mut HICON__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HMENU__ {
    pub unused: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout_HMENU__() {
    const UNINIT: ::core::mem::MaybeUninit<HMENU__> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<HMENU__>(),
        4usize,
        concat!("Size of: ", stringify!(HMENU__))
    );
    assert_eq!(
        ::core::mem::align_of::<HMENU__>(),
        4usize,
        concat!("Alignment of ", stringify!(HMENU__))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HMENU__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HMENU = *mut HMENU__;
pub type HCURSOR = HICON;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagPOINT {
    pub x: LONG,
    pub y: LONG,
}
#[test]
fn bindgen_test_layout_tagPOINT() {
    const UNINIT: ::core::mem::MaybeUninit<tagPOINT> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<tagPOINT>(),
        8usize,
        concat!("Size of: ", stringify!(tagPOINT))
    );
    assert_eq!(
        ::core::mem::align_of::<tagPOINT>(),
        4usize,
        concat!("Alignment of ", stringify!(tagPOINT))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tagPOINT),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tagPOINT),
            "::",
            stringify!(y)
        )
    );
}
pub type POINT = tagPOINT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tagMSG {
    pub hwnd: HWND,
    pub message: UINT,
    pub wParam: WPARAM,
    pub lParam: LPARAM,
    pub time: DWORD,
    pub pt: POINT,
}
#[test]
fn bindgen_test_layout_tagMSG() {
    const UNINIT: ::core::mem::MaybeUninit<tagMSG> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<tagMSG>(),
        48usize,
        concat!("Size of: ", stringify!(tagMSG))
    );
    assert_eq!(
        ::core::mem::align_of::<tagMSG>(),
        8usize,
        concat!("Alignment of ", stringify!(tagMSG))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hwnd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tagMSG),
            "::",
            stringify!(hwnd)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).message) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tagMSG),
            "::",
            stringify!(message)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wParam) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tagMSG),
            "::",
            stringify!(wParam)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lParam) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tagMSG),
            "::",
            stringify!(lParam)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tagMSG),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pt) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(tagMSG),
            "::",
            stringify!(pt)
        )
    );
}
pub type MSG = tagMSG;
#[doc = "\n Structure representing CefExecuteProcess arguments.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_main_args_t {
    pub instance: HINSTANCE,
}
#[test]
fn bindgen_test_layout__cef_main_args_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_main_args_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_main_args_t>(),
        8usize,
        concat!("Size of: ", stringify!(_cef_main_args_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_main_args_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_main_args_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).instance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_main_args_t),
            "::",
            stringify!(instance)
        )
    );
}
#[doc = "\n Structure representing CefExecuteProcess arguments.\n"]
pub type cef_main_args_t = _cef_main_args_t;
#[doc = "\n Structure representing window information.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_window_info_t {
    #[doc = " Standard parameters required by CreateWindowEx()"]
    pub ex_style: DWORD,
    pub window_name: cef_string_t,
    pub style: DWORD,
    pub x: ::core::ffi::c_int,
    pub y: ::core::ffi::c_int,
    pub width: ::core::ffi::c_int,
    pub height: ::core::ffi::c_int,
    pub parent_window: HWND,
    pub menu: HMENU,
    #[doc = "\n Set to true (1) to create the browser using windowless (off-screen)\n rendering. No window will be created for the browser and all rendering will\n occur via the CefRenderHandler interface. The |parent_window| value will be\n used to identify monitor info and to act as the parent window for dialogs,\n context menus, etc. If |parent_window| is not provided then the main screen\n monitor will be used and some functionality that requires a parent window\n may not function correctly. In order to create windowless browsers the\n CefSettings.windowless_rendering_enabled value must be set to true.\n Transparent painting is enabled by default but can be disabled by setting\n CefBrowserSettings.background_color to an opaque value.\n"]
    pub windowless_rendering_enabled: ::core::ffi::c_int,
    #[doc = "\n Set to true (1) to enable shared textures for windowless rendering. Only\n valid if windowless_rendering_enabled above is also set to true. Currently\n only supported on Windows (D3D11).\n"]
    pub shared_texture_enabled: ::core::ffi::c_int,
    #[doc = "\n Set to true (1) to enable the ability to issue BeginFrame requests from the\n client application by calling CefBrowserHost::SendExternalBeginFrame.\n"]
    pub external_begin_frame_enabled: ::core::ffi::c_int,
    #[doc = "\n Handle for the new browser window. Only used with windowed rendering.\n"]
    pub window: HWND,
}
#[test]
fn bindgen_test_layout__cef_window_info_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_window_info_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_window_info_t>(),
        96usize,
        concat!("Size of: ", stringify!(_cef_window_info_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_window_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_window_info_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ex_style) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_window_info_t),
            "::",
            stringify!(ex_style)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).window_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_window_info_t),
            "::",
            stringify!(window_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).style) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_window_info_t),
            "::",
            stringify!(style)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_window_info_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_window_info_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_window_info_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_window_info_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parent_window) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_window_info_t),
            "::",
            stringify!(parent_window)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).menu) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_window_info_t),
            "::",
            stringify!(menu)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).windowless_rendering_enabled) as usize - ptr as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_window_info_t),
            "::",
            stringify!(windowless_rendering_enabled)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).shared_texture_enabled) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_window_info_t),
            "::",
            stringify!(shared_texture_enabled)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).external_begin_frame_enabled) as usize - ptr as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_window_info_t),
            "::",
            stringify!(external_begin_frame_enabled)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_window_info_t),
            "::",
            stringify!(window)
        )
    );
}
#[doc = "\n Structure representing window information.\n"]
pub type cef_window_info_t = _cef_window_info_t;
#[doc = " 32-bit ARGB color value, not premultiplied. The color components are always\n in a known order. Equivalent to the SkColor type."]
pub type cef_color_t = uint32;
#[doc = "\n Default logging (currently INFO logging).\n"]
pub const cef_log_severity_t_LOGSEVERITY_DEFAULT: cef_log_severity_t = 0;
#[doc = "\n Verbose logging.\n"]
pub const cef_log_severity_t_LOGSEVERITY_VERBOSE: cef_log_severity_t = 1;
#[doc = "\n DEBUG logging.\n"]
pub const cef_log_severity_t_LOGSEVERITY_DEBUG: cef_log_severity_t = 1;
#[doc = "\n INFO logging.\n"]
pub const cef_log_severity_t_LOGSEVERITY_INFO: cef_log_severity_t = 2;
#[doc = "\n WARNING logging.\n"]
pub const cef_log_severity_t_LOGSEVERITY_WARNING: cef_log_severity_t = 3;
#[doc = "\n ERROR logging.\n"]
pub const cef_log_severity_t_LOGSEVERITY_ERROR: cef_log_severity_t = 4;
#[doc = "\n FATAL logging.\n"]
pub const cef_log_severity_t_LOGSEVERITY_FATAL: cef_log_severity_t = 5;
#[doc = "\n Disable logging to file for all messages, and to stderr for messages with\n severity less than FATAL.\n"]
pub const cef_log_severity_t_LOGSEVERITY_DISABLE: cef_log_severity_t = 99;
#[doc = "\n Log severity levels.\n"]
pub type cef_log_severity_t = i32;
#[doc = "\n Use the default state for the setting.\n"]
pub const cef_state_t_STATE_DEFAULT: cef_state_t = 0;
#[doc = "\n Enable or allow the setting.\n"]
pub const cef_state_t_STATE_ENABLED: cef_state_t = 1;
#[doc = "\n Disable or disallow the setting.\n"]
pub const cef_state_t_STATE_DISABLED: cef_state_t = 2;
#[doc = "\n Represents the state of a setting.\n"]
pub type cef_state_t = i32;
#[doc = "\n Initialization settings. Specify NULL or 0 to get the recommended default\n values. Many of these and other settings can also configured using command-\n line switches.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_settings_t {
    #[doc = "\n Size of this structure.\n"]
    pub size: usize,
    #[doc = "\n Set to true (1) to disable the sandbox for sub-processes. See\n cef_sandbox_win.h for requirements to enable the sandbox on Windows. Also\n configurable using the \"no-sandbox\" command-line switch.\n"]
    pub no_sandbox: ::core::ffi::c_int,
    #[doc = "\n The path to a separate executable that will be launched for sub-processes.\n If this value is empty on Windows or Linux then the main process executable\n will be used. If this value is empty on macOS then a helper executable must\n exist at \"Contents/Frameworks/<app> Helper.app/Contents/MacOS/<app> Helper\"\n in the top-level app bundle. See the comments on CefExecuteProcess() for\n details. If this value is non-empty then it must be an absolute path. Also\n configurable using the \"browser-subprocess-path\" command-line switch.\n"]
    pub browser_subprocess_path: cef_string_t,
    #[doc = "\n The path to the CEF framework directory on macOS. If this value is empty\n then the framework must exist at \"Contents/Frameworks/Chromium Embedded\n Framework.framework\" in the top-level app bundle. If this value is\n non-empty then it must be an absolute path. Also configurable using the\n \"framework-dir-path\" command-line switch.\n"]
    pub framework_dir_path: cef_string_t,
    #[doc = "\n The path to the main bundle on macOS. If this value is empty then it\n defaults to the top-level app bundle. If this value is non-empty then it\n must be an absolute path. Also configurable using the \"main-bundle-path\"\n command-line switch.\n"]
    pub main_bundle_path: cef_string_t,
    #[doc = "\n Set to true (1) to enable use of the Chrome runtime in CEF. This feature is\n considered experimental and is not recommended for most users at this time.\n See issue #2969 for details.\n"]
    pub chrome_runtime: ::core::ffi::c_int,
    #[doc = "\n Set to true (1) to have the browser process message loop run in a separate\n thread. If false (0) than the CefDoMessageLoopWork() function must be\n called from your application message loop. This option is only supported on\n Windows and Linux.\n"]
    pub multi_threaded_message_loop: ::core::ffi::c_int,
    #[doc = "\n Set to true (1) to control browser process main (UI) thread message pump\n scheduling via the CefBrowserProcessHandler::OnScheduleMessagePumpWork()\n callback. This option is recommended for use in combination with the\n CefDoMessageLoopWork() function in cases where the CEF message loop must be\n integrated into an existing application message loop (see additional\n comments and warnings on CefDoMessageLoopWork). Enabling this option is not\n recommended for most users; leave this option disabled and use either the\n CefRunMessageLoop() function or multi_threaded_message_loop if possible.\n"]
    pub external_message_pump: ::core::ffi::c_int,
    #[doc = "\n Set to true (1) to enable windowless (off-screen) rendering support. Do not\n enable this value if the application does not use windowless rendering as\n it may reduce rendering performance on some systems.\n"]
    pub windowless_rendering_enabled: ::core::ffi::c_int,
    #[doc = "\n Set to true (1) to disable configuration of browser process features using\n standard CEF and Chromium command-line arguments. Configuration can still\n be specified using CEF data structures or via the\n CefApp::OnBeforeCommandLineProcessing() method.\n"]
    pub command_line_args_disabled: ::core::ffi::c_int,
    #[doc = "\n The location where data for the global browser cache will be stored on\n disk. If this value is non-empty then it must be an absolute path that is\n either equal to or a child directory of CefSettings.root_cache_path. If\n this value is empty then browsers will be created in \"incognito mode\" where\n in-memory caches are used for storage and no data is persisted to disk.\n HTML5 databases such as localStorage will only persist across sessions if a\n cache path is specified. Can be overridden for individual CefRequestContext\n instances via the CefRequestContextSettings.cache_path value. When using\n the Chrome runtime the \"default\" profile will be used if |cache_path| and\n |root_cache_path| have the same value.\n"]
    pub cache_path: cef_string_t,
    #[doc = "\n The root directory that all CefSettings.cache_path and\n CefRequestContextSettings.cache_path values must have in common. If this\n value is empty and CefSettings.cache_path is non-empty then it will\n default to the CefSettings.cache_path value. If this value is non-empty\n then it must be an absolute path. Failure to set this value correctly may\n result in the sandbox blocking read/write access to the cache_path\n directory.\n"]
    pub root_cache_path: cef_string_t,
    #[doc = "\n The location where user data such as spell checking dictionary files will\n be stored on disk. If this value is empty then the default\n platform-specific user data directory will be used (\"~/.cef_user_data\"\n directory on Linux, \"~/Library/Application Support/CEF/User Data\" directory\n on Mac OS X, \"Local Settings\\Application Data\\CEF\\User Data\" directory\n under the user profile directory on Windows). If this value is non-empty\n then it must be an absolute path. When using the Chrome runtime this value\n will be ignored in favor of the |root_cache_path| value.\n"]
    pub user_data_path: cef_string_t,
    #[doc = "\n To persist session cookies (cookies without an expiry date or validity\n interval) by default when using the global cookie manager set this value to\n true (1). Session cookies are generally intended to be transient and most\n Web browsers do not persist them. A |cache_path| value must also be\n specified to enable this feature. Also configurable using the\n \"persist-session-cookies\" command-line switch. Can be overridden for\n individual CefRequestContext instances via the\n CefRequestContextSettings.persist_session_cookies value.\n"]
    pub persist_session_cookies: ::core::ffi::c_int,
    #[doc = "\n To persist user preferences as a JSON file in the cache path directory set\n this value to true (1). A |cache_path| value must also be specified\n to enable this feature. Also configurable using the\n \"persist-user-preferences\" command-line switch. Can be overridden for\n individual CefRequestContext instances via the\n CefRequestContextSettings.persist_user_preferences value.\n"]
    pub persist_user_preferences: ::core::ffi::c_int,
    #[doc = "\n Value that will be returned as the User-Agent HTTP header. If empty the\n default User-Agent string will be used. Also configurable using the\n \"user-agent\" command-line switch.\n"]
    pub user_agent: cef_string_t,
    #[doc = "\n Value that will be inserted as the product portion of the default\n User-Agent string. If empty the Chromium product version will be used. If\n |userAgent| is specified this value will be ignored. Also configurable\n using the \"user-agent-product\" command-line switch.\n"]
    pub user_agent_product: cef_string_t,
    #[doc = "\n The locale string that will be passed to WebKit. If empty the default\n locale of \"en-US\" will be used. This value is ignored on Linux where locale\n is determined using environment variable parsing with the precedence order:\n LANGUAGE, LC_ALL, LC_MESSAGES and LANG. Also configurable using the \"lang\"\n command-line switch.\n"]
    pub locale: cef_string_t,
    #[doc = "\n The directory and file name to use for the debug log. If empty a default\n log file name and location will be used. On Windows and Linux a \"debug.log\"\n file will be written in the main executable directory. On Mac OS X a\n \"~/Library/Logs/<app name>_debug.log\" file will be written where <app name>\n is the name of the main app executable. Also configurable using the\n \"log-file\" command-line switch.\n"]
    pub log_file: cef_string_t,
    #[doc = "\n The log severity. Only messages of this severity level or higher will be\n logged. When set to DISABLE no messages will be written to the log file,\n but FATAL messages will still be output to stderr. Also configurable using\n the \"log-severity\" command-line switch with a value of \"verbose\", \"info\",\n \"warning\", \"error\", \"fatal\" or \"disable\".\n"]
    pub log_severity: cef_log_severity_t,
    #[doc = "\n Custom flags that will be used when initializing the V8 JavaScript engine.\n The consequences of using custom flags may not be well tested. Also\n configurable using the \"js-flags\" command-line switch.\n"]
    pub javascript_flags: cef_string_t,
    #[doc = "\n The fully qualified path for the resources directory. If this value is\n empty the *.pak files must be located in the module directory on\n Windows/Linux or the app bundle Resources directory on Mac OS X. If this\n value is non-empty then it must be an absolute path. Also configurable\n using the \"resources-dir-path\" command-line switch.\n"]
    pub resources_dir_path: cef_string_t,
    #[doc = "\n The fully qualified path for the locales directory. If this value is empty\n the locales directory must be located in the module directory. If this\n value is non-empty then it must be an absolute path. This value is ignored\n on Mac OS X where pack files are always loaded from the app bundle\n Resources directory. Also configurable using the \"locales-dir-path\"\n command-line switch.\n"]
    pub locales_dir_path: cef_string_t,
    #[doc = "\n Set to true (1) to disable loading of pack files for resources and locales.\n A resource bundle handler must be provided for the browser and render\n processes via CefApp::GetResourceBundleHandler() if loading of pack files\n is disabled. Also configurable using the \"disable-pack-loading\" command-\n line switch.\n"]
    pub pack_loading_disabled: ::core::ffi::c_int,
    #[doc = "\n Set to a value between 1024 and 65535 to enable remote debugging on the\n specified port. For example, if 8080 is specified the remote debugging URL\n will be http://localhost:8080. CEF can be remotely debugged from any CEF or\n Chrome browser window. Also configurable using the \"remote-debugging-port\"\n command-line switch.\n"]
    pub remote_debugging_port: ::core::ffi::c_int,
    #[doc = "\n The number of stack trace frames to capture for uncaught exceptions.\n Specify a positive value to enable the CefRenderProcessHandler::\n OnUncaughtException() callback. Specify 0 (default value) and\n OnUncaughtException() will not be called. Also configurable using the\n \"uncaught-exception-stack-size\" command-line switch.\n"]
    pub uncaught_exception_stack_size: ::core::ffi::c_int,
    #[doc = "\n Set to true (1) to ignore errors related to invalid SSL certificates.\n Enabling this setting can lead to potential security vulnerabilities like\n \"man in the middle\" attacks. Applications that load content from the\n internet should not enable this setting. Also configurable using the\n \"ignore-certificate-errors\" command-line switch. Can be overridden for\n individual CefRequestContext instances via the\n CefRequestContextSettings.ignore_certificate_errors value.\n"]
    pub ignore_certificate_errors: ::core::ffi::c_int,
    #[doc = "\n Background color used for the browser before a document is loaded and when\n no document color is specified. The alpha component must be either fully\n opaque (0xFF) or fully transparent (0x00). If the alpha component is fully\n opaque then the RGB components will be used as the background color. If the\n alpha component is fully transparent for a windowed browser then the\n default value of opaque white be used. If the alpha component is fully\n transparent for a windowless (off-screen) browser then transparent painting\n will be enabled.\n"]
    pub background_color: cef_color_t,
    #[doc = "\n Comma delimited ordered list of language codes without any whitespace that\n will be used in the \"Accept-Language\" HTTP header. May be overridden on a\n per-browser basis using the CefBrowserSettings.accept_language_list value.\n If both values are empty then \"en-US,en\" will be used. Can be overridden\n for individual CefRequestContext instances via the\n CefRequestContextSettings.accept_language_list value.\n"]
    pub accept_language_list: cef_string_t,
    #[doc = "\n Comma delimited list of schemes supported by the associated\n CefCookieManager. If |cookieable_schemes_exclude_defaults| is false (0) the\n default schemes (\"http\", \"https\", \"ws\" and \"wss\") will also be supported.\n Specifying a |cookieable_schemes_list| value and setting\n |cookieable_schemes_exclude_defaults| to true (1) will disable all loading\n and saving of cookies for this manager. Can be overridden\n for individual CefRequestContext instances via the\n CefRequestContextSettings.cookieable_schemes_list and\n CefRequestContextSettings.cookieable_schemes_exclude_defaults values.\n"]
    pub cookieable_schemes_list: cef_string_t,
    pub cookieable_schemes_exclude_defaults: ::core::ffi::c_int,
    #[doc = "\n GUID string used for identifying the application. This is passed to the\n system AV function for scanning downloaded files. By default, the GUID\n will be an empty string and the file will be treated as an untrusted\n file when the GUID is empty.\n"]
    pub application_client_id_for_file_scanning: cef_string_t,
}
#[test]
fn bindgen_test_layout__cef_settings_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_settings_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_settings_t>(),
        472usize,
        concat!("Size of: ", stringify!(_cef_settings_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_settings_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_settings_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_settings_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).no_sandbox) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_settings_t),
            "::",
            stringify!(no_sandbox)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).browser_subprocess_path) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_settings_t),
            "::",
            stringify!(browser_subprocess_path)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).framework_dir_path) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_settings_t),
            "::",
            stringify!(framework_dir_path)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).main_bundle_path) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_settings_t),
            "::",
            stringify!(main_bundle_path)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chrome_runtime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_settings_t),
            "::",
            stringify!(chrome_runtime)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).multi_threaded_message_loop) as usize - ptr as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_settings_t),
            "::",
            stringify!(multi_threaded_message_loop)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).external_message_pump) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_settings_t),
            "::",
            stringify!(external_message_pump)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).windowless_rendering_enabled) as usize - ptr as usize
        },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_settings_t),
            "::",
            stringify!(windowless_rendering_enabled)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).command_line_args_disabled) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_settings_t),
            "::",
            stringify!(command_line_args_disabled)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cache_path) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_settings_t),
            "::",
            stringify!(cache_path)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).root_cache_path) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_settings_t),
            "::",
            stringify!(root_cache_path)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).user_data_path) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_settings_t),
            "::",
            stringify!(user_data_path)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).persist_session_cookies) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_settings_t),
            "::",
            stringify!(persist_session_cookies)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).persist_user_preferences) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_settings_t),
            "::",
            stringify!(persist_user_preferences)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).user_agent) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_settings_t),
            "::",
            stringify!(user_agent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).user_agent_product) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_settings_t),
            "::",
            stringify!(user_agent_product)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).locale) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_settings_t),
            "::",
            stringify!(locale)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).log_file) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_settings_t),
            "::",
            stringify!(log_file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).log_severity) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_settings_t),
            "::",
            stringify!(log_severity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).javascript_flags) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_settings_t),
            "::",
            stringify!(javascript_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).resources_dir_path) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_settings_t),
            "::",
            stringify!(resources_dir_path)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).locales_dir_path) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_settings_t),
            "::",
            stringify!(locales_dir_path)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pack_loading_disabled) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_settings_t),
            "::",
            stringify!(pack_loading_disabled)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).remote_debugging_port) as usize - ptr as usize },
        372usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_settings_t),
            "::",
            stringify!(remote_debugging_port)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).uncaught_exception_stack_size) as usize - ptr as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_settings_t),
            "::",
            stringify!(uncaught_exception_stack_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ignore_certificate_errors) as usize - ptr as usize },
        380usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_settings_t),
            "::",
            stringify!(ignore_certificate_errors)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).background_color) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_settings_t),
            "::",
            stringify!(background_color)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).accept_language_list) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_settings_t),
            "::",
            stringify!(accept_language_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cookieable_schemes_list) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_settings_t),
            "::",
            stringify!(cookieable_schemes_list)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).cookieable_schemes_exclude_defaults) as usize
                - ptr as usize
        },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_settings_t),
            "::",
            stringify!(cookieable_schemes_exclude_defaults)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).application_client_id_for_file_scanning) as usize
                - ptr as usize
        },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_settings_t),
            "::",
            stringify!(application_client_id_for_file_scanning)
        )
    );
}
#[doc = "\n Initialization settings. Specify NULL or 0 to get the recommended default\n values. Many of these and other settings can also configured using command-\n line switches.\n"]
pub type cef_settings_t = _cef_settings_t;
#[doc = "\n Request context initialization settings. Specify NULL or 0 to get the\n recommended default values.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_request_context_settings_t {
    #[doc = "\n Size of this structure.\n"]
    pub size: usize,
    #[doc = "\n The location where cache data for this request context will be stored on\n disk. If this value is non-empty then it must be an absolute path that is\n either equal to or a child directory of CefSettings.root_cache_path. If\n this value is empty then browsers will be created in \"incognito mode\" where\n in-memory caches are used for storage and no data is persisted to disk.\n HTML5 databases such as localStorage will only persist across sessions if a\n cache path is specified. To share the global browser cache and related\n configuration set this value to match the CefSettings.cache_path value.\n"]
    pub cache_path: cef_string_t,
    #[doc = "\n To persist session cookies (cookies without an expiry date or validity\n interval) by default when using the global cookie manager set this value to\n true (1). Session cookies are generally intended to be transient and most\n Web browsers do not persist them. Can be set globally using the\n CefSettings.persist_session_cookies value. This value will be ignored if\n |cache_path| is empty or if it matches the CefSettings.cache_path value.\n"]
    pub persist_session_cookies: ::core::ffi::c_int,
    #[doc = "\n To persist user preferences as a JSON file in the cache path directory set\n this value to true (1). Can be set globally using the\n CefSettings.persist_user_preferences value. This value will be ignored if\n |cache_path| is empty or if it matches the CefSettings.cache_path value.\n"]
    pub persist_user_preferences: ::core::ffi::c_int,
    #[doc = "\n Set to true (1) to ignore errors related to invalid SSL certificates.\n Enabling this setting can lead to potential security vulnerabilities like\n \"man in the middle\" attacks. Applications that load content from the\n internet should not enable this setting. Can be set globally using the\n CefSettings.ignore_certificate_errors value. This value will be ignored if\n |cache_path| matches the CefSettings.cache_path value.\n"]
    pub ignore_certificate_errors: ::core::ffi::c_int,
    #[doc = "\n Comma delimited ordered list of language codes without any whitespace that\n will be used in the \"Accept-Language\" HTTP header. Can be set globally\n using the CefSettings.accept_language_list value or overridden on a per-\n browser basis using the CefBrowserSettings.accept_language_list value. If\n all values are empty then \"en-US,en\" will be used. This value will be\n ignored if |cache_path| matches the CefSettings.cache_path value.\n"]
    pub accept_language_list: cef_string_t,
    #[doc = "\n Comma delimited list of schemes supported by the associated\n CefCookieManager. If |cookieable_schemes_exclude_defaults| is false (0) the\n default schemes (\"http\", \"https\", \"ws\" and \"wss\") will also be supported.\n Specifying a |cookieable_schemes_list| value and setting\n |cookieable_schemes_exclude_defaults| to true (1) will disable all loading\n and saving of cookies for this manager. These values will be ignored if\n |cache_path| matches the CefSettings.cache_path value.\n"]
    pub cookieable_schemes_list: cef_string_t,
    pub cookieable_schemes_exclude_defaults: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout__cef_request_context_settings_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_request_context_settings_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_request_context_settings_t>(),
        104usize,
        concat!("Size of: ", stringify!(_cef_request_context_settings_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_request_context_settings_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_request_context_settings_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_context_settings_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cache_path) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_context_settings_t),
            "::",
            stringify!(cache_path)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).persist_session_cookies) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_context_settings_t),
            "::",
            stringify!(persist_session_cookies)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).persist_user_preferences) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_context_settings_t),
            "::",
            stringify!(persist_user_preferences)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ignore_certificate_errors) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_context_settings_t),
            "::",
            stringify!(ignore_certificate_errors)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).accept_language_list) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_context_settings_t),
            "::",
            stringify!(accept_language_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cookieable_schemes_list) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_context_settings_t),
            "::",
            stringify!(cookieable_schemes_list)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).cookieable_schemes_exclude_defaults) as usize
                - ptr as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_context_settings_t),
            "::",
            stringify!(cookieable_schemes_exclude_defaults)
        )
    );
}
#[doc = "\n Request context initialization settings. Specify NULL or 0 to get the\n recommended default values.\n"]
pub type cef_request_context_settings_t = _cef_request_context_settings_t;
#[doc = "\n Browser initialization settings. Specify NULL or 0 to get the recommended\n default values. The consequences of using custom values may not be well\n tested. Many of these and other settings can also configured using command-\n line switches.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_browser_settings_t {
    #[doc = "\n Size of this structure.\n"]
    pub size: usize,
    #[doc = "\n The maximum rate in frames per second (fps) that CefRenderHandler::OnPaint\n will be called for a windowless browser. The actual fps may be lower if\n the browser cannot generate frames at the requested rate. The minimum\n value is 1 and the maximum value is 60 (default 30). This value can also be\n changed dynamically via CefBrowserHost::SetWindowlessFrameRate.\n"]
    pub windowless_frame_rate: ::core::ffi::c_int,
    #[doc = "\n Font settings.\n"]
    pub standard_font_family: cef_string_t,
    pub fixed_font_family: cef_string_t,
    pub serif_font_family: cef_string_t,
    pub sans_serif_font_family: cef_string_t,
    pub cursive_font_family: cef_string_t,
    pub fantasy_font_family: cef_string_t,
    pub default_font_size: ::core::ffi::c_int,
    pub default_fixed_font_size: ::core::ffi::c_int,
    pub minimum_font_size: ::core::ffi::c_int,
    pub minimum_logical_font_size: ::core::ffi::c_int,
    #[doc = "\n Default encoding for Web content. If empty \"ISO-8859-1\" will be used. Also\n configurable using the \"default-encoding\" command-line switch.\n"]
    pub default_encoding: cef_string_t,
    #[doc = "\n Controls the loading of fonts from remote sources. Also configurable using\n the \"disable-remote-fonts\" command-line switch.\n"]
    pub remote_fonts: cef_state_t,
    #[doc = "\n Controls whether JavaScript can be executed. Also configurable using the\n \"disable-javascript\" command-line switch.\n"]
    pub javascript: cef_state_t,
    #[doc = "\n Controls whether JavaScript can be used to close windows that were not\n opened via JavaScript. JavaScript can still be used to close windows that\n were opened via JavaScript or that have no back/forward history. Also\n configurable using the \"disable-javascript-close-windows\" command-line\n switch.\n"]
    pub javascript_close_windows: cef_state_t,
    #[doc = "\n Controls whether JavaScript can access the clipboard. Also configurable\n using the \"disable-javascript-access-clipboard\" command-line switch.\n"]
    pub javascript_access_clipboard: cef_state_t,
    #[doc = "\n Controls whether DOM pasting is supported in the editor via\n execCommand(\"paste\"). The |javascript_access_clipboard| setting must also\n be enabled. Also configurable using the \"disable-javascript-dom-paste\"\n command-line switch.\n"]
    pub javascript_dom_paste: cef_state_t,
    #[doc = "\n Controls whether any plugins will be loaded. Also configurable using the\n \"disable-plugins\" command-line switch.\n"]
    pub plugins: cef_state_t,
    #[doc = "\n Controls whether file URLs will have access to all URLs. Also configurable\n using the \"allow-universal-access-from-files\" command-line switch.\n"]
    pub universal_access_from_file_urls: cef_state_t,
    #[doc = "\n Controls whether file URLs will have access to other file URLs. Also\n configurable using the \"allow-access-from-files\" command-line switch.\n"]
    pub file_access_from_file_urls: cef_state_t,
    #[doc = "\n Controls whether image URLs will be loaded from the network. A cached image\n will still be rendered if requested. Also configurable using the\n \"disable-image-loading\" command-line switch.\n"]
    pub image_loading: cef_state_t,
    #[doc = "\n Controls whether standalone images will be shrunk to fit the page. Also\n configurable using the \"image-shrink-standalone-to-fit\" command-line\n switch.\n"]
    pub image_shrink_standalone_to_fit: cef_state_t,
    #[doc = "\n Controls whether text areas can be resized. Also configurable using the\n \"disable-text-area-resize\" command-line switch.\n"]
    pub text_area_resize: cef_state_t,
    #[doc = "\n Controls whether the tab key can advance focus to links. Also configurable\n using the \"disable-tab-to-links\" command-line switch.\n"]
    pub tab_to_links: cef_state_t,
    #[doc = "\n Controls whether local storage can be used. Also configurable using the\n \"disable-local-storage\" command-line switch.\n"]
    pub local_storage: cef_state_t,
    #[doc = "\n Controls whether databases can be used. Also configurable using the\n \"disable-databases\" command-line switch.\n"]
    pub databases: cef_state_t,
    #[doc = "\n Controls whether the application cache can be used. Also configurable using\n the \"disable-application-cache\" command-line switch.\n"]
    pub application_cache: cef_state_t,
    #[doc = "\n Controls whether WebGL can be used. Note that WebGL requires hardware\n support and may not work on all systems even when enabled. Also\n configurable using the \"disable-webgl\" command-line switch.\n"]
    pub webgl: cef_state_t,
    #[doc = "\n Background color used for the browser before a document is loaded and when\n no document color is specified. The alpha component must be either fully\n opaque (0xFF) or fully transparent (0x00). If the alpha component is fully\n opaque then the RGB components will be used as the background color. If the\n alpha component is fully transparent for a windowed browser then the\n CefSettings.background_color value will be used. If the alpha component is\n fully transparent for a windowless (off-screen) browser then transparent\n painting will be enabled.\n"]
    pub background_color: cef_color_t,
    #[doc = "\n Comma delimited ordered list of language codes without any whitespace that\n will be used in the \"Accept-Language\" HTTP header. May be set globally\n using the CefSettings.accept_language_list value. If both values are\n empty then \"en-US,en\" will be used.\n"]
    pub accept_language_list: cef_string_t,
}
#[test]
fn bindgen_test_layout__cef_browser_settings_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_browser_settings_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_browser_settings_t>(),
        296usize,
        concat!("Size of: ", stringify!(_cef_browser_settings_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_browser_settings_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_browser_settings_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_settings_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).windowless_frame_rate) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_settings_t),
            "::",
            stringify!(windowless_frame_rate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).standard_font_family) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_settings_t),
            "::",
            stringify!(standard_font_family)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fixed_font_family) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_settings_t),
            "::",
            stringify!(fixed_font_family)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).serif_font_family) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_settings_t),
            "::",
            stringify!(serif_font_family)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sans_serif_font_family) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_settings_t),
            "::",
            stringify!(sans_serif_font_family)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cursive_font_family) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_settings_t),
            "::",
            stringify!(cursive_font_family)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fantasy_font_family) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_settings_t),
            "::",
            stringify!(fantasy_font_family)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).default_font_size) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_settings_t),
            "::",
            stringify!(default_font_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).default_fixed_font_size) as usize - ptr as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_settings_t),
            "::",
            stringify!(default_fixed_font_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).minimum_font_size) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_settings_t),
            "::",
            stringify!(minimum_font_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).minimum_logical_font_size) as usize - ptr as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_settings_t),
            "::",
            stringify!(minimum_logical_font_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).default_encoding) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_settings_t),
            "::",
            stringify!(default_encoding)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).remote_fonts) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_settings_t),
            "::",
            stringify!(remote_fonts)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).javascript) as usize - ptr as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_settings_t),
            "::",
            stringify!(javascript)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).javascript_close_windows) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_settings_t),
            "::",
            stringify!(javascript_close_windows)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).javascript_access_clipboard) as usize - ptr as usize
        },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_settings_t),
            "::",
            stringify!(javascript_access_clipboard)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).javascript_dom_paste) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_settings_t),
            "::",
            stringify!(javascript_dom_paste)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).plugins) as usize - ptr as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_settings_t),
            "::",
            stringify!(plugins)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).universal_access_from_file_urls) as usize - ptr as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_settings_t),
            "::",
            stringify!(universal_access_from_file_urls)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).file_access_from_file_urls) as usize - ptr as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_settings_t),
            "::",
            stringify!(file_access_from_file_urls)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).image_loading) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_settings_t),
            "::",
            stringify!(image_loading)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).image_shrink_standalone_to_fit) as usize - ptr as usize
        },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_settings_t),
            "::",
            stringify!(image_shrink_standalone_to_fit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).text_area_resize) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_settings_t),
            "::",
            stringify!(text_area_resize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tab_to_links) as usize - ptr as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_settings_t),
            "::",
            stringify!(tab_to_links)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).local_storage) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_settings_t),
            "::",
            stringify!(local_storage)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).databases) as usize - ptr as usize },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_settings_t),
            "::",
            stringify!(databases)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).application_cache) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_settings_t),
            "::",
            stringify!(application_cache)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).webgl) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_settings_t),
            "::",
            stringify!(webgl)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).background_color) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_settings_t),
            "::",
            stringify!(background_color)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).accept_language_list) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_settings_t),
            "::",
            stringify!(accept_language_list)
        )
    );
}
#[doc = "\n Browser initialization settings. Specify NULL or 0 to get the recommended\n default values. The consequences of using custom values may not be well\n tested. Many of these and other settings can also configured using command-\n line switches.\n"]
pub type cef_browser_settings_t = _cef_browser_settings_t;
#[doc = "\n Cancel immediately.\n"]
pub const cef_return_value_t_RV_CANCEL: cef_return_value_t = 0;
#[doc = "\n Continue immediately.\n"]
pub const cef_return_value_t_RV_CONTINUE: cef_return_value_t = 1;
#[doc = "\n Continue asynchronously (usually via a callback).\n"]
pub const cef_return_value_t_RV_CONTINUE_ASYNC: cef_return_value_t = 2;
#[doc = "\n Return value types.\n"]
pub type cef_return_value_t = i32;
#[doc = "\n URL component parts.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_urlparts_t {
    #[doc = "\n The complete URL specification.\n"]
    pub spec: cef_string_t,
    #[doc = "\n Scheme component not including the colon (e.g., \"http\").\n"]
    pub scheme: cef_string_t,
    #[doc = "\n User name component.\n"]
    pub username: cef_string_t,
    #[doc = "\n Password component.\n"]
    pub password: cef_string_t,
    #[doc = "\n Host component. This may be a hostname, an IPv4 address or an IPv6 literal\n surrounded by square brackets (e.g., \"[2001:db8::1]\").\n"]
    pub host: cef_string_t,
    #[doc = "\n Port number component.\n"]
    pub port: cef_string_t,
    #[doc = "\n Origin contains just the scheme, host, and port from a URL. Equivalent to\n clearing any username and password, replacing the path with a slash, and\n clearing everything after that. This value will be empty for non-standard\n URLs.\n"]
    pub origin: cef_string_t,
    #[doc = "\n Path component including the first slash following the host.\n"]
    pub path: cef_string_t,
    #[doc = "\n Query string component (i.e., everything following the '?').\n"]
    pub query: cef_string_t,
    #[doc = "\n Fragment (hash) identifier component (i.e., the string following the '#').\n"]
    pub fragment: cef_string_t,
}
#[test]
fn bindgen_test_layout__cef_urlparts_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_urlparts_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_urlparts_t>(),
        240usize,
        concat!("Size of: ", stringify!(_cef_urlparts_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_urlparts_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_urlparts_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).spec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_urlparts_t),
            "::",
            stringify!(spec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scheme) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_urlparts_t),
            "::",
            stringify!(scheme)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).username) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_urlparts_t),
            "::",
            stringify!(username)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).password) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_urlparts_t),
            "::",
            stringify!(password)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).host) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_urlparts_t),
            "::",
            stringify!(host)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_urlparts_t),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).origin) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_urlparts_t),
            "::",
            stringify!(origin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).path) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_urlparts_t),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).query) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_urlparts_t),
            "::",
            stringify!(query)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fragment) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_urlparts_t),
            "::",
            stringify!(fragment)
        )
    );
}
#[doc = "\n URL component parts.\n"]
pub type cef_urlparts_t = _cef_urlparts_t;
pub const cef_cookie_priority_t_CEF_COOKIE_PRIORITY_LOW: cef_cookie_priority_t = -1;
pub const cef_cookie_priority_t_CEF_COOKIE_PRIORITY_MEDIUM: cef_cookie_priority_t = 0;
pub const cef_cookie_priority_t_CEF_COOKIE_PRIORITY_HIGH: cef_cookie_priority_t = 1;
#[doc = "\n Cookie priority values.\n"]
pub type cef_cookie_priority_t = i32;
pub const cef_cookie_same_site_t_CEF_COOKIE_SAME_SITE_UNSPECIFIED: cef_cookie_same_site_t = 0;
pub const cef_cookie_same_site_t_CEF_COOKIE_SAME_SITE_NO_RESTRICTION: cef_cookie_same_site_t = 1;
pub const cef_cookie_same_site_t_CEF_COOKIE_SAME_SITE_LAX_MODE: cef_cookie_same_site_t = 2;
pub const cef_cookie_same_site_t_CEF_COOKIE_SAME_SITE_STRICT_MODE: cef_cookie_same_site_t = 3;
#[doc = "\n Cookie same site values.\n"]
pub type cef_cookie_same_site_t = i32;
#[doc = "\n Cookie information.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_cookie_t {
    #[doc = "\n The cookie name.\n"]
    pub name: cef_string_t,
    #[doc = "\n The cookie value.\n"]
    pub value: cef_string_t,
    #[doc = "\n If |domain| is empty a host cookie will be created instead of a domain\n cookie. Domain cookies are stored with a leading \".\" and are visible to\n sub-domains whereas host cookies are not.\n"]
    pub domain: cef_string_t,
    #[doc = "\n If |path| is non-empty only URLs at or below the path will get the cookie\n value.\n"]
    pub path: cef_string_t,
    #[doc = "\n If |secure| is true the cookie will only be sent for HTTPS requests.\n"]
    pub secure: ::core::ffi::c_int,
    #[doc = "\n If |httponly| is true the cookie will only be sent for HTTP requests.\n"]
    pub httponly: ::core::ffi::c_int,
    #[doc = "\n The cookie creation date. This is automatically populated by the system on\n cookie creation.\n"]
    pub creation: cef_time_t,
    #[doc = "\n The cookie last access date. This is automatically populated by the system\n on access.\n"]
    pub last_access: cef_time_t,
    #[doc = "\n The cookie expiration date is only valid if |has_expires| is true.\n"]
    pub has_expires: ::core::ffi::c_int,
    pub expires: cef_time_t,
    #[doc = "\n Same site.\n"]
    pub same_site: cef_cookie_same_site_t,
    #[doc = "\n Priority.\n"]
    pub priority: cef_cookie_priority_t,
}
#[test]
fn bindgen_test_layout__cef_cookie_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_cookie_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_cookie_t>(),
        216usize,
        concat!("Size of: ", stringify!(_cef_cookie_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_cookie_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_cookie_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_cookie_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_cookie_t),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).domain) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_cookie_t),
            "::",
            stringify!(domain)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).path) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_cookie_t),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).secure) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_cookie_t),
            "::",
            stringify!(secure)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).httponly) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_cookie_t),
            "::",
            stringify!(httponly)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).creation) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_cookie_t),
            "::",
            stringify!(creation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).last_access) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_cookie_t),
            "::",
            stringify!(last_access)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_expires) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_cookie_t),
            "::",
            stringify!(has_expires)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).expires) as usize - ptr as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_cookie_t),
            "::",
            stringify!(expires)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).same_site) as usize - ptr as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_cookie_t),
            "::",
            stringify!(same_site)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_cookie_t),
            "::",
            stringify!(priority)
        )
    );
}
#[doc = "\n Cookie information.\n"]
pub type cef_cookie_t = _cef_cookie_t;
#[doc = "\n Non-zero exit status.\n"]
pub const cef_termination_status_t_TS_ABNORMAL_TERMINATION: cef_termination_status_t = 0;
#[doc = "\n SIGKILL or task manager kill.\n"]
pub const cef_termination_status_t_TS_PROCESS_WAS_KILLED: cef_termination_status_t = 1;
#[doc = "\n Segmentation fault.\n"]
pub const cef_termination_status_t_TS_PROCESS_CRASHED: cef_termination_status_t = 2;
#[doc = "\n Out of memory. Some platforms may use TS_PROCESS_CRASHED instead.\n"]
pub const cef_termination_status_t_TS_PROCESS_OOM: cef_termination_status_t = 3;
#[doc = "\n Process termination status values.\n"]
pub type cef_termination_status_t = i32;
#[doc = "\n Current directory.\n"]
pub const cef_path_key_t_PK_DIR_CURRENT: cef_path_key_t = 0;
#[doc = "\n Directory containing PK_FILE_EXE.\n"]
pub const cef_path_key_t_PK_DIR_EXE: cef_path_key_t = 1;
#[doc = "\n Directory containing PK_FILE_MODULE.\n"]
pub const cef_path_key_t_PK_DIR_MODULE: cef_path_key_t = 2;
#[doc = "\n Temporary directory.\n"]
pub const cef_path_key_t_PK_DIR_TEMP: cef_path_key_t = 3;
#[doc = "\n Path and filename of the current executable.\n"]
pub const cef_path_key_t_PK_FILE_EXE: cef_path_key_t = 4;
#[doc = "\n Path and filename of the module containing the CEF code (usually the libcef\n module).\n"]
pub const cef_path_key_t_PK_FILE_MODULE: cef_path_key_t = 5;
#[doc = "\n \"Local Settings\\Application Data\" directory under the user profile\n directory on Windows.\n"]
pub const cef_path_key_t_PK_LOCAL_APP_DATA: cef_path_key_t = 6;
#[doc = "\n \"Application Data\" directory under the user profile directory on Windows\n and \"~/Library/Application Support\" directory on Mac OS X.\n"]
pub const cef_path_key_t_PK_USER_DATA: cef_path_key_t = 7;
#[doc = "\n Directory containing application resources. Can be configured via\n CefSettings.resources_dir_path.\n"]
pub const cef_path_key_t_PK_DIR_RESOURCES: cef_path_key_t = 8;
#[doc = "\n Path key values.\n"]
pub type cef_path_key_t = i32;
pub const cef_storage_type_t_ST_LOCALSTORAGE: cef_storage_type_t = 0;
pub const cef_storage_type_t_ST_SESSIONSTORAGE: cef_storage_type_t = 1;
#[doc = "\n Storage types.\n"]
pub type cef_storage_type_t = i32;
#[doc = " No error."]
pub const cef_errorcode_t_ERR_NONE: cef_errorcode_t = 0;
pub const cef_errorcode_t_ERR_IO_PENDING: cef_errorcode_t = -1;
pub const cef_errorcode_t_ERR_FAILED: cef_errorcode_t = -2;
pub const cef_errorcode_t_ERR_ABORTED: cef_errorcode_t = -3;
pub const cef_errorcode_t_ERR_INVALID_ARGUMENT: cef_errorcode_t = -4;
pub const cef_errorcode_t_ERR_INVALID_HANDLE: cef_errorcode_t = -5;
pub const cef_errorcode_t_ERR_FILE_NOT_FOUND: cef_errorcode_t = -6;
pub const cef_errorcode_t_ERR_TIMED_OUT: cef_errorcode_t = -7;
pub const cef_errorcode_t_ERR_FILE_TOO_BIG: cef_errorcode_t = -8;
pub const cef_errorcode_t_ERR_UNEXPECTED: cef_errorcode_t = -9;
pub const cef_errorcode_t_ERR_ACCESS_DENIED: cef_errorcode_t = -10;
pub const cef_errorcode_t_ERR_NOT_IMPLEMENTED: cef_errorcode_t = -11;
pub const cef_errorcode_t_ERR_INSUFFICIENT_RESOURCES: cef_errorcode_t = -12;
pub const cef_errorcode_t_ERR_OUT_OF_MEMORY: cef_errorcode_t = -13;
pub const cef_errorcode_t_ERR_UPLOAD_FILE_CHANGED: cef_errorcode_t = -14;
pub const cef_errorcode_t_ERR_SOCKET_NOT_CONNECTED: cef_errorcode_t = -15;
pub const cef_errorcode_t_ERR_FILE_EXISTS: cef_errorcode_t = -16;
pub const cef_errorcode_t_ERR_FILE_PATH_TOO_LONG: cef_errorcode_t = -17;
pub const cef_errorcode_t_ERR_FILE_NO_SPACE: cef_errorcode_t = -18;
pub const cef_errorcode_t_ERR_FILE_VIRUS_INFECTED: cef_errorcode_t = -19;
pub const cef_errorcode_t_ERR_BLOCKED_BY_CLIENT: cef_errorcode_t = -20;
pub const cef_errorcode_t_ERR_NETWORK_CHANGED: cef_errorcode_t = -21;
pub const cef_errorcode_t_ERR_BLOCKED_BY_ADMINISTRATOR: cef_errorcode_t = -22;
pub const cef_errorcode_t_ERR_SOCKET_IS_CONNECTED: cef_errorcode_t = -23;
pub const cef_errorcode_t_ERR_BLOCKED_ENROLLMENT_CHECK_PENDING: cef_errorcode_t = -24;
pub const cef_errorcode_t_ERR_UPLOAD_STREAM_REWIND_NOT_SUPPORTED: cef_errorcode_t = -25;
pub const cef_errorcode_t_ERR_CONTEXT_SHUT_DOWN: cef_errorcode_t = -26;
pub const cef_errorcode_t_ERR_BLOCKED_BY_RESPONSE: cef_errorcode_t = -27;
pub const cef_errorcode_t_ERR_CLEARTEXT_NOT_PERMITTED: cef_errorcode_t = -29;
pub const cef_errorcode_t_ERR_BLOCKED_BY_CSP: cef_errorcode_t = -30;
pub const cef_errorcode_t_ERR_H2_OR_QUIC_REQUIRED: cef_errorcode_t = -31;
pub const cef_errorcode_t_ERR_CONNECTION_CLOSED: cef_errorcode_t = -100;
pub const cef_errorcode_t_ERR_CONNECTION_RESET: cef_errorcode_t = -101;
pub const cef_errorcode_t_ERR_CONNECTION_REFUSED: cef_errorcode_t = -102;
pub const cef_errorcode_t_ERR_CONNECTION_ABORTED: cef_errorcode_t = -103;
pub const cef_errorcode_t_ERR_CONNECTION_FAILED: cef_errorcode_t = -104;
pub const cef_errorcode_t_ERR_NAME_NOT_RESOLVED: cef_errorcode_t = -105;
pub const cef_errorcode_t_ERR_INTERNET_DISCONNECTED: cef_errorcode_t = -106;
pub const cef_errorcode_t_ERR_SSL_PROTOCOL_ERROR: cef_errorcode_t = -107;
pub const cef_errorcode_t_ERR_ADDRESS_INVALID: cef_errorcode_t = -108;
pub const cef_errorcode_t_ERR_ADDRESS_UNREACHABLE: cef_errorcode_t = -109;
pub const cef_errorcode_t_ERR_SSL_CLIENT_AUTH_CERT_NEEDED: cef_errorcode_t = -110;
pub const cef_errorcode_t_ERR_TUNNEL_CONNECTION_FAILED: cef_errorcode_t = -111;
pub const cef_errorcode_t_ERR_NO_SSL_VERSIONS_ENABLED: cef_errorcode_t = -112;
pub const cef_errorcode_t_ERR_SSL_VERSION_OR_CIPHER_MISMATCH: cef_errorcode_t = -113;
pub const cef_errorcode_t_ERR_SSL_RENEGOTIATION_REQUESTED: cef_errorcode_t = -114;
pub const cef_errorcode_t_ERR_PROXY_AUTH_UNSUPPORTED: cef_errorcode_t = -115;
pub const cef_errorcode_t_ERR_CERT_ERROR_IN_SSL_RENEGOTIATION: cef_errorcode_t = -116;
pub const cef_errorcode_t_ERR_BAD_SSL_CLIENT_AUTH_CERT: cef_errorcode_t = -117;
pub const cef_errorcode_t_ERR_CONNECTION_TIMED_OUT: cef_errorcode_t = -118;
pub const cef_errorcode_t_ERR_HOST_RESOLVER_QUEUE_TOO_LARGE: cef_errorcode_t = -119;
pub const cef_errorcode_t_ERR_SOCKS_CONNECTION_FAILED: cef_errorcode_t = -120;
pub const cef_errorcode_t_ERR_SOCKS_CONNECTION_HOST_UNREACHABLE: cef_errorcode_t = -121;
pub const cef_errorcode_t_ERR_ALPN_NEGOTIATION_FAILED: cef_errorcode_t = -122;
pub const cef_errorcode_t_ERR_SSL_NO_RENEGOTIATION: cef_errorcode_t = -123;
pub const cef_errorcode_t_ERR_WINSOCK_UNEXPECTED_WRITTEN_BYTES: cef_errorcode_t = -124;
pub const cef_errorcode_t_ERR_SSL_DECOMPRESSION_FAILURE_ALERT: cef_errorcode_t = -125;
pub const cef_errorcode_t_ERR_SSL_BAD_RECORD_MAC_ALERT: cef_errorcode_t = -126;
pub const cef_errorcode_t_ERR_PROXY_AUTH_REQUESTED: cef_errorcode_t = -127;
pub const cef_errorcode_t_ERR_PROXY_CONNECTION_FAILED: cef_errorcode_t = -130;
pub const cef_errorcode_t_ERR_MANDATORY_PROXY_CONFIGURATION_FAILED: cef_errorcode_t = -131;
pub const cef_errorcode_t_ERR_PRECONNECT_MAX_SOCKET_LIMIT: cef_errorcode_t = -133;
pub const cef_errorcode_t_ERR_SSL_CLIENT_AUTH_PRIVATE_KEY_ACCESS_DENIED: cef_errorcode_t = -134;
pub const cef_errorcode_t_ERR_SSL_CLIENT_AUTH_CERT_NO_PRIVATE_KEY: cef_errorcode_t = -135;
pub const cef_errorcode_t_ERR_PROXY_CERTIFICATE_INVALID: cef_errorcode_t = -136;
pub const cef_errorcode_t_ERR_NAME_RESOLUTION_FAILED: cef_errorcode_t = -137;
pub const cef_errorcode_t_ERR_NETWORK_ACCESS_DENIED: cef_errorcode_t = -138;
pub const cef_errorcode_t_ERR_TEMPORARILY_THROTTLED: cef_errorcode_t = -139;
pub const cef_errorcode_t_ERR_HTTPS_PROXY_TUNNEL_RESPONSE_REDIRECT: cef_errorcode_t = -140;
pub const cef_errorcode_t_ERR_SSL_CLIENT_AUTH_SIGNATURE_FAILED: cef_errorcode_t = -141;
pub const cef_errorcode_t_ERR_MSG_TOO_BIG: cef_errorcode_t = -142;
pub const cef_errorcode_t_ERR_WS_PROTOCOL_ERROR: cef_errorcode_t = -145;
pub const cef_errorcode_t_ERR_ADDRESS_IN_USE: cef_errorcode_t = -147;
pub const cef_errorcode_t_ERR_SSL_HANDSHAKE_NOT_COMPLETED: cef_errorcode_t = -148;
pub const cef_errorcode_t_ERR_SSL_BAD_PEER_PUBLIC_KEY: cef_errorcode_t = -149;
pub const cef_errorcode_t_ERR_SSL_PINNED_KEY_NOT_IN_CERT_CHAIN: cef_errorcode_t = -150;
pub const cef_errorcode_t_ERR_CLIENT_AUTH_CERT_TYPE_UNSUPPORTED: cef_errorcode_t = -151;
pub const cef_errorcode_t_ERR_SSL_DECRYPT_ERROR_ALERT: cef_errorcode_t = -153;
pub const cef_errorcode_t_ERR_WS_THROTTLE_QUEUE_TOO_LARGE: cef_errorcode_t = -154;
pub const cef_errorcode_t_ERR_SSL_SERVER_CERT_CHANGED: cef_errorcode_t = -156;
pub const cef_errorcode_t_ERR_SSL_UNRECOGNIZED_NAME_ALERT: cef_errorcode_t = -159;
pub const cef_errorcode_t_ERR_SOCKET_SET_RECEIVE_BUFFER_SIZE_ERROR: cef_errorcode_t = -160;
pub const cef_errorcode_t_ERR_SOCKET_SET_SEND_BUFFER_SIZE_ERROR: cef_errorcode_t = -161;
pub const cef_errorcode_t_ERR_SOCKET_RECEIVE_BUFFER_SIZE_UNCHANGEABLE: cef_errorcode_t = -162;
pub const cef_errorcode_t_ERR_SOCKET_SEND_BUFFER_SIZE_UNCHANGEABLE: cef_errorcode_t = -163;
pub const cef_errorcode_t_ERR_SSL_CLIENT_AUTH_CERT_BAD_FORMAT: cef_errorcode_t = -164;
pub const cef_errorcode_t_ERR_ICANN_NAME_COLLISION: cef_errorcode_t = -166;
pub const cef_errorcode_t_ERR_SSL_SERVER_CERT_BAD_FORMAT: cef_errorcode_t = -167;
pub const cef_errorcode_t_ERR_CT_STH_PARSING_FAILED: cef_errorcode_t = -168;
pub const cef_errorcode_t_ERR_CT_STH_INCOMPLETE: cef_errorcode_t = -169;
pub const cef_errorcode_t_ERR_UNABLE_TO_REUSE_CONNECTION_FOR_PROXY_AUTH: cef_errorcode_t = -170;
pub const cef_errorcode_t_ERR_CT_CONSISTENCY_PROOF_PARSING_FAILED: cef_errorcode_t = -171;
pub const cef_errorcode_t_ERR_SSL_OBSOLETE_CIPHER: cef_errorcode_t = -172;
pub const cef_errorcode_t_ERR_WS_UPGRADE: cef_errorcode_t = -173;
pub const cef_errorcode_t_ERR_READ_IF_READY_NOT_IMPLEMENTED: cef_errorcode_t = -174;
pub const cef_errorcode_t_ERR_NO_BUFFER_SPACE: cef_errorcode_t = -176;
pub const cef_errorcode_t_ERR_SSL_CLIENT_AUTH_NO_COMMON_ALGORITHMS: cef_errorcode_t = -177;
pub const cef_errorcode_t_ERR_EARLY_DATA_REJECTED: cef_errorcode_t = -178;
pub const cef_errorcode_t_ERR_WRONG_VERSION_ON_EARLY_DATA: cef_errorcode_t = -179;
pub const cef_errorcode_t_ERR_TLS13_DOWNGRADE_DETECTED: cef_errorcode_t = -180;
pub const cef_errorcode_t_ERR_SSL_KEY_USAGE_INCOMPATIBLE: cef_errorcode_t = -181;
pub const cef_errorcode_t_ERR_CERT_COMMON_NAME_INVALID: cef_errorcode_t = -200;
pub const cef_errorcode_t_ERR_CERT_DATE_INVALID: cef_errorcode_t = -201;
pub const cef_errorcode_t_ERR_CERT_AUTHORITY_INVALID: cef_errorcode_t = -202;
pub const cef_errorcode_t_ERR_CERT_CONTAINS_ERRORS: cef_errorcode_t = -203;
pub const cef_errorcode_t_ERR_CERT_NO_REVOCATION_MECHANISM: cef_errorcode_t = -204;
pub const cef_errorcode_t_ERR_CERT_UNABLE_TO_CHECK_REVOCATION: cef_errorcode_t = -205;
pub const cef_errorcode_t_ERR_CERT_REVOKED: cef_errorcode_t = -206;
pub const cef_errorcode_t_ERR_CERT_INVALID: cef_errorcode_t = -207;
pub const cef_errorcode_t_ERR_CERT_WEAK_SIGNATURE_ALGORITHM: cef_errorcode_t = -208;
pub const cef_errorcode_t_ERR_CERT_NON_UNIQUE_NAME: cef_errorcode_t = -210;
pub const cef_errorcode_t_ERR_CERT_WEAK_KEY: cef_errorcode_t = -211;
pub const cef_errorcode_t_ERR_CERT_NAME_CONSTRAINT_VIOLATION: cef_errorcode_t = -212;
pub const cef_errorcode_t_ERR_CERT_VALIDITY_TOO_LONG: cef_errorcode_t = -213;
pub const cef_errorcode_t_ERR_CERTIFICATE_TRANSPARENCY_REQUIRED: cef_errorcode_t = -214;
pub const cef_errorcode_t_ERR_CERT_SYMANTEC_LEGACY: cef_errorcode_t = -215;
pub const cef_errorcode_t_ERR_CERT_KNOWN_INTERCEPTION_BLOCKED: cef_errorcode_t = -217;
pub const cef_errorcode_t_ERR_SSL_OBSOLETE_VERSION: cef_errorcode_t = -218;
pub const cef_errorcode_t_ERR_CERT_END: cef_errorcode_t = -219;
pub const cef_errorcode_t_ERR_INVALID_URL: cef_errorcode_t = -300;
pub const cef_errorcode_t_ERR_DISALLOWED_URL_SCHEME: cef_errorcode_t = -301;
pub const cef_errorcode_t_ERR_UNKNOWN_URL_SCHEME: cef_errorcode_t = -302;
pub const cef_errorcode_t_ERR_INVALID_REDIRECT: cef_errorcode_t = -303;
pub const cef_errorcode_t_ERR_TOO_MANY_REDIRECTS: cef_errorcode_t = -310;
pub const cef_errorcode_t_ERR_UNSAFE_REDIRECT: cef_errorcode_t = -311;
pub const cef_errorcode_t_ERR_UNSAFE_PORT: cef_errorcode_t = -312;
pub const cef_errorcode_t_ERR_INVALID_RESPONSE: cef_errorcode_t = -320;
pub const cef_errorcode_t_ERR_INVALID_CHUNKED_ENCODING: cef_errorcode_t = -321;
pub const cef_errorcode_t_ERR_METHOD_NOT_SUPPORTED: cef_errorcode_t = -322;
pub const cef_errorcode_t_ERR_UNEXPECTED_PROXY_AUTH: cef_errorcode_t = -323;
pub const cef_errorcode_t_ERR_EMPTY_RESPONSE: cef_errorcode_t = -324;
pub const cef_errorcode_t_ERR_RESPONSE_HEADERS_TOO_BIG: cef_errorcode_t = -325;
pub const cef_errorcode_t_ERR_PAC_SCRIPT_FAILED: cef_errorcode_t = -327;
pub const cef_errorcode_t_ERR_REQUEST_RANGE_NOT_SATISFIABLE: cef_errorcode_t = -328;
pub const cef_errorcode_t_ERR_MALFORMED_IDENTITY: cef_errorcode_t = -329;
pub const cef_errorcode_t_ERR_CONTENT_DECODING_FAILED: cef_errorcode_t = -330;
pub const cef_errorcode_t_ERR_NETWORK_IO_SUSPENDED: cef_errorcode_t = -331;
pub const cef_errorcode_t_ERR_SYN_REPLY_NOT_RECEIVED: cef_errorcode_t = -332;
pub const cef_errorcode_t_ERR_ENCODING_CONVERSION_FAILED: cef_errorcode_t = -333;
pub const cef_errorcode_t_ERR_UNRECOGNIZED_FTP_DIRECTORY_LISTING_FORMAT: cef_errorcode_t = -334;
pub const cef_errorcode_t_ERR_NO_SUPPORTED_PROXIES: cef_errorcode_t = -336;
pub const cef_errorcode_t_ERR_HTTP2_PROTOCOL_ERROR: cef_errorcode_t = -337;
pub const cef_errorcode_t_ERR_INVALID_AUTH_CREDENTIALS: cef_errorcode_t = -338;
pub const cef_errorcode_t_ERR_UNSUPPORTED_AUTH_SCHEME: cef_errorcode_t = -339;
pub const cef_errorcode_t_ERR_ENCODING_DETECTION_FAILED: cef_errorcode_t = -340;
pub const cef_errorcode_t_ERR_MISSING_AUTH_CREDENTIALS: cef_errorcode_t = -341;
pub const cef_errorcode_t_ERR_UNEXPECTED_SECURITY_LIBRARY_STATUS: cef_errorcode_t = -342;
pub const cef_errorcode_t_ERR_MISCONFIGURED_AUTH_ENVIRONMENT: cef_errorcode_t = -343;
pub const cef_errorcode_t_ERR_UNDOCUMENTED_SECURITY_LIBRARY_STATUS: cef_errorcode_t = -344;
pub const cef_errorcode_t_ERR_RESPONSE_BODY_TOO_BIG_TO_DRAIN: cef_errorcode_t = -345;
pub const cef_errorcode_t_ERR_RESPONSE_HEADERS_MULTIPLE_CONTENT_LENGTH: cef_errorcode_t = -346;
pub const cef_errorcode_t_ERR_INCOMPLETE_HTTP2_HEADERS: cef_errorcode_t = -347;
pub const cef_errorcode_t_ERR_PAC_NOT_IN_DHCP: cef_errorcode_t = -348;
pub const cef_errorcode_t_ERR_RESPONSE_HEADERS_MULTIPLE_CONTENT_DISPOSITION: cef_errorcode_t = -349;
pub const cef_errorcode_t_ERR_RESPONSE_HEADERS_MULTIPLE_LOCATION: cef_errorcode_t = -350;
pub const cef_errorcode_t_ERR_HTTP2_SERVER_REFUSED_STREAM: cef_errorcode_t = -351;
pub const cef_errorcode_t_ERR_HTTP2_PING_FAILED: cef_errorcode_t = -352;
pub const cef_errorcode_t_ERR_CONTENT_LENGTH_MISMATCH: cef_errorcode_t = -354;
pub const cef_errorcode_t_ERR_INCOMPLETE_CHUNKED_ENCODING: cef_errorcode_t = -355;
pub const cef_errorcode_t_ERR_QUIC_PROTOCOL_ERROR: cef_errorcode_t = -356;
pub const cef_errorcode_t_ERR_RESPONSE_HEADERS_TRUNCATED: cef_errorcode_t = -357;
pub const cef_errorcode_t_ERR_QUIC_HANDSHAKE_FAILED: cef_errorcode_t = -358;
pub const cef_errorcode_t_ERR_HTTP2_INADEQUATE_TRANSPORT_SECURITY: cef_errorcode_t = -360;
pub const cef_errorcode_t_ERR_HTTP2_FLOW_CONTROL_ERROR: cef_errorcode_t = -361;
pub const cef_errorcode_t_ERR_HTTP2_FRAME_SIZE_ERROR: cef_errorcode_t = -362;
pub const cef_errorcode_t_ERR_HTTP2_COMPRESSION_ERROR: cef_errorcode_t = -363;
pub const cef_errorcode_t_ERR_PROXY_AUTH_REQUESTED_WITH_NO_CONNECTION: cef_errorcode_t = -364;
pub const cef_errorcode_t_ERR_HTTP_1_1_REQUIRED: cef_errorcode_t = -365;
pub const cef_errorcode_t_ERR_PROXY_HTTP_1_1_REQUIRED: cef_errorcode_t = -366;
pub const cef_errorcode_t_ERR_PAC_SCRIPT_TERMINATED: cef_errorcode_t = -367;
pub const cef_errorcode_t_ERR_INVALID_HTTP_RESPONSE: cef_errorcode_t = -370;
pub const cef_errorcode_t_ERR_CONTENT_DECODING_INIT_FAILED: cef_errorcode_t = -371;
pub const cef_errorcode_t_ERR_HTTP2_RST_STREAM_NO_ERROR_RECEIVED: cef_errorcode_t = -372;
pub const cef_errorcode_t_ERR_HTTP2_PUSHED_STREAM_NOT_AVAILABLE: cef_errorcode_t = -373;
pub const cef_errorcode_t_ERR_HTTP2_CLAIMED_PUSHED_STREAM_RESET_BY_SERVER: cef_errorcode_t = -374;
pub const cef_errorcode_t_ERR_TOO_MANY_RETRIES: cef_errorcode_t = -375;
pub const cef_errorcode_t_ERR_HTTP2_STREAM_CLOSED: cef_errorcode_t = -376;
pub const cef_errorcode_t_ERR_HTTP2_CLIENT_REFUSED_STREAM: cef_errorcode_t = -377;
pub const cef_errorcode_t_ERR_HTTP2_PUSHED_RESPONSE_DOES_NOT_MATCH: cef_errorcode_t = -378;
pub const cef_errorcode_t_ERR_HTTP_RESPONSE_CODE_FAILURE: cef_errorcode_t = -379;
pub const cef_errorcode_t_ERR_QUIC_CERT_ROOT_NOT_KNOWN: cef_errorcode_t = -380;
pub const cef_errorcode_t_ERR_QUIC_GOAWAY_REQUEST_CAN_BE_RETRIED: cef_errorcode_t = -381;
pub const cef_errorcode_t_ERR_CACHE_MISS: cef_errorcode_t = -400;
pub const cef_errorcode_t_ERR_CACHE_READ_FAILURE: cef_errorcode_t = -401;
pub const cef_errorcode_t_ERR_CACHE_WRITE_FAILURE: cef_errorcode_t = -402;
pub const cef_errorcode_t_ERR_CACHE_OPERATION_NOT_SUPPORTED: cef_errorcode_t = -403;
pub const cef_errorcode_t_ERR_CACHE_OPEN_FAILURE: cef_errorcode_t = -404;
pub const cef_errorcode_t_ERR_CACHE_CREATE_FAILURE: cef_errorcode_t = -405;
pub const cef_errorcode_t_ERR_CACHE_RACE: cef_errorcode_t = -406;
pub const cef_errorcode_t_ERR_CACHE_CHECKSUM_READ_FAILURE: cef_errorcode_t = -407;
pub const cef_errorcode_t_ERR_CACHE_CHECKSUM_MISMATCH: cef_errorcode_t = -408;
pub const cef_errorcode_t_ERR_CACHE_LOCK_TIMEOUT: cef_errorcode_t = -409;
pub const cef_errorcode_t_ERR_CACHE_AUTH_FAILURE_AFTER_READ: cef_errorcode_t = -410;
pub const cef_errorcode_t_ERR_CACHE_ENTRY_NOT_SUITABLE: cef_errorcode_t = -411;
pub const cef_errorcode_t_ERR_CACHE_DOOM_FAILURE: cef_errorcode_t = -412;
pub const cef_errorcode_t_ERR_CACHE_OPEN_OR_CREATE_FAILURE: cef_errorcode_t = -413;
pub const cef_errorcode_t_ERR_INSECURE_RESPONSE: cef_errorcode_t = -501;
pub const cef_errorcode_t_ERR_NO_PRIVATE_KEY_FOR_CERT: cef_errorcode_t = -502;
pub const cef_errorcode_t_ERR_ADD_USER_CERT_FAILED: cef_errorcode_t = -503;
pub const cef_errorcode_t_ERR_INVALID_SIGNED_EXCHANGE: cef_errorcode_t = -504;
pub const cef_errorcode_t_ERR_INVALID_WEB_BUNDLE: cef_errorcode_t = -505;
pub const cef_errorcode_t_ERR_TRUST_TOKEN_OPERATION_FAILED: cef_errorcode_t = -506;
pub const cef_errorcode_t_ERR_TRUST_TOKEN_OPERATION_SUCCESS_WITHOUT_SENDING_REQUEST:
    cef_errorcode_t = -507;
pub const cef_errorcode_t_ERR_FTP_FAILED: cef_errorcode_t = -601;
pub const cef_errorcode_t_ERR_FTP_SERVICE_UNAVAILABLE: cef_errorcode_t = -602;
pub const cef_errorcode_t_ERR_FTP_TRANSFER_ABORTED: cef_errorcode_t = -603;
pub const cef_errorcode_t_ERR_FTP_FILE_BUSY: cef_errorcode_t = -604;
pub const cef_errorcode_t_ERR_FTP_SYNTAX_ERROR: cef_errorcode_t = -605;
pub const cef_errorcode_t_ERR_FTP_COMMAND_NOT_SUPPORTED: cef_errorcode_t = -606;
pub const cef_errorcode_t_ERR_FTP_BAD_COMMAND_SEQUENCE: cef_errorcode_t = -607;
pub const cef_errorcode_t_ERR_PKCS12_IMPORT_BAD_PASSWORD: cef_errorcode_t = -701;
pub const cef_errorcode_t_ERR_PKCS12_IMPORT_FAILED: cef_errorcode_t = -702;
pub const cef_errorcode_t_ERR_IMPORT_CA_CERT_NOT_CA: cef_errorcode_t = -703;
pub const cef_errorcode_t_ERR_IMPORT_CERT_ALREADY_EXISTS: cef_errorcode_t = -704;
pub const cef_errorcode_t_ERR_IMPORT_CA_CERT_FAILED: cef_errorcode_t = -705;
pub const cef_errorcode_t_ERR_IMPORT_SERVER_CERT_FAILED: cef_errorcode_t = -706;
pub const cef_errorcode_t_ERR_PKCS12_IMPORT_INVALID_MAC: cef_errorcode_t = -707;
pub const cef_errorcode_t_ERR_PKCS12_IMPORT_INVALID_FILE: cef_errorcode_t = -708;
pub const cef_errorcode_t_ERR_PKCS12_IMPORT_UNSUPPORTED: cef_errorcode_t = -709;
pub const cef_errorcode_t_ERR_KEY_GENERATION_FAILED: cef_errorcode_t = -710;
pub const cef_errorcode_t_ERR_PRIVATE_KEY_EXPORT_FAILED: cef_errorcode_t = -712;
pub const cef_errorcode_t_ERR_SELF_SIGNED_CERT_GENERATION_FAILED: cef_errorcode_t = -713;
pub const cef_errorcode_t_ERR_CERT_DATABASE_CHANGED: cef_errorcode_t = -714;
pub const cef_errorcode_t_ERR_DNS_MALFORMED_RESPONSE: cef_errorcode_t = -800;
pub const cef_errorcode_t_ERR_DNS_SERVER_REQUIRES_TCP: cef_errorcode_t = -801;
pub const cef_errorcode_t_ERR_DNS_SERVER_FAILED: cef_errorcode_t = -802;
pub const cef_errorcode_t_ERR_DNS_TIMED_OUT: cef_errorcode_t = -803;
pub const cef_errorcode_t_ERR_DNS_CACHE_MISS: cef_errorcode_t = -804;
pub const cef_errorcode_t_ERR_DNS_SEARCH_EMPTY: cef_errorcode_t = -805;
pub const cef_errorcode_t_ERR_DNS_SORT_ERROR: cef_errorcode_t = -806;
pub const cef_errorcode_t_ERR_DNS_SECURE_RESOLVER_HOSTNAME_RESOLUTION_FAILED: cef_errorcode_t =
    -808;
#[doc = "\n Supported error code values.\n"]
pub type cef_errorcode_t = i32;
pub const cef_cert_status_t_CERT_STATUS_NONE: cef_cert_status_t = 0;
pub const cef_cert_status_t_CERT_STATUS_COMMON_NAME_INVALID: cef_cert_status_t = 1;
pub const cef_cert_status_t_CERT_STATUS_DATE_INVALID: cef_cert_status_t = 2;
pub const cef_cert_status_t_CERT_STATUS_AUTHORITY_INVALID: cef_cert_status_t = 4;
#[doc = " 1 << 3 is reserved for ERR_CERT_CONTAINS_ERRORS (not useful with WinHTTP)."]
pub const cef_cert_status_t_CERT_STATUS_NO_REVOCATION_MECHANISM: cef_cert_status_t = 16;
#[doc = " 1 << 3 is reserved for ERR_CERT_CONTAINS_ERRORS (not useful with WinHTTP)."]
pub const cef_cert_status_t_CERT_STATUS_UNABLE_TO_CHECK_REVOCATION: cef_cert_status_t = 32;
#[doc = " 1 << 3 is reserved for ERR_CERT_CONTAINS_ERRORS (not useful with WinHTTP)."]
pub const cef_cert_status_t_CERT_STATUS_REVOKED: cef_cert_status_t = 64;
#[doc = " 1 << 3 is reserved for ERR_CERT_CONTAINS_ERRORS (not useful with WinHTTP)."]
pub const cef_cert_status_t_CERT_STATUS_INVALID: cef_cert_status_t = 128;
#[doc = " 1 << 3 is reserved for ERR_CERT_CONTAINS_ERRORS (not useful with WinHTTP)."]
pub const cef_cert_status_t_CERT_STATUS_WEAK_SIGNATURE_ALGORITHM: cef_cert_status_t = 256;
#[doc = " 1 << 9 was used for CERT_STATUS_NOT_IN_DNS"]
pub const cef_cert_status_t_CERT_STATUS_NON_UNIQUE_NAME: cef_cert_status_t = 1024;
#[doc = " 1 << 9 was used for CERT_STATUS_NOT_IN_DNS"]
pub const cef_cert_status_t_CERT_STATUS_WEAK_KEY: cef_cert_status_t = 2048;
#[doc = " 1 << 12 was used for CERT_STATUS_WEAK_DH_KEY"]
pub const cef_cert_status_t_CERT_STATUS_PINNED_KEY_MISSING: cef_cert_status_t = 8192;
#[doc = " 1 << 12 was used for CERT_STATUS_WEAK_DH_KEY"]
pub const cef_cert_status_t_CERT_STATUS_NAME_CONSTRAINT_VIOLATION: cef_cert_status_t = 16384;
#[doc = " 1 << 12 was used for CERT_STATUS_WEAK_DH_KEY"]
pub const cef_cert_status_t_CERT_STATUS_VALIDITY_TOO_LONG: cef_cert_status_t = 32768;
#[doc = " Bits 16 to 31 are for non-error statuses."]
pub const cef_cert_status_t_CERT_STATUS_IS_EV: cef_cert_status_t = 65536;
#[doc = " Bits 16 to 31 are for non-error statuses."]
pub const cef_cert_status_t_CERT_STATUS_REV_CHECKING_ENABLED: cef_cert_status_t = 131072;
#[doc = " Bit 18 was CERT_STATUS_IS_DNSSEC"]
pub const cef_cert_status_t_CERT_STATUS_SHA1_SIGNATURE_PRESENT: cef_cert_status_t = 524288;
#[doc = " Bit 18 was CERT_STATUS_IS_DNSSEC"]
pub const cef_cert_status_t_CERT_STATUS_CT_COMPLIANCE_FAILED: cef_cert_status_t = 1048576;
#[doc = "\n Supported certificate status code values. See net\\cert\\cert_status_flags.h\n for more information. CERT_STATUS_NONE is new in CEF because we use an\n enum while cert_status_flags.h uses a typedef and static const variables.\n"]
pub type cef_cert_status_t = i32;
pub const cef_window_open_disposition_t_WOD_UNKNOWN: cef_window_open_disposition_t = 0;
pub const cef_window_open_disposition_t_WOD_CURRENT_TAB: cef_window_open_disposition_t = 1;
pub const cef_window_open_disposition_t_WOD_SINGLETON_TAB: cef_window_open_disposition_t = 2;
pub const cef_window_open_disposition_t_WOD_NEW_FOREGROUND_TAB: cef_window_open_disposition_t = 3;
pub const cef_window_open_disposition_t_WOD_NEW_BACKGROUND_TAB: cef_window_open_disposition_t = 4;
pub const cef_window_open_disposition_t_WOD_NEW_POPUP: cef_window_open_disposition_t = 5;
pub const cef_window_open_disposition_t_WOD_NEW_WINDOW: cef_window_open_disposition_t = 6;
pub const cef_window_open_disposition_t_WOD_SAVE_TO_DISK: cef_window_open_disposition_t = 7;
pub const cef_window_open_disposition_t_WOD_OFF_THE_RECORD: cef_window_open_disposition_t = 8;
pub const cef_window_open_disposition_t_WOD_IGNORE_ACTION: cef_window_open_disposition_t = 9;
#[doc = "\n The manner in which a link click should be opened. These constants match\n their equivalents in Chromium's window_open_disposition.h and should not be\n renumbered.\n"]
pub type cef_window_open_disposition_t = i32;
pub const cef_drag_operations_mask_t_DRAG_OPERATION_NONE: cef_drag_operations_mask_t = 0;
pub const cef_drag_operations_mask_t_DRAG_OPERATION_COPY: cef_drag_operations_mask_t = 1;
pub const cef_drag_operations_mask_t_DRAG_OPERATION_LINK: cef_drag_operations_mask_t = 2;
pub const cef_drag_operations_mask_t_DRAG_OPERATION_GENERIC: cef_drag_operations_mask_t = 4;
pub const cef_drag_operations_mask_t_DRAG_OPERATION_PRIVATE: cef_drag_operations_mask_t = 8;
pub const cef_drag_operations_mask_t_DRAG_OPERATION_MOVE: cef_drag_operations_mask_t = 16;
pub const cef_drag_operations_mask_t_DRAG_OPERATION_DELETE: cef_drag_operations_mask_t = 32;
pub const cef_drag_operations_mask_t_DRAG_OPERATION_EVERY: cef_drag_operations_mask_t = -1;
#[doc = "\n \"Verb\" of a drag-and-drop operation as negotiated between the source and\n destination. These constants match their equivalents in WebCore's\n DragActions.h and should not be renumbered.\n"]
pub type cef_drag_operations_mask_t = i32;
pub const cef_text_input_mode_t_CEF_TEXT_INPUT_MODE_DEFAULT: cef_text_input_mode_t = 0;
pub const cef_text_input_mode_t_CEF_TEXT_INPUT_MODE_NONE: cef_text_input_mode_t = 1;
pub const cef_text_input_mode_t_CEF_TEXT_INPUT_MODE_TEXT: cef_text_input_mode_t = 2;
pub const cef_text_input_mode_t_CEF_TEXT_INPUT_MODE_TEL: cef_text_input_mode_t = 3;
pub const cef_text_input_mode_t_CEF_TEXT_INPUT_MODE_URL: cef_text_input_mode_t = 4;
pub const cef_text_input_mode_t_CEF_TEXT_INPUT_MODE_EMAIL: cef_text_input_mode_t = 5;
pub const cef_text_input_mode_t_CEF_TEXT_INPUT_MODE_NUMERIC: cef_text_input_mode_t = 6;
pub const cef_text_input_mode_t_CEF_TEXT_INPUT_MODE_DECIMAL: cef_text_input_mode_t = 7;
pub const cef_text_input_mode_t_CEF_TEXT_INPUT_MODE_SEARCH: cef_text_input_mode_t = 8;
pub const cef_text_input_mode_t_CEF_TEXT_INPUT_MODE_MAX: cef_text_input_mode_t = 8;
#[doc = "\n Input mode of a virtual keyboard. These constants match their equivalents\n in Chromium's text_input_mode.h and should not be renumbered.\n See https://html.spec.whatwg.org/#input-modalities:-the-inputmode-attribute\n"]
pub type cef_text_input_mode_t = i32;
pub const cef_v8_accesscontrol_t_V8_ACCESS_CONTROL_DEFAULT: cef_v8_accesscontrol_t = 0;
pub const cef_v8_accesscontrol_t_V8_ACCESS_CONTROL_ALL_CAN_READ: cef_v8_accesscontrol_t = 1;
pub const cef_v8_accesscontrol_t_V8_ACCESS_CONTROL_ALL_CAN_WRITE: cef_v8_accesscontrol_t = 2;
pub const cef_v8_accesscontrol_t_V8_ACCESS_CONTROL_PROHIBITS_OVERWRITING: cef_v8_accesscontrol_t =
    4;
#[doc = "\n V8 access control values.\n"]
pub type cef_v8_accesscontrol_t = i32;
#[doc = " Writeable, Enumerable,\n   Configurable"]
pub const cef_v8_propertyattribute_t_V8_PROPERTY_ATTRIBUTE_NONE: cef_v8_propertyattribute_t = 0;
#[doc = " Not writeable"]
pub const cef_v8_propertyattribute_t_V8_PROPERTY_ATTRIBUTE_READONLY: cef_v8_propertyattribute_t = 1;
#[doc = " Not enumerable"]
pub const cef_v8_propertyattribute_t_V8_PROPERTY_ATTRIBUTE_DONTENUM: cef_v8_propertyattribute_t = 2;
#[doc = " Not configurable"]
pub const cef_v8_propertyattribute_t_V8_PROPERTY_ATTRIBUTE_DONTDELETE: cef_v8_propertyattribute_t =
    4;
#[doc = "\n V8 property attribute values.\n"]
pub type cef_v8_propertyattribute_t = i32;
pub const cef_postdataelement_type_t_PDE_TYPE_EMPTY: cef_postdataelement_type_t = 0;
pub const cef_postdataelement_type_t_PDE_TYPE_BYTES: cef_postdataelement_type_t = 1;
pub const cef_postdataelement_type_t_PDE_TYPE_FILE: cef_postdataelement_type_t = 2;
#[doc = "\n Post data elements may represent either bytes or files.\n"]
pub type cef_postdataelement_type_t = i32;
#[doc = "\n Top level page.\n"]
pub const cef_resource_type_t_RT_MAIN_FRAME: cef_resource_type_t = 0;
#[doc = "\n Frame or iframe.\n"]
pub const cef_resource_type_t_RT_SUB_FRAME: cef_resource_type_t = 1;
#[doc = "\n CSS stylesheet.\n"]
pub const cef_resource_type_t_RT_STYLESHEET: cef_resource_type_t = 2;
#[doc = "\n External script.\n"]
pub const cef_resource_type_t_RT_SCRIPT: cef_resource_type_t = 3;
#[doc = "\n Image (jpg/gif/png/etc).\n"]
pub const cef_resource_type_t_RT_IMAGE: cef_resource_type_t = 4;
#[doc = "\n Font.\n"]
pub const cef_resource_type_t_RT_FONT_RESOURCE: cef_resource_type_t = 5;
#[doc = "\n Some other subresource. This is the default type if the actual type is\n unknown.\n"]
pub const cef_resource_type_t_RT_SUB_RESOURCE: cef_resource_type_t = 6;
#[doc = "\n Object (or embed) tag for a plugin, or a resource that a plugin requested.\n"]
pub const cef_resource_type_t_RT_OBJECT: cef_resource_type_t = 7;
#[doc = "\n Media resource.\n"]
pub const cef_resource_type_t_RT_MEDIA: cef_resource_type_t = 8;
#[doc = "\n Main resource of a dedicated worker.\n"]
pub const cef_resource_type_t_RT_WORKER: cef_resource_type_t = 9;
#[doc = "\n Main resource of a shared worker.\n"]
pub const cef_resource_type_t_RT_SHARED_WORKER: cef_resource_type_t = 10;
#[doc = "\n Explicitly requested prefetch.\n"]
pub const cef_resource_type_t_RT_PREFETCH: cef_resource_type_t = 11;
#[doc = "\n Favicon.\n"]
pub const cef_resource_type_t_RT_FAVICON: cef_resource_type_t = 12;
#[doc = "\n XMLHttpRequest.\n"]
pub const cef_resource_type_t_RT_XHR: cef_resource_type_t = 13;
#[doc = "\n A request for a <ping>\n"]
pub const cef_resource_type_t_RT_PING: cef_resource_type_t = 14;
#[doc = "\n Main resource of a service worker.\n"]
pub const cef_resource_type_t_RT_SERVICE_WORKER: cef_resource_type_t = 15;
#[doc = "\n A report of Content Security Policy violations.\n"]
pub const cef_resource_type_t_RT_CSP_REPORT: cef_resource_type_t = 16;
#[doc = "\n A resource that a plugin requested.\n"]
pub const cef_resource_type_t_RT_PLUGIN_RESOURCE: cef_resource_type_t = 17;
#[doc = "\n Resource type for a request.\n"]
pub type cef_resource_type_t = i32;
#[doc = "\n Source is a link click or the JavaScript window.open function. This is\n also the default value for requests like sub-resource loads that are not\n navigations.\n"]
pub const cef_transition_type_t_TT_LINK: cef_transition_type_t = 0;
#[doc = "\n Source is some other \"explicit\" navigation. This is the default value for\n navigations where the actual type is unknown. See also TT_DIRECT_LOAD_FLAG.\n"]
pub const cef_transition_type_t_TT_EXPLICIT: cef_transition_type_t = 1;
#[doc = "\n Source is a subframe navigation. This is any content that is automatically\n loaded in a non-toplevel frame. For example, if a page consists of several\n frames containing ads, those ad URLs will have this transition type.\n The user may not even realize the content in these pages is a separate\n frame, so may not care about the URL.\n"]
pub const cef_transition_type_t_TT_AUTO_SUBFRAME: cef_transition_type_t = 3;
#[doc = "\n Source is a subframe navigation explicitly requested by the user that will\n generate new navigation entries in the back/forward list. These are\n probably more important than frames that were automatically loaded in\n the background because the user probably cares about the fact that this\n link was loaded.\n"]
pub const cef_transition_type_t_TT_MANUAL_SUBFRAME: cef_transition_type_t = 4;
#[doc = "\n Source is a form submission by the user. NOTE: In some situations\n submitting a form does not result in this transition type. This can happen\n if the form uses a script to submit the contents.\n"]
pub const cef_transition_type_t_TT_FORM_SUBMIT: cef_transition_type_t = 7;
#[doc = "\n Source is a \"reload\" of the page via the Reload function or by re-visiting\n the same URL. NOTE: This is distinct from the concept of whether a\n particular load uses \"reload semantics\" (i.e. bypasses cached data).\n"]
pub const cef_transition_type_t_TT_RELOAD: cef_transition_type_t = 8;
#[doc = "\n General mask defining the bits used for the source values.\n"]
pub const cef_transition_type_t_TT_SOURCE_MASK: cef_transition_type_t = 255;
#[doc = "\n Attempted to visit a URL but was blocked.\n"]
pub const cef_transition_type_t_TT_BLOCKED_FLAG: cef_transition_type_t = 8388608;
#[doc = "\n Used the Forward or Back function to navigate among browsing history.\n Will be ORed to the transition type for the original load.\n"]
pub const cef_transition_type_t_TT_FORWARD_BACK_FLAG: cef_transition_type_t = 16777216;
#[doc = "\n Loaded a URL directly via CreateBrowser, LoadURL or LoadRequest.\n"]
pub const cef_transition_type_t_TT_DIRECT_LOAD_FLAG: cef_transition_type_t = 33554432;
#[doc = "\n The beginning of a navigation chain.\n"]
pub const cef_transition_type_t_TT_CHAIN_START_FLAG: cef_transition_type_t = 268435456;
#[doc = "\n The last transition in a redirect chain.\n"]
pub const cef_transition_type_t_TT_CHAIN_END_FLAG: cef_transition_type_t = 536870912;
#[doc = "\n Redirects caused by JavaScript or a meta refresh tag on the page.\n"]
pub const cef_transition_type_t_TT_CLIENT_REDIRECT_FLAG: cef_transition_type_t = 1073741824;
#[doc = "\n Redirects sent from the server by HTTP headers.\n"]
pub const cef_transition_type_t_TT_SERVER_REDIRECT_FLAG: cef_transition_type_t = -2147483648;
#[doc = "\n Used to test whether a transition involves a redirect.\n"]
pub const cef_transition_type_t_TT_IS_REDIRECT_MASK: cef_transition_type_t = -1073741824;
#[doc = "\n General mask defining the bits used for the qualifiers.\n"]
pub const cef_transition_type_t_TT_QUALIFIER_MASK: cef_transition_type_t = -256;
#[doc = "\n Transition type for a request. Made up of one source value and 0 or more\n qualifiers.\n"]
pub type cef_transition_type_t = i32;
#[doc = "\n Default behavior.\n"]
pub const cef_urlrequest_flags_t_UR_FLAG_NONE: cef_urlrequest_flags_t = 0;
#[doc = "\n If set the cache will be skipped when handling the request. Setting this\n value is equivalent to specifying the \"Cache-Control: no-cache\" request\n header. Setting this value in combination with UR_FLAG_ONLY_FROM_CACHE will\n cause the request to fail.\n"]
pub const cef_urlrequest_flags_t_UR_FLAG_SKIP_CACHE: cef_urlrequest_flags_t = 1;
#[doc = "\n If set the request will fail if it cannot be served from the cache (or some\n equivalent local store). Setting this value is equivalent to specifying the\n \"Cache-Control: only-if-cached\" request header. Setting this value in\n combination with UR_FLAG_SKIP_CACHE or UR_FLAG_DISABLE_CACHE will cause the\n request to fail.\n"]
pub const cef_urlrequest_flags_t_UR_FLAG_ONLY_FROM_CACHE: cef_urlrequest_flags_t = 2;
#[doc = "\n If set the cache will not be used at all. Setting this value is equivalent\n to specifying the \"Cache-Control: no-store\" request header. Setting this\n value in combination with UR_FLAG_ONLY_FROM_CACHE will cause the request to\n fail.\n"]
pub const cef_urlrequest_flags_t_UR_FLAG_DISABLE_CACHE: cef_urlrequest_flags_t = 4;
#[doc = "\n If set user name, password, and cookies may be sent with the request, and\n cookies may be saved from the response.\n"]
pub const cef_urlrequest_flags_t_UR_FLAG_ALLOW_STORED_CREDENTIALS: cef_urlrequest_flags_t = 8;
#[doc = "\n If set upload progress events will be generated when a request has a body.\n"]
pub const cef_urlrequest_flags_t_UR_FLAG_REPORT_UPLOAD_PROGRESS: cef_urlrequest_flags_t = 16;
#[doc = "\n If set the CefURLRequestClient::OnDownloadData method will not be called.\n"]
pub const cef_urlrequest_flags_t_UR_FLAG_NO_DOWNLOAD_DATA: cef_urlrequest_flags_t = 32;
#[doc = "\n If set 5XX redirect errors will be propagated to the observer instead of\n automatically re-tried. This currently only applies for requests\n originated in the browser process.\n"]
pub const cef_urlrequest_flags_t_UR_FLAG_NO_RETRY_ON_5XX: cef_urlrequest_flags_t = 64;
#[doc = "\n If set 3XX responses will cause the fetch to halt immediately rather than\n continue through the redirect.\n"]
pub const cef_urlrequest_flags_t_UR_FLAG_STOP_ON_REDIRECT: cef_urlrequest_flags_t = 128;
#[doc = "\n Flags used to customize the behavior of CefURLRequest.\n"]
pub type cef_urlrequest_flags_t = i32;
#[doc = "\n Unknown status.\n"]
pub const cef_urlrequest_status_t_UR_UNKNOWN: cef_urlrequest_status_t = 0;
#[doc = "\n Request succeeded.\n"]
pub const cef_urlrequest_status_t_UR_SUCCESS: cef_urlrequest_status_t = 1;
#[doc = "\n An IO request is pending, and the caller will be informed when it is\n completed.\n"]
pub const cef_urlrequest_status_t_UR_IO_PENDING: cef_urlrequest_status_t = 2;
#[doc = "\n Request was canceled programatically.\n"]
pub const cef_urlrequest_status_t_UR_CANCELED: cef_urlrequest_status_t = 3;
#[doc = "\n Request failed for some reason.\n"]
pub const cef_urlrequest_status_t_UR_FAILED: cef_urlrequest_status_t = 4;
#[doc = "\n Flags that represent CefURLRequest status.\n"]
pub type cef_urlrequest_status_t = i32;
#[doc = "\n Structure representing a point.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_point_t {
    pub x: ::core::ffi::c_int,
    pub y: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout__cef_point_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_point_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_point_t>(),
        8usize,
        concat!("Size of: ", stringify!(_cef_point_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_point_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_cef_point_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_point_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_point_t),
            "::",
            stringify!(y)
        )
    );
}
#[doc = "\n Structure representing a point.\n"]
pub type cef_point_t = _cef_point_t;
#[doc = "\n Structure representing a rectangle.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_rect_t {
    pub x: ::core::ffi::c_int,
    pub y: ::core::ffi::c_int,
    pub width: ::core::ffi::c_int,
    pub height: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout__cef_rect_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_rect_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_rect_t>(),
        16usize,
        concat!("Size of: ", stringify!(_cef_rect_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_rect_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_cef_rect_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_rect_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_rect_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_rect_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_rect_t),
            "::",
            stringify!(height)
        )
    );
}
#[doc = "\n Structure representing a rectangle.\n"]
pub type cef_rect_t = _cef_rect_t;
#[doc = "\n Structure representing a size.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_size_t {
    pub width: ::core::ffi::c_int,
    pub height: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout__cef_size_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_size_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_size_t>(),
        8usize,
        concat!("Size of: ", stringify!(_cef_size_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_size_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_cef_size_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_size_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_size_t),
            "::",
            stringify!(height)
        )
    );
}
#[doc = "\n Structure representing a size.\n"]
pub type cef_size_t = _cef_size_t;
#[doc = "\n Structure representing a range.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_range_t {
    pub from: ::core::ffi::c_int,
    pub to: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout__cef_range_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_range_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_range_t>(),
        8usize,
        concat!("Size of: ", stringify!(_cef_range_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_range_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_cef_range_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).from) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_range_t),
            "::",
            stringify!(from)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).to) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_range_t),
            "::",
            stringify!(to)
        )
    );
}
#[doc = "\n Structure representing a range.\n"]
pub type cef_range_t = _cef_range_t;
#[doc = "\n Structure representing insets.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_insets_t {
    pub top: ::core::ffi::c_int,
    pub left: ::core::ffi::c_int,
    pub bottom: ::core::ffi::c_int,
    pub right: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout__cef_insets_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_insets_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_insets_t>(),
        16usize,
        concat!("Size of: ", stringify!(_cef_insets_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_insets_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_cef_insets_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).top) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_insets_t),
            "::",
            stringify!(top)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_insets_t),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bottom) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_insets_t),
            "::",
            stringify!(bottom)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).right) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_insets_t),
            "::",
            stringify!(right)
        )
    );
}
#[doc = "\n Structure representing insets.\n"]
pub type cef_insets_t = _cef_insets_t;
#[doc = "\n Structure representing a draggable region.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_draggable_region_t {
    #[doc = "\n Bounds of the region.\n"]
    pub bounds: cef_rect_t,
    #[doc = "\n True (1) this this region is draggable and false (0) otherwise.\n"]
    pub draggable: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout__cef_draggable_region_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_draggable_region_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_draggable_region_t>(),
        20usize,
        concat!("Size of: ", stringify!(_cef_draggable_region_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_draggable_region_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_cef_draggable_region_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bounds) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_draggable_region_t),
            "::",
            stringify!(bounds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).draggable) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_draggable_region_t),
            "::",
            stringify!(draggable)
        )
    );
}
#[doc = "\n Structure representing a draggable region.\n"]
pub type cef_draggable_region_t = _cef_draggable_region_t;
#[doc = "\n Browser process.\n"]
pub const cef_process_id_t_PID_BROWSER: cef_process_id_t = 0;
#[doc = "\n Renderer process.\n"]
pub const cef_process_id_t_PID_RENDERER: cef_process_id_t = 1;
#[doc = "\n Existing process IDs.\n"]
pub type cef_process_id_t = i32;
#[doc = "\n The main thread in the browser. This will be the same as the main\n application thread if CefInitialize() is called with a\n CefSettings.multi_threaded_message_loop value of false. Do not perform\n blocking tasks on this thread. All tasks posted after\n CefBrowserProcessHandler::OnContextInitialized() and before CefShutdown()\n are guaranteed to run. This thread will outlive all other CEF threads.\n"]
pub const cef_thread_id_t_TID_UI: cef_thread_id_t = 0;
#[doc = "\n Used for blocking tasks (e.g. file system access) where the user won't\n notice if the task takes an arbitrarily long time to complete. All tasks\n posted after CefBrowserProcessHandler::OnContextInitialized() and before\n CefShutdown() are guaranteed to run.\n"]
pub const cef_thread_id_t_TID_FILE_BACKGROUND: cef_thread_id_t = 1;
#[doc = "\n Used for blocking tasks (e.g. file system access) where the user won't\n notice if the task takes an arbitrarily long time to complete. All tasks\n posted after CefBrowserProcessHandler::OnContextInitialized() and before\n CefShutdown() are guaranteed to run.\n"]
pub const cef_thread_id_t_TID_FILE: cef_thread_id_t = 1;
#[doc = "\n Used for blocking tasks (e.g. file system access) that affect UI or\n responsiveness of future user interactions. Do not use if an immediate\n response to a user interaction is expected. All tasks posted after\n CefBrowserProcessHandler::OnContextInitialized() and before CefShutdown()\n are guaranteed to run.\n Examples:\n - Updating the UI to reflect progress on a long task.\n - Loading data that might be shown in the UI after a future user\n   interaction.\n"]
pub const cef_thread_id_t_TID_FILE_USER_VISIBLE: cef_thread_id_t = 2;
#[doc = "\n Used for blocking tasks (e.g. file system access) that affect UI\n immediately after a user interaction. All tasks posted after\n CefBrowserProcessHandler::OnContextInitialized() and before CefShutdown()\n are guaranteed to run.\n Example: Generating data shown in the UI immediately after a click.\n"]
pub const cef_thread_id_t_TID_FILE_USER_BLOCKING: cef_thread_id_t = 3;
#[doc = "\n Used to launch and terminate browser processes.\n"]
pub const cef_thread_id_t_TID_PROCESS_LAUNCHER: cef_thread_id_t = 4;
#[doc = "\n Used to process IPC and network messages. Do not perform blocking tasks on\n this thread. All tasks posted after\n CefBrowserProcessHandler::OnContextInitialized() and before CefShutdown()\n are guaranteed to run.\n"]
pub const cef_thread_id_t_TID_IO: cef_thread_id_t = 5;
#[doc = "\n The main thread in the renderer. Used for all WebKit and V8 interaction.\n Tasks may be posted to this thread after\n CefRenderProcessHandler::OnWebKitInitialized but are not guaranteed to\n run before sub-process termination (sub-processes may be killed at any time\n without warning).\n"]
pub const cef_thread_id_t_TID_RENDERER: cef_thread_id_t = 6;
#[doc = "\n Existing thread IDs.\n"]
pub type cef_thread_id_t = i32;
#[doc = "\n Suitable for threads that shouldn't disrupt high priority work.\n"]
pub const cef_thread_priority_t_TP_BACKGROUND: cef_thread_priority_t = 0;
#[doc = "\n Default priority level.\n"]
pub const cef_thread_priority_t_TP_NORMAL: cef_thread_priority_t = 1;
#[doc = "\n Suitable for threads which generate data for the display (at ~60Hz).\n"]
pub const cef_thread_priority_t_TP_DISPLAY: cef_thread_priority_t = 2;
#[doc = "\n Suitable for low-latency, glitch-resistant audio.\n"]
pub const cef_thread_priority_t_TP_REALTIME_AUDIO: cef_thread_priority_t = 3;
#[doc = "\n Thread priority values listed in increasing order of importance.\n"]
pub type cef_thread_priority_t = i32;
#[doc = "\n Supports tasks and timers.\n"]
pub const cef_message_loop_type_t_ML_TYPE_DEFAULT: cef_message_loop_type_t = 0;
#[doc = "\n Supports tasks, timers and native UI events (e.g. Windows messages).\n"]
pub const cef_message_loop_type_t_ML_TYPE_UI: cef_message_loop_type_t = 1;
#[doc = "\n Supports tasks, timers and asynchronous IO events.\n"]
pub const cef_message_loop_type_t_ML_TYPE_IO: cef_message_loop_type_t = 2;
#[doc = "\n Message loop types. Indicates the set of asynchronous events that a message\n loop can process.\n"]
pub type cef_message_loop_type_t = i32;
#[doc = "\n No COM initialization.\n"]
pub const cef_com_init_mode_t_COM_INIT_MODE_NONE: cef_com_init_mode_t = 0;
#[doc = "\n Initialize COM using single-threaded apartments.\n"]
pub const cef_com_init_mode_t_COM_INIT_MODE_STA: cef_com_init_mode_t = 1;
#[doc = "\n Initialize COM using multi-threaded apartments.\n"]
pub const cef_com_init_mode_t_COM_INIT_MODE_MTA: cef_com_init_mode_t = 2;
#[doc = "\n Windows COM initialization mode. Specifies how COM will be initialized for a\n new thread.\n"]
pub type cef_com_init_mode_t = i32;
pub const cef_value_type_t_VTYPE_INVALID: cef_value_type_t = 0;
pub const cef_value_type_t_VTYPE_NULL: cef_value_type_t = 1;
pub const cef_value_type_t_VTYPE_BOOL: cef_value_type_t = 2;
pub const cef_value_type_t_VTYPE_INT: cef_value_type_t = 3;
pub const cef_value_type_t_VTYPE_DOUBLE: cef_value_type_t = 4;
pub const cef_value_type_t_VTYPE_STRING: cef_value_type_t = 5;
pub const cef_value_type_t_VTYPE_BINARY: cef_value_type_t = 6;
pub const cef_value_type_t_VTYPE_DICTIONARY: cef_value_type_t = 7;
pub const cef_value_type_t_VTYPE_LIST: cef_value_type_t = 8;
#[doc = "\n Supported value types.\n"]
pub type cef_value_type_t = i32;
pub const cef_jsdialog_type_t_JSDIALOGTYPE_ALERT: cef_jsdialog_type_t = 0;
pub const cef_jsdialog_type_t_JSDIALOGTYPE_CONFIRM: cef_jsdialog_type_t = 1;
pub const cef_jsdialog_type_t_JSDIALOGTYPE_PROMPT: cef_jsdialog_type_t = 2;
#[doc = "\n Supported JavaScript dialog types.\n"]
pub type cef_jsdialog_type_t = i32;
#[doc = "\n Screen information used when window rendering is disabled. This structure is\n passed as a parameter to CefRenderHandler::GetScreenInfo and should be filled\n in by the client.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_screen_info_t {
    #[doc = "\n Device scale factor. Specifies the ratio between physical and logical\n pixels.\n"]
    pub device_scale_factor: f32,
    #[doc = "\n The screen depth in bits per pixel.\n"]
    pub depth: ::core::ffi::c_int,
    #[doc = "\n The bits per color component. This assumes that the colors are balanced\n equally.\n"]
    pub depth_per_component: ::core::ffi::c_int,
    #[doc = "\n This can be true for black and white printers.\n"]
    pub is_monochrome: ::core::ffi::c_int,
    #[doc = "\n This is set from the rcMonitor member of MONITORINFOEX, to whit:\n   \"A RECT structure that specifies the display monitor rectangle,\n   expressed in virtual-screen coordinates. Note that if the monitor\n   is not the primary display monitor, some of the rectangle's\n   coordinates may be negative values.\"\n\n The |rect| and |available_rect| properties are used to determine the\n available surface for rendering popup views.\n"]
    pub rect: cef_rect_t,
    #[doc = "\n This is set from the rcWork member of MONITORINFOEX, to whit:\n   \"A RECT structure that specifies the work area rectangle of the\n   display monitor that can be used by applications, expressed in\n   virtual-screen coordinates. Windows uses this rectangle to\n   maximize an application on the monitor. The rest of the area in\n   rcMonitor contains system windows such as the task bar and side\n   bars. Note that if the monitor is not the primary display monitor,\n   some of the rectangle's coordinates may be negative values\".\n\n The |rect| and |available_rect| properties are used to determine the\n available surface for rendering popup views.\n"]
    pub available_rect: cef_rect_t,
}
#[test]
fn bindgen_test_layout__cef_screen_info_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_screen_info_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_screen_info_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_screen_info_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_screen_info_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_cef_screen_info_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).device_scale_factor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_screen_info_t),
            "::",
            stringify!(device_scale_factor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).depth) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_screen_info_t),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).depth_per_component) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_screen_info_t),
            "::",
            stringify!(depth_per_component)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_monochrome) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_screen_info_t),
            "::",
            stringify!(is_monochrome)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rect) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_screen_info_t),
            "::",
            stringify!(rect)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).available_rect) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_screen_info_t),
            "::",
            stringify!(available_rect)
        )
    );
}
#[doc = "\n Screen information used when window rendering is disabled. This structure is\n passed as a parameter to CefRenderHandler::GetScreenInfo and should be filled\n in by the client.\n"]
pub type cef_screen_info_t = _cef_screen_info_t;
#[doc = " Navigation."]
pub const cef_menu_id_t_MENU_ID_BACK: cef_menu_id_t = 100;
#[doc = " Navigation."]
pub const cef_menu_id_t_MENU_ID_FORWARD: cef_menu_id_t = 101;
#[doc = " Navigation."]
pub const cef_menu_id_t_MENU_ID_RELOAD: cef_menu_id_t = 102;
#[doc = " Navigation."]
pub const cef_menu_id_t_MENU_ID_RELOAD_NOCACHE: cef_menu_id_t = 103;
#[doc = " Navigation."]
pub const cef_menu_id_t_MENU_ID_STOPLOAD: cef_menu_id_t = 104;
#[doc = " Editing."]
pub const cef_menu_id_t_MENU_ID_UNDO: cef_menu_id_t = 110;
#[doc = " Editing."]
pub const cef_menu_id_t_MENU_ID_REDO: cef_menu_id_t = 111;
#[doc = " Editing."]
pub const cef_menu_id_t_MENU_ID_CUT: cef_menu_id_t = 112;
#[doc = " Editing."]
pub const cef_menu_id_t_MENU_ID_COPY: cef_menu_id_t = 113;
#[doc = " Editing."]
pub const cef_menu_id_t_MENU_ID_PASTE: cef_menu_id_t = 114;
#[doc = " Editing."]
pub const cef_menu_id_t_MENU_ID_DELETE: cef_menu_id_t = 115;
#[doc = " Editing."]
pub const cef_menu_id_t_MENU_ID_SELECT_ALL: cef_menu_id_t = 116;
#[doc = " Miscellaneous."]
pub const cef_menu_id_t_MENU_ID_FIND: cef_menu_id_t = 130;
#[doc = " Miscellaneous."]
pub const cef_menu_id_t_MENU_ID_PRINT: cef_menu_id_t = 131;
#[doc = " Miscellaneous."]
pub const cef_menu_id_t_MENU_ID_VIEW_SOURCE: cef_menu_id_t = 132;
#[doc = " Spell checking word correction suggestions."]
pub const cef_menu_id_t_MENU_ID_SPELLCHECK_SUGGESTION_0: cef_menu_id_t = 200;
#[doc = " Spell checking word correction suggestions."]
pub const cef_menu_id_t_MENU_ID_SPELLCHECK_SUGGESTION_1: cef_menu_id_t = 201;
#[doc = " Spell checking word correction suggestions."]
pub const cef_menu_id_t_MENU_ID_SPELLCHECK_SUGGESTION_2: cef_menu_id_t = 202;
#[doc = " Spell checking word correction suggestions."]
pub const cef_menu_id_t_MENU_ID_SPELLCHECK_SUGGESTION_3: cef_menu_id_t = 203;
#[doc = " Spell checking word correction suggestions."]
pub const cef_menu_id_t_MENU_ID_SPELLCHECK_SUGGESTION_4: cef_menu_id_t = 204;
#[doc = " Spell checking word correction suggestions."]
pub const cef_menu_id_t_MENU_ID_SPELLCHECK_SUGGESTION_LAST: cef_menu_id_t = 204;
#[doc = " Spell checking word correction suggestions."]
pub const cef_menu_id_t_MENU_ID_NO_SPELLING_SUGGESTIONS: cef_menu_id_t = 205;
#[doc = " Spell checking word correction suggestions."]
pub const cef_menu_id_t_MENU_ID_ADD_TO_DICTIONARY: cef_menu_id_t = 206;
#[doc = " Custom menu items originating from the renderer process. For example,\n plugin placeholder menu items."]
pub const cef_menu_id_t_MENU_ID_CUSTOM_FIRST: cef_menu_id_t = 220;
#[doc = " Custom menu items originating from the renderer process. For example,\n plugin placeholder menu items."]
pub const cef_menu_id_t_MENU_ID_CUSTOM_LAST: cef_menu_id_t = 250;
#[doc = " All user-defined menu IDs should come between MENU_ID_USER_FIRST and\n MENU_ID_USER_LAST to avoid overlapping the Chromium and CEF ID ranges\n defined in the tools/gritsettings/resource_ids file."]
pub const cef_menu_id_t_MENU_ID_USER_FIRST: cef_menu_id_t = 26500;
#[doc = " All user-defined menu IDs should come between MENU_ID_USER_FIRST and\n MENU_ID_USER_LAST to avoid overlapping the Chromium and CEF ID ranges\n defined in the tools/gritsettings/resource_ids file."]
pub const cef_menu_id_t_MENU_ID_USER_LAST: cef_menu_id_t = 28500;
#[doc = "\n Supported menu IDs. Non-English translations can be provided for the\n IDS_MENU_* strings in CefResourceBundleHandler::GetLocalizedString().\n"]
pub type cef_menu_id_t = i32;
pub const cef_mouse_button_type_t_MBT_LEFT: cef_mouse_button_type_t = 0;
pub const cef_mouse_button_type_t_MBT_MIDDLE: cef_mouse_button_type_t = 1;
pub const cef_mouse_button_type_t_MBT_RIGHT: cef_mouse_button_type_t = 2;
#[doc = "\n Mouse button types.\n"]
pub type cef_mouse_button_type_t = i32;
#[doc = "\n Structure representing mouse event information.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_mouse_event_t {
    #[doc = "\n X coordinate relative to the left side of the view.\n"]
    pub x: ::core::ffi::c_int,
    #[doc = "\n Y coordinate relative to the top side of the view.\n"]
    pub y: ::core::ffi::c_int,
    #[doc = "\n Bit flags describing any pressed modifier keys. See\n cef_event_flags_t for values.\n"]
    pub modifiers: uint32,
}
#[test]
fn bindgen_test_layout__cef_mouse_event_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_mouse_event_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_mouse_event_t>(),
        12usize,
        concat!("Size of: ", stringify!(_cef_mouse_event_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_mouse_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_cef_mouse_event_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_mouse_event_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_mouse_event_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).modifiers) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_mouse_event_t),
            "::",
            stringify!(modifiers)
        )
    );
}
#[doc = "\n Structure representing mouse event information.\n"]
pub type cef_mouse_event_t = _cef_mouse_event_t;
pub const cef_touch_event_type_t_CEF_TET_RELEASED: cef_touch_event_type_t = 0;
pub const cef_touch_event_type_t_CEF_TET_PRESSED: cef_touch_event_type_t = 1;
pub const cef_touch_event_type_t_CEF_TET_MOVED: cef_touch_event_type_t = 2;
pub const cef_touch_event_type_t_CEF_TET_CANCELLED: cef_touch_event_type_t = 3;
#[doc = "\n Touch points states types.\n"]
pub type cef_touch_event_type_t = i32;
pub const cef_pointer_type_t_CEF_POINTER_TYPE_TOUCH: cef_pointer_type_t = 0;
pub const cef_pointer_type_t_CEF_POINTER_TYPE_MOUSE: cef_pointer_type_t = 1;
pub const cef_pointer_type_t_CEF_POINTER_TYPE_PEN: cef_pointer_type_t = 2;
pub const cef_pointer_type_t_CEF_POINTER_TYPE_ERASER: cef_pointer_type_t = 3;
pub const cef_pointer_type_t_CEF_POINTER_TYPE_UNKNOWN: cef_pointer_type_t = 4;
#[doc = "\n The device type that caused the event.\n"]
pub type cef_pointer_type_t = i32;
#[doc = "\n Structure representing touch event information.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_touch_event_t {
    #[doc = "\n Id of a touch point. Must be unique per touch, can be any number except -1.\n Note that a maximum of 16 concurrent touches will be tracked; touches\n beyond that will be ignored.\n"]
    pub id: ::core::ffi::c_int,
    #[doc = "\n X coordinate relative to the left side of the view.\n"]
    pub x: f32,
    #[doc = "\n Y coordinate relative to the top side of the view.\n"]
    pub y: f32,
    #[doc = "\n X radius in pixels. Set to 0 if not applicable.\n"]
    pub radius_x: f32,
    #[doc = "\n Y radius in pixels. Set to 0 if not applicable.\n"]
    pub radius_y: f32,
    #[doc = "\n Rotation angle in radians. Set to 0 if not applicable.\n"]
    pub rotation_angle: f32,
    #[doc = "\n The normalized pressure of the pointer input in the range of [0,1].\n Set to 0 if not applicable.\n"]
    pub pressure: f32,
    #[doc = "\n The state of the touch point. Touches begin with one CEF_TET_PRESSED event\n followed by zero or more CEF_TET_MOVED events and finally one\n CEF_TET_RELEASED or CEF_TET_CANCELLED event. Events not respecting this\n order will be ignored.\n"]
    pub type_: cef_touch_event_type_t,
    #[doc = "\n Bit flags describing any pressed modifier keys. See\n cef_event_flags_t for values.\n"]
    pub modifiers: uint32,
    #[doc = "\n The device type that caused the event.\n"]
    pub pointer_type: cef_pointer_type_t,
}
#[test]
fn bindgen_test_layout__cef_touch_event_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_touch_event_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_touch_event_t>(),
        40usize,
        concat!("Size of: ", stringify!(_cef_touch_event_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_touch_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_cef_touch_event_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_touch_event_t),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_touch_event_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_touch_event_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).radius_x) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_touch_event_t),
            "::",
            stringify!(radius_x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).radius_y) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_touch_event_t),
            "::",
            stringify!(radius_y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rotation_angle) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_touch_event_t),
            "::",
            stringify!(rotation_angle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pressure) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_touch_event_t),
            "::",
            stringify!(pressure)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_touch_event_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).modifiers) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_touch_event_t),
            "::",
            stringify!(modifiers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pointer_type) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_touch_event_t),
            "::",
            stringify!(pointer_type)
        )
    );
}
#[doc = "\n Structure representing touch event information.\n"]
pub type cef_touch_event_t = _cef_touch_event_t;
pub const cef_paint_element_type_t_PET_VIEW: cef_paint_element_type_t = 0;
pub const cef_paint_element_type_t_PET_POPUP: cef_paint_element_type_t = 1;
#[doc = "\n Paint element types.\n"]
pub type cef_paint_element_type_t = i32;
pub const cef_event_flags_t_EVENTFLAG_NONE: cef_event_flags_t = 0;
pub const cef_event_flags_t_EVENTFLAG_CAPS_LOCK_ON: cef_event_flags_t = 1;
pub const cef_event_flags_t_EVENTFLAG_SHIFT_DOWN: cef_event_flags_t = 2;
pub const cef_event_flags_t_EVENTFLAG_CONTROL_DOWN: cef_event_flags_t = 4;
pub const cef_event_flags_t_EVENTFLAG_ALT_DOWN: cef_event_flags_t = 8;
pub const cef_event_flags_t_EVENTFLAG_LEFT_MOUSE_BUTTON: cef_event_flags_t = 16;
pub const cef_event_flags_t_EVENTFLAG_MIDDLE_MOUSE_BUTTON: cef_event_flags_t = 32;
pub const cef_event_flags_t_EVENTFLAG_RIGHT_MOUSE_BUTTON: cef_event_flags_t = 64;
#[doc = " Mac OS-X command key."]
pub const cef_event_flags_t_EVENTFLAG_COMMAND_DOWN: cef_event_flags_t = 128;
#[doc = " Mac OS-X command key."]
pub const cef_event_flags_t_EVENTFLAG_NUM_LOCK_ON: cef_event_flags_t = 256;
#[doc = " Mac OS-X command key."]
pub const cef_event_flags_t_EVENTFLAG_IS_KEY_PAD: cef_event_flags_t = 512;
#[doc = " Mac OS-X command key."]
pub const cef_event_flags_t_EVENTFLAG_IS_LEFT: cef_event_flags_t = 1024;
#[doc = " Mac OS-X command key."]
pub const cef_event_flags_t_EVENTFLAG_IS_RIGHT: cef_event_flags_t = 2048;
#[doc = " Mac OS-X command key."]
pub const cef_event_flags_t_EVENTFLAG_ALTGR_DOWN: cef_event_flags_t = 4096;
#[doc = "\n Supported event bit flags.\n"]
pub type cef_event_flags_t = i32;
pub const cef_menu_item_type_t_MENUITEMTYPE_NONE: cef_menu_item_type_t = 0;
pub const cef_menu_item_type_t_MENUITEMTYPE_COMMAND: cef_menu_item_type_t = 1;
pub const cef_menu_item_type_t_MENUITEMTYPE_CHECK: cef_menu_item_type_t = 2;
pub const cef_menu_item_type_t_MENUITEMTYPE_RADIO: cef_menu_item_type_t = 3;
pub const cef_menu_item_type_t_MENUITEMTYPE_SEPARATOR: cef_menu_item_type_t = 4;
pub const cef_menu_item_type_t_MENUITEMTYPE_SUBMENU: cef_menu_item_type_t = 5;
#[doc = "\n Supported menu item types.\n"]
pub type cef_menu_item_type_t = i32;
#[doc = "\n No node is selected.\n"]
pub const cef_context_menu_type_flags_t_CM_TYPEFLAG_NONE: cef_context_menu_type_flags_t = 0;
#[doc = "\n The top page is selected.\n"]
pub const cef_context_menu_type_flags_t_CM_TYPEFLAG_PAGE: cef_context_menu_type_flags_t = 1;
#[doc = "\n A subframe page is selected.\n"]
pub const cef_context_menu_type_flags_t_CM_TYPEFLAG_FRAME: cef_context_menu_type_flags_t = 2;
#[doc = "\n A link is selected.\n"]
pub const cef_context_menu_type_flags_t_CM_TYPEFLAG_LINK: cef_context_menu_type_flags_t = 4;
#[doc = "\n A media node is selected.\n"]
pub const cef_context_menu_type_flags_t_CM_TYPEFLAG_MEDIA: cef_context_menu_type_flags_t = 8;
#[doc = "\n There is a textual or mixed selection that is selected.\n"]
pub const cef_context_menu_type_flags_t_CM_TYPEFLAG_SELECTION: cef_context_menu_type_flags_t = 16;
#[doc = "\n An editable element is selected.\n"]
pub const cef_context_menu_type_flags_t_CM_TYPEFLAG_EDITABLE: cef_context_menu_type_flags_t = 32;
#[doc = "\n Supported context menu type flags.\n"]
pub type cef_context_menu_type_flags_t = i32;
#[doc = "\n No special node is in context.\n"]
pub const cef_context_menu_media_type_t_CM_MEDIATYPE_NONE: cef_context_menu_media_type_t = 0;
#[doc = "\n An image node is selected.\n"]
pub const cef_context_menu_media_type_t_CM_MEDIATYPE_IMAGE: cef_context_menu_media_type_t = 1;
#[doc = "\n A video node is selected.\n"]
pub const cef_context_menu_media_type_t_CM_MEDIATYPE_VIDEO: cef_context_menu_media_type_t = 2;
#[doc = "\n An audio node is selected.\n"]
pub const cef_context_menu_media_type_t_CM_MEDIATYPE_AUDIO: cef_context_menu_media_type_t = 3;
#[doc = "\n A file node is selected.\n"]
pub const cef_context_menu_media_type_t_CM_MEDIATYPE_FILE: cef_context_menu_media_type_t = 4;
#[doc = "\n A plugin node is selected.\n"]
pub const cef_context_menu_media_type_t_CM_MEDIATYPE_PLUGIN: cef_context_menu_media_type_t = 5;
#[doc = "\n Supported context menu media types.\n"]
pub type cef_context_menu_media_type_t = i32;
pub const cef_context_menu_media_state_flags_t_CM_MEDIAFLAG_NONE:
    cef_context_menu_media_state_flags_t = 0;
pub const cef_context_menu_media_state_flags_t_CM_MEDIAFLAG_ERROR:
    cef_context_menu_media_state_flags_t = 1;
pub const cef_context_menu_media_state_flags_t_CM_MEDIAFLAG_PAUSED:
    cef_context_menu_media_state_flags_t = 2;
pub const cef_context_menu_media_state_flags_t_CM_MEDIAFLAG_MUTED:
    cef_context_menu_media_state_flags_t = 4;
pub const cef_context_menu_media_state_flags_t_CM_MEDIAFLAG_LOOP:
    cef_context_menu_media_state_flags_t = 8;
pub const cef_context_menu_media_state_flags_t_CM_MEDIAFLAG_CAN_SAVE:
    cef_context_menu_media_state_flags_t = 16;
pub const cef_context_menu_media_state_flags_t_CM_MEDIAFLAG_HAS_AUDIO:
    cef_context_menu_media_state_flags_t = 32;
pub const cef_context_menu_media_state_flags_t_CM_MEDIAFLAG_HAS_VIDEO:
    cef_context_menu_media_state_flags_t = 64;
pub const cef_context_menu_media_state_flags_t_CM_MEDIAFLAG_CONTROL_ROOT_ELEMENT:
    cef_context_menu_media_state_flags_t = 128;
pub const cef_context_menu_media_state_flags_t_CM_MEDIAFLAG_CAN_PRINT:
    cef_context_menu_media_state_flags_t = 256;
pub const cef_context_menu_media_state_flags_t_CM_MEDIAFLAG_CAN_ROTATE:
    cef_context_menu_media_state_flags_t = 512;
#[doc = "\n Supported context menu media state bit flags.\n"]
pub type cef_context_menu_media_state_flags_t = i32;
pub const cef_context_menu_edit_state_flags_t_CM_EDITFLAG_NONE:
    cef_context_menu_edit_state_flags_t = 0;
pub const cef_context_menu_edit_state_flags_t_CM_EDITFLAG_CAN_UNDO:
    cef_context_menu_edit_state_flags_t = 1;
pub const cef_context_menu_edit_state_flags_t_CM_EDITFLAG_CAN_REDO:
    cef_context_menu_edit_state_flags_t = 2;
pub const cef_context_menu_edit_state_flags_t_CM_EDITFLAG_CAN_CUT:
    cef_context_menu_edit_state_flags_t = 4;
pub const cef_context_menu_edit_state_flags_t_CM_EDITFLAG_CAN_COPY:
    cef_context_menu_edit_state_flags_t = 8;
pub const cef_context_menu_edit_state_flags_t_CM_EDITFLAG_CAN_PASTE:
    cef_context_menu_edit_state_flags_t = 16;
pub const cef_context_menu_edit_state_flags_t_CM_EDITFLAG_CAN_DELETE:
    cef_context_menu_edit_state_flags_t = 32;
pub const cef_context_menu_edit_state_flags_t_CM_EDITFLAG_CAN_SELECT_ALL:
    cef_context_menu_edit_state_flags_t = 64;
pub const cef_context_menu_edit_state_flags_t_CM_EDITFLAG_CAN_TRANSLATE:
    cef_context_menu_edit_state_flags_t = 128;
#[doc = "\n Supported context menu edit state bit flags.\n"]
pub type cef_context_menu_edit_state_flags_t = i32;
#[doc = "\n Notification that a key transitioned from \"up\" to \"down\".\n"]
pub const cef_key_event_type_t_KEYEVENT_RAWKEYDOWN: cef_key_event_type_t = 0;
#[doc = "\n Notification that a key was pressed. This does not necessarily correspond\n to a character depending on the key and language. Use KEYEVENT_CHAR for\n character input.\n"]
pub const cef_key_event_type_t_KEYEVENT_KEYDOWN: cef_key_event_type_t = 1;
#[doc = "\n Notification that a key was released.\n"]
pub const cef_key_event_type_t_KEYEVENT_KEYUP: cef_key_event_type_t = 2;
#[doc = "\n Notification that a character was typed. Use this for text input. Key\n down events may generate 0, 1, or more than one character event depending\n on the key, locale, and operating system.\n"]
pub const cef_key_event_type_t_KEYEVENT_CHAR: cef_key_event_type_t = 3;
#[doc = "\n Key event types.\n"]
pub type cef_key_event_type_t = i32;
#[doc = "\n Structure representing keyboard event information.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_key_event_t {
    #[doc = "\n The type of keyboard event.\n"]
    pub type_: cef_key_event_type_t,
    #[doc = "\n Bit flags describing any pressed modifier keys. See\n cef_event_flags_t for values.\n"]
    pub modifiers: uint32,
    #[doc = "\n The Windows key code for the key event. This value is used by the DOM\n specification. Sometimes it comes directly from the event (i.e. on\n Windows) and sometimes it's determined using a mapping function. See\n WebCore/platform/chromium/KeyboardCodes.h for the list of values.\n"]
    pub windows_key_code: ::core::ffi::c_int,
    #[doc = "\n The actual key code genenerated by the platform.\n"]
    pub native_key_code: ::core::ffi::c_int,
    #[doc = "\n Indicates whether the event is considered a \"system key\" event (see\n http://msdn.microsoft.com/en-us/library/ms646286(VS.85).aspx for details).\n This value will always be false on non-Windows platforms.\n"]
    pub is_system_key: ::core::ffi::c_int,
    #[doc = "\n The character generated by the keystroke.\n"]
    pub character: char16,
    #[doc = "\n Same as |character| but unmodified by any concurrently-held modifiers\n (except shift). This is useful for working out shortcut keys.\n"]
    pub unmodified_character: char16,
    #[doc = "\n True if the focus is currently on an editable field on the page. This is\n useful for determining if standard key events should be intercepted.\n"]
    pub focus_on_editable_field: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout__cef_key_event_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_key_event_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_key_event_t>(),
        28usize,
        concat!("Size of: ", stringify!(_cef_key_event_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_key_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_cef_key_event_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_key_event_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).modifiers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_key_event_t),
            "::",
            stringify!(modifiers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).windows_key_code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_key_event_t),
            "::",
            stringify!(windows_key_code)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).native_key_code) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_key_event_t),
            "::",
            stringify!(native_key_code)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_system_key) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_key_event_t),
            "::",
            stringify!(is_system_key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).character) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_key_event_t),
            "::",
            stringify!(character)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unmodified_character) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_key_event_t),
            "::",
            stringify!(unmodified_character)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).focus_on_editable_field) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_key_event_t),
            "::",
            stringify!(focus_on_editable_field)
        )
    );
}
#[doc = "\n Structure representing keyboard event information.\n"]
pub type cef_key_event_t = _cef_key_event_t;
#[doc = "\n The source is explicit navigation via the API (LoadURL(), etc).\n"]
pub const cef_focus_source_t_FOCUS_SOURCE_NAVIGATION: cef_focus_source_t = 0;
#[doc = "\n The source is a system-generated focus event.\n"]
pub const cef_focus_source_t_FOCUS_SOURCE_SYSTEM: cef_focus_source_t = 1;
#[doc = "\n Focus sources.\n"]
pub type cef_focus_source_t = i32;
pub const cef_navigation_type_t_NAVIGATION_LINK_CLICKED: cef_navigation_type_t = 0;
pub const cef_navigation_type_t_NAVIGATION_FORM_SUBMITTED: cef_navigation_type_t = 1;
pub const cef_navigation_type_t_NAVIGATION_BACK_FORWARD: cef_navigation_type_t = 2;
pub const cef_navigation_type_t_NAVIGATION_RELOAD: cef_navigation_type_t = 3;
pub const cef_navigation_type_t_NAVIGATION_FORM_RESUBMITTED: cef_navigation_type_t = 4;
pub const cef_navigation_type_t_NAVIGATION_OTHER: cef_navigation_type_t = 5;
#[doc = "\n Navigation types.\n"]
pub type cef_navigation_type_t = i32;
pub const cef_xml_encoding_type_t_XML_ENCODING_NONE: cef_xml_encoding_type_t = 0;
pub const cef_xml_encoding_type_t_XML_ENCODING_UTF8: cef_xml_encoding_type_t = 1;
pub const cef_xml_encoding_type_t_XML_ENCODING_UTF16LE: cef_xml_encoding_type_t = 2;
pub const cef_xml_encoding_type_t_XML_ENCODING_UTF16BE: cef_xml_encoding_type_t = 3;
pub const cef_xml_encoding_type_t_XML_ENCODING_ASCII: cef_xml_encoding_type_t = 4;
#[doc = "\n Supported XML encoding types. The parser supports ASCII, ISO-8859-1, and\n UTF16 (LE and BE) by default. All other types must be translated to UTF8\n before being passed to the parser. If a BOM is detected and the correct\n decoder is available then that decoder will be used automatically.\n"]
pub type cef_xml_encoding_type_t = i32;
pub const cef_xml_node_type_t_XML_NODE_UNSUPPORTED: cef_xml_node_type_t = 0;
pub const cef_xml_node_type_t_XML_NODE_PROCESSING_INSTRUCTION: cef_xml_node_type_t = 1;
pub const cef_xml_node_type_t_XML_NODE_DOCUMENT_TYPE: cef_xml_node_type_t = 2;
pub const cef_xml_node_type_t_XML_NODE_ELEMENT_START: cef_xml_node_type_t = 3;
pub const cef_xml_node_type_t_XML_NODE_ELEMENT_END: cef_xml_node_type_t = 4;
pub const cef_xml_node_type_t_XML_NODE_ATTRIBUTE: cef_xml_node_type_t = 5;
pub const cef_xml_node_type_t_XML_NODE_TEXT: cef_xml_node_type_t = 6;
pub const cef_xml_node_type_t_XML_NODE_CDATA: cef_xml_node_type_t = 7;
pub const cef_xml_node_type_t_XML_NODE_ENTITY_REFERENCE: cef_xml_node_type_t = 8;
pub const cef_xml_node_type_t_XML_NODE_WHITESPACE: cef_xml_node_type_t = 9;
pub const cef_xml_node_type_t_XML_NODE_COMMENT: cef_xml_node_type_t = 10;
#[doc = "\n XML node types.\n"]
pub type cef_xml_node_type_t = i32;
#[doc = "\n Popup window features.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_popup_features_t {
    pub x: ::core::ffi::c_int,
    pub xSet: ::core::ffi::c_int,
    pub y: ::core::ffi::c_int,
    pub ySet: ::core::ffi::c_int,
    pub width: ::core::ffi::c_int,
    pub widthSet: ::core::ffi::c_int,
    pub height: ::core::ffi::c_int,
    pub heightSet: ::core::ffi::c_int,
    pub menuBarVisible: ::core::ffi::c_int,
    pub statusBarVisible: ::core::ffi::c_int,
    pub toolBarVisible: ::core::ffi::c_int,
    pub scrollbarsVisible: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout__cef_popup_features_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_popup_features_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_popup_features_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_popup_features_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_popup_features_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_cef_popup_features_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_popup_features_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xSet) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_popup_features_t),
            "::",
            stringify!(xSet)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_popup_features_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ySet) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_popup_features_t),
            "::",
            stringify!(ySet)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_popup_features_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).widthSet) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_popup_features_t),
            "::",
            stringify!(widthSet)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_popup_features_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).heightSet) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_popup_features_t),
            "::",
            stringify!(heightSet)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).menuBarVisible) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_popup_features_t),
            "::",
            stringify!(menuBarVisible)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).statusBarVisible) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_popup_features_t),
            "::",
            stringify!(statusBarVisible)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).toolBarVisible) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_popup_features_t),
            "::",
            stringify!(toolBarVisible)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scrollbarsVisible) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_popup_features_t),
            "::",
            stringify!(scrollbarsVisible)
        )
    );
}
#[doc = "\n Popup window features.\n"]
pub type cef_popup_features_t = _cef_popup_features_t;
pub const cef_dom_document_type_t_DOM_DOCUMENT_TYPE_UNKNOWN: cef_dom_document_type_t = 0;
pub const cef_dom_document_type_t_DOM_DOCUMENT_TYPE_HTML: cef_dom_document_type_t = 1;
pub const cef_dom_document_type_t_DOM_DOCUMENT_TYPE_XHTML: cef_dom_document_type_t = 2;
pub const cef_dom_document_type_t_DOM_DOCUMENT_TYPE_PLUGIN: cef_dom_document_type_t = 3;
#[doc = "\n DOM document types.\n"]
pub type cef_dom_document_type_t = i32;
pub const cef_dom_event_category_t_DOM_EVENT_CATEGORY_UNKNOWN: cef_dom_event_category_t = 0;
pub const cef_dom_event_category_t_DOM_EVENT_CATEGORY_UI: cef_dom_event_category_t = 1;
pub const cef_dom_event_category_t_DOM_EVENT_CATEGORY_MOUSE: cef_dom_event_category_t = 2;
pub const cef_dom_event_category_t_DOM_EVENT_CATEGORY_MUTATION: cef_dom_event_category_t = 4;
pub const cef_dom_event_category_t_DOM_EVENT_CATEGORY_KEYBOARD: cef_dom_event_category_t = 8;
pub const cef_dom_event_category_t_DOM_EVENT_CATEGORY_TEXT: cef_dom_event_category_t = 16;
pub const cef_dom_event_category_t_DOM_EVENT_CATEGORY_COMPOSITION: cef_dom_event_category_t = 32;
pub const cef_dom_event_category_t_DOM_EVENT_CATEGORY_DRAG: cef_dom_event_category_t = 64;
pub const cef_dom_event_category_t_DOM_EVENT_CATEGORY_CLIPBOARD: cef_dom_event_category_t = 128;
pub const cef_dom_event_category_t_DOM_EVENT_CATEGORY_MESSAGE: cef_dom_event_category_t = 256;
pub const cef_dom_event_category_t_DOM_EVENT_CATEGORY_WHEEL: cef_dom_event_category_t = 512;
pub const cef_dom_event_category_t_DOM_EVENT_CATEGORY_BEFORE_TEXT_INSERTED:
    cef_dom_event_category_t = 1024;
pub const cef_dom_event_category_t_DOM_EVENT_CATEGORY_OVERFLOW: cef_dom_event_category_t = 2048;
pub const cef_dom_event_category_t_DOM_EVENT_CATEGORY_PAGE_TRANSITION: cef_dom_event_category_t =
    4096;
pub const cef_dom_event_category_t_DOM_EVENT_CATEGORY_POPSTATE: cef_dom_event_category_t = 8192;
pub const cef_dom_event_category_t_DOM_EVENT_CATEGORY_PROGRESS: cef_dom_event_category_t = 16384;
pub const cef_dom_event_category_t_DOM_EVENT_CATEGORY_XMLHTTPREQUEST_PROGRESS:
    cef_dom_event_category_t = 32768;
#[doc = "\n DOM event category flags.\n"]
pub type cef_dom_event_category_t = i32;
pub const cef_dom_event_phase_t_DOM_EVENT_PHASE_UNKNOWN: cef_dom_event_phase_t = 0;
pub const cef_dom_event_phase_t_DOM_EVENT_PHASE_CAPTURING: cef_dom_event_phase_t = 1;
pub const cef_dom_event_phase_t_DOM_EVENT_PHASE_AT_TARGET: cef_dom_event_phase_t = 2;
pub const cef_dom_event_phase_t_DOM_EVENT_PHASE_BUBBLING: cef_dom_event_phase_t = 3;
#[doc = "\n DOM event processing phases.\n"]
pub type cef_dom_event_phase_t = i32;
pub const cef_dom_node_type_t_DOM_NODE_TYPE_UNSUPPORTED: cef_dom_node_type_t = 0;
pub const cef_dom_node_type_t_DOM_NODE_TYPE_ELEMENT: cef_dom_node_type_t = 1;
pub const cef_dom_node_type_t_DOM_NODE_TYPE_ATTRIBUTE: cef_dom_node_type_t = 2;
pub const cef_dom_node_type_t_DOM_NODE_TYPE_TEXT: cef_dom_node_type_t = 3;
pub const cef_dom_node_type_t_DOM_NODE_TYPE_CDATA_SECTION: cef_dom_node_type_t = 4;
pub const cef_dom_node_type_t_DOM_NODE_TYPE_PROCESSING_INSTRUCTIONS: cef_dom_node_type_t = 5;
pub const cef_dom_node_type_t_DOM_NODE_TYPE_COMMENT: cef_dom_node_type_t = 6;
pub const cef_dom_node_type_t_DOM_NODE_TYPE_DOCUMENT: cef_dom_node_type_t = 7;
pub const cef_dom_node_type_t_DOM_NODE_TYPE_DOCUMENT_TYPE: cef_dom_node_type_t = 8;
pub const cef_dom_node_type_t_DOM_NODE_TYPE_DOCUMENT_FRAGMENT: cef_dom_node_type_t = 9;
#[doc = "\n DOM node types.\n"]
pub type cef_dom_node_type_t = i32;
#[doc = "\n Requires that the file exists before allowing the user to pick it.\n"]
pub const cef_file_dialog_mode_t_FILE_DIALOG_OPEN: cef_file_dialog_mode_t = 0;
#[doc = "\n Like Open, but allows picking multiple files to open.\n"]
pub const cef_file_dialog_mode_t_FILE_DIALOG_OPEN_MULTIPLE: cef_file_dialog_mode_t = 1;
#[doc = "\n Like Open, but selects a folder to open.\n"]
pub const cef_file_dialog_mode_t_FILE_DIALOG_OPEN_FOLDER: cef_file_dialog_mode_t = 2;
#[doc = "\n Allows picking a nonexistent file, and prompts to overwrite if the file\n already exists.\n"]
pub const cef_file_dialog_mode_t_FILE_DIALOG_SAVE: cef_file_dialog_mode_t = 3;
#[doc = "\n General mask defining the bits used for the type values.\n"]
pub const cef_file_dialog_mode_t_FILE_DIALOG_TYPE_MASK: cef_file_dialog_mode_t = 255;
#[doc = "\n Prompt to overwrite if the user selects an existing file with the Save\n dialog.\n"]
pub const cef_file_dialog_mode_t_FILE_DIALOG_OVERWRITEPROMPT_FLAG: cef_file_dialog_mode_t =
    16777216;
#[doc = "\n Do not display read-only files.\n"]
pub const cef_file_dialog_mode_t_FILE_DIALOG_HIDEREADONLY_FLAG: cef_file_dialog_mode_t = 33554432;
#[doc = "\n Supported file dialog modes.\n"]
pub type cef_file_dialog_mode_t = i32;
pub const cef_color_model_t_COLOR_MODEL_UNKNOWN: cef_color_model_t = 0;
pub const cef_color_model_t_COLOR_MODEL_GRAY: cef_color_model_t = 1;
pub const cef_color_model_t_COLOR_MODEL_COLOR: cef_color_model_t = 2;
pub const cef_color_model_t_COLOR_MODEL_CMYK: cef_color_model_t = 3;
pub const cef_color_model_t_COLOR_MODEL_CMY: cef_color_model_t = 4;
pub const cef_color_model_t_COLOR_MODEL_KCMY: cef_color_model_t = 5;
#[doc = " CMY_K represents CMY+K."]
pub const cef_color_model_t_COLOR_MODEL_CMY_K: cef_color_model_t = 6;
pub const cef_color_model_t_COLOR_MODEL_BLACK: cef_color_model_t = 7;
pub const cef_color_model_t_COLOR_MODEL_GRAYSCALE: cef_color_model_t = 8;
pub const cef_color_model_t_COLOR_MODEL_RGB: cef_color_model_t = 9;
pub const cef_color_model_t_COLOR_MODEL_RGB16: cef_color_model_t = 10;
pub const cef_color_model_t_COLOR_MODEL_RGBA: cef_color_model_t = 11;
#[doc = " Used in samsung printer ppds."]
pub const cef_color_model_t_COLOR_MODEL_COLORMODE_COLOR: cef_color_model_t = 12;
#[doc = " Used in samsung printer ppds."]
pub const cef_color_model_t_COLOR_MODEL_COLORMODE_MONOCHROME: cef_color_model_t = 13;
#[doc = " Used in HP color printer ppds."]
pub const cef_color_model_t_COLOR_MODEL_HP_COLOR_COLOR: cef_color_model_t = 14;
#[doc = " Used in HP color printer ppds."]
pub const cef_color_model_t_COLOR_MODEL_HP_COLOR_BLACK: cef_color_model_t = 15;
#[doc = " Used in foomatic ppds."]
pub const cef_color_model_t_COLOR_MODEL_PRINTOUTMODE_NORMAL: cef_color_model_t = 16;
#[doc = " Used in foomatic ppds."]
pub const cef_color_model_t_COLOR_MODEL_PRINTOUTMODE_NORMAL_GRAY: cef_color_model_t = 17;
#[doc = " Used in canon printer ppds."]
pub const cef_color_model_t_COLOR_MODEL_PROCESSCOLORMODEL_CMYK: cef_color_model_t = 18;
#[doc = " Used in canon printer ppds."]
pub const cef_color_model_t_COLOR_MODEL_PROCESSCOLORMODEL_GREYSCALE: cef_color_model_t = 19;
#[doc = " Used in canon printer ppds"]
pub const cef_color_model_t_COLOR_MODEL_PROCESSCOLORMODEL_RGB: cef_color_model_t = 20;
#[doc = "\n Print job color mode values.\n"]
pub type cef_color_model_t = i32;
pub const cef_duplex_mode_t_DUPLEX_MODE_UNKNOWN: cef_duplex_mode_t = -1;
pub const cef_duplex_mode_t_DUPLEX_MODE_SIMPLEX: cef_duplex_mode_t = 0;
pub const cef_duplex_mode_t_DUPLEX_MODE_LONG_EDGE: cef_duplex_mode_t = 1;
pub const cef_duplex_mode_t_DUPLEX_MODE_SHORT_EDGE: cef_duplex_mode_t = 2;
#[doc = "\n Print job duplex mode values.\n"]
pub type cef_duplex_mode_t = i32;
pub const cef_cursor_type_t_CT_POINTER: cef_cursor_type_t = 0;
pub const cef_cursor_type_t_CT_CROSS: cef_cursor_type_t = 1;
pub const cef_cursor_type_t_CT_HAND: cef_cursor_type_t = 2;
pub const cef_cursor_type_t_CT_IBEAM: cef_cursor_type_t = 3;
pub const cef_cursor_type_t_CT_WAIT: cef_cursor_type_t = 4;
pub const cef_cursor_type_t_CT_HELP: cef_cursor_type_t = 5;
pub const cef_cursor_type_t_CT_EASTRESIZE: cef_cursor_type_t = 6;
pub const cef_cursor_type_t_CT_NORTHRESIZE: cef_cursor_type_t = 7;
pub const cef_cursor_type_t_CT_NORTHEASTRESIZE: cef_cursor_type_t = 8;
pub const cef_cursor_type_t_CT_NORTHWESTRESIZE: cef_cursor_type_t = 9;
pub const cef_cursor_type_t_CT_SOUTHRESIZE: cef_cursor_type_t = 10;
pub const cef_cursor_type_t_CT_SOUTHEASTRESIZE: cef_cursor_type_t = 11;
pub const cef_cursor_type_t_CT_SOUTHWESTRESIZE: cef_cursor_type_t = 12;
pub const cef_cursor_type_t_CT_WESTRESIZE: cef_cursor_type_t = 13;
pub const cef_cursor_type_t_CT_NORTHSOUTHRESIZE: cef_cursor_type_t = 14;
pub const cef_cursor_type_t_CT_EASTWESTRESIZE: cef_cursor_type_t = 15;
pub const cef_cursor_type_t_CT_NORTHEASTSOUTHWESTRESIZE: cef_cursor_type_t = 16;
pub const cef_cursor_type_t_CT_NORTHWESTSOUTHEASTRESIZE: cef_cursor_type_t = 17;
pub const cef_cursor_type_t_CT_COLUMNRESIZE: cef_cursor_type_t = 18;
pub const cef_cursor_type_t_CT_ROWRESIZE: cef_cursor_type_t = 19;
pub const cef_cursor_type_t_CT_MIDDLEPANNING: cef_cursor_type_t = 20;
pub const cef_cursor_type_t_CT_EASTPANNING: cef_cursor_type_t = 21;
pub const cef_cursor_type_t_CT_NORTHPANNING: cef_cursor_type_t = 22;
pub const cef_cursor_type_t_CT_NORTHEASTPANNING: cef_cursor_type_t = 23;
pub const cef_cursor_type_t_CT_NORTHWESTPANNING: cef_cursor_type_t = 24;
pub const cef_cursor_type_t_CT_SOUTHPANNING: cef_cursor_type_t = 25;
pub const cef_cursor_type_t_CT_SOUTHEASTPANNING: cef_cursor_type_t = 26;
pub const cef_cursor_type_t_CT_SOUTHWESTPANNING: cef_cursor_type_t = 27;
pub const cef_cursor_type_t_CT_WESTPANNING: cef_cursor_type_t = 28;
pub const cef_cursor_type_t_CT_MOVE: cef_cursor_type_t = 29;
pub const cef_cursor_type_t_CT_VERTICALTEXT: cef_cursor_type_t = 30;
pub const cef_cursor_type_t_CT_CELL: cef_cursor_type_t = 31;
pub const cef_cursor_type_t_CT_CONTEXTMENU: cef_cursor_type_t = 32;
pub const cef_cursor_type_t_CT_ALIAS: cef_cursor_type_t = 33;
pub const cef_cursor_type_t_CT_PROGRESS: cef_cursor_type_t = 34;
pub const cef_cursor_type_t_CT_NODROP: cef_cursor_type_t = 35;
pub const cef_cursor_type_t_CT_COPY: cef_cursor_type_t = 36;
pub const cef_cursor_type_t_CT_NONE: cef_cursor_type_t = 37;
pub const cef_cursor_type_t_CT_NOTALLOWED: cef_cursor_type_t = 38;
pub const cef_cursor_type_t_CT_ZOOMIN: cef_cursor_type_t = 39;
pub const cef_cursor_type_t_CT_ZOOMOUT: cef_cursor_type_t = 40;
pub const cef_cursor_type_t_CT_GRAB: cef_cursor_type_t = 41;
pub const cef_cursor_type_t_CT_GRABBING: cef_cursor_type_t = 42;
pub const cef_cursor_type_t_CT_MIDDLE_PANNING_VERTICAL: cef_cursor_type_t = 43;
pub const cef_cursor_type_t_CT_MIDDLE_PANNING_HORIZONTAL: cef_cursor_type_t = 44;
pub const cef_cursor_type_t_CT_CUSTOM: cef_cursor_type_t = 45;
pub const cef_cursor_type_t_CT_DND_NONE: cef_cursor_type_t = 46;
pub const cef_cursor_type_t_CT_DND_MOVE: cef_cursor_type_t = 47;
pub const cef_cursor_type_t_CT_DND_COPY: cef_cursor_type_t = 48;
pub const cef_cursor_type_t_CT_DND_LINK: cef_cursor_type_t = 49;
#[doc = "\n Cursor type values.\n"]
pub type cef_cursor_type_t = i32;
#[doc = "\n Structure representing cursor information. |buffer| will be\n |size.width|*|size.height|*4 bytes in size and represents a BGRA image with\n an upper-left origin.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_cursor_info_t {
    pub hotspot: cef_point_t,
    pub image_scale_factor: f32,
    pub buffer: *mut ::core::ffi::c_void,
    pub size: cef_size_t,
}
#[test]
fn bindgen_test_layout__cef_cursor_info_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_cursor_info_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_cursor_info_t>(),
        32usize,
        concat!("Size of: ", stringify!(_cef_cursor_info_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_cursor_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_cursor_info_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hotspot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_cursor_info_t),
            "::",
            stringify!(hotspot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).image_scale_factor) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_cursor_info_t),
            "::",
            stringify!(image_scale_factor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_cursor_info_t),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_cursor_info_t),
            "::",
            stringify!(size)
        )
    );
}
#[doc = "\n Structure representing cursor information. |buffer| will be\n |size.width|*|size.height|*4 bytes in size and represents a BGRA image with\n an upper-left origin.\n"]
pub type cef_cursor_info_t = _cef_cursor_info_t;
#[doc = "\n Don't unescape anything at all.\n"]
pub const cef_uri_unescape_rule_t_UU_NONE: cef_uri_unescape_rule_t = 0;
#[doc = "\n Don't unescape anything special, but all normal unescaping will happen.\n This is a placeholder and can't be combined with other flags (since it's\n just the absence of them). All other unescape rules imply \"normal\" in\n addition to their special meaning. Things like escaped letters, digits,\n and most symbols will get unescaped with this mode.\n"]
pub const cef_uri_unescape_rule_t_UU_NORMAL: cef_uri_unescape_rule_t = 1;
#[doc = "\n Convert %20 to spaces. In some places where we're showing URLs, we may\n want this. In places where the URL may be copied and pasted out, then\n you wouldn't want this since it might not be interpreted in one piece\n by other applications.\n"]
pub const cef_uri_unescape_rule_t_UU_SPACES: cef_uri_unescape_rule_t = 2;
#[doc = "\n Unescapes '/' and '\\\\'. If these characters were unescaped, the resulting\n URL won't be the same as the source one. Moreover, they are dangerous to\n unescape in strings that will be used as file paths or names. This value\n should only be used when slashes don't have special meaning, like data\n URLs.\n"]
pub const cef_uri_unescape_rule_t_UU_PATH_SEPARATORS: cef_uri_unescape_rule_t = 4;
#[doc = "\n Unescapes various characters that will change the meaning of URLs,\n including '%', '+', '&', '#'. Does not unescape path separators.\n If these characters were unescaped, the resulting URL won't be the same\n as the source one. This flag is used when generating final output like\n filenames for URLs where we won't be interpreting as a URL and want to do\n as much unescaping as possible.\n"]
pub const cef_uri_unescape_rule_t_UU_URL_SPECIAL_CHARS_EXCEPT_PATH_SEPARATORS:
    cef_uri_unescape_rule_t = 8;
#[doc = "\n URL queries use \"+\" for space. This flag controls that replacement.\n"]
pub const cef_uri_unescape_rule_t_UU_REPLACE_PLUS_WITH_SPACE: cef_uri_unescape_rule_t = 16;
#[doc = "\n URI unescape rules passed to CefURIDecode().\n"]
pub type cef_uri_unescape_rule_t = i32;
#[doc = "\n Parses the input strictly according to RFC 4627. See comments in Chromium's\n base/json/json_reader.h file for known limitations/deviations from the RFC.\n"]
pub const cef_json_parser_options_t_JSON_PARSER_RFC: cef_json_parser_options_t = 0;
#[doc = "\n Allows commas to exist after the last element in structures.\n"]
pub const cef_json_parser_options_t_JSON_PARSER_ALLOW_TRAILING_COMMAS: cef_json_parser_options_t =
    1;
#[doc = "\n Options that can be passed to CefParseJSON.\n"]
pub type cef_json_parser_options_t = i32;
#[doc = "\n Default behavior.\n"]
pub const cef_json_writer_options_t_JSON_WRITER_DEFAULT: cef_json_writer_options_t = 0;
#[doc = "\n This option instructs the writer that if a Binary value is encountered,\n the value (and key if within a dictionary) will be omitted from the\n output, and success will be returned. Otherwise, if a binary value is\n encountered, failure will be returned.\n"]
pub const cef_json_writer_options_t_JSON_WRITER_OMIT_BINARY_VALUES: cef_json_writer_options_t = 1;
#[doc = "\n This option instructs the writer to write doubles that have no fractional\n part as a normal integer (i.e., without using exponential notation\n or appending a '.0') as long as the value is within the range of a\n 64-bit int.\n"]
pub const cef_json_writer_options_t_JSON_WRITER_OMIT_DOUBLE_TYPE_PRESERVATION:
    cef_json_writer_options_t = 2;
#[doc = "\n Return a slightly nicer formatted json string (pads with whitespace to\n help with readability).\n"]
pub const cef_json_writer_options_t_JSON_WRITER_PRETTY_PRINT: cef_json_writer_options_t = 4;
#[doc = "\n Options that can be passed to CefWriteJSON.\n"]
pub type cef_json_writer_options_t = i32;
#[doc = "\n Default margins.\n"]
pub const cef_pdf_print_margin_type_t_PDF_PRINT_MARGIN_DEFAULT: cef_pdf_print_margin_type_t = 0;
#[doc = "\n No margins.\n"]
pub const cef_pdf_print_margin_type_t_PDF_PRINT_MARGIN_NONE: cef_pdf_print_margin_type_t = 1;
#[doc = "\n Minimum margins.\n"]
pub const cef_pdf_print_margin_type_t_PDF_PRINT_MARGIN_MINIMUM: cef_pdf_print_margin_type_t = 2;
#[doc = "\n Custom margins using the |margin_*| values from cef_pdf_print_settings_t.\n"]
pub const cef_pdf_print_margin_type_t_PDF_PRINT_MARGIN_CUSTOM: cef_pdf_print_margin_type_t = 3;
#[doc = "\n Margin type for PDF printing.\n"]
pub type cef_pdf_print_margin_type_t = i32;
#[doc = "\n Structure representing PDF print settings.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_pdf_print_settings_t {
    #[doc = "\n Page title to display in the header. Only used if |header_footer_enabled|\n is set to true (1).\n"]
    pub header_footer_title: cef_string_t,
    #[doc = "\n URL to display in the footer. Only used if |header_footer_enabled| is set\n to true (1).\n"]
    pub header_footer_url: cef_string_t,
    #[doc = "\n Output page size in microns. If either of these values is less than or\n equal to zero then the default paper size (A4) will be used.\n"]
    pub page_width: ::core::ffi::c_int,
    pub page_height: ::core::ffi::c_int,
    #[doc = "\n The percentage to scale the PDF by before printing (e.g. 50 is 50%).\n If this value is less than or equal to zero the default value of 100\n will be used.\n"]
    pub scale_factor: ::core::ffi::c_int,
    #[doc = "\n Margins in points. Only used if |margin_type| is set to\n PDF_PRINT_MARGIN_CUSTOM.\n"]
    pub margin_top: ::core::ffi::c_int,
    pub margin_right: ::core::ffi::c_int,
    pub margin_bottom: ::core::ffi::c_int,
    pub margin_left: ::core::ffi::c_int,
    #[doc = "\n Margin type.\n"]
    pub margin_type: cef_pdf_print_margin_type_t,
    #[doc = "\n Set to true (1) to print headers and footers or false (0) to not print\n headers and footers.\n"]
    pub header_footer_enabled: ::core::ffi::c_int,
    #[doc = "\n Set to true (1) to print the selection only or false (0) to print all.\n"]
    pub selection_only: ::core::ffi::c_int,
    #[doc = "\n Set to true (1) for landscape mode or false (0) for portrait mode.\n"]
    pub landscape: ::core::ffi::c_int,
    #[doc = "\n Set to true (1) to print background graphics or false (0) to not print\n background graphics.\n"]
    pub backgrounds_enabled: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout__cef_pdf_print_settings_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_pdf_print_settings_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_pdf_print_settings_t>(),
        96usize,
        concat!("Size of: ", stringify!(_cef_pdf_print_settings_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_pdf_print_settings_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_pdf_print_settings_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header_footer_title) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_pdf_print_settings_t),
            "::",
            stringify!(header_footer_title)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header_footer_url) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_pdf_print_settings_t),
            "::",
            stringify!(header_footer_url)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).page_width) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_pdf_print_settings_t),
            "::",
            stringify!(page_width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).page_height) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_pdf_print_settings_t),
            "::",
            stringify!(page_height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scale_factor) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_pdf_print_settings_t),
            "::",
            stringify!(scale_factor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).margin_top) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_pdf_print_settings_t),
            "::",
            stringify!(margin_top)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).margin_right) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_pdf_print_settings_t),
            "::",
            stringify!(margin_right)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).margin_bottom) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_pdf_print_settings_t),
            "::",
            stringify!(margin_bottom)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).margin_left) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_pdf_print_settings_t),
            "::",
            stringify!(margin_left)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).margin_type) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_pdf_print_settings_t),
            "::",
            stringify!(margin_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header_footer_enabled) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_pdf_print_settings_t),
            "::",
            stringify!(header_footer_enabled)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).selection_only) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_pdf_print_settings_t),
            "::",
            stringify!(selection_only)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).landscape) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_pdf_print_settings_t),
            "::",
            stringify!(landscape)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).backgrounds_enabled) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_pdf_print_settings_t),
            "::",
            stringify!(backgrounds_enabled)
        )
    );
}
#[doc = "\n Structure representing PDF print settings.\n"]
pub type cef_pdf_print_settings_t = _cef_pdf_print_settings_t;
pub const cef_scale_factor_t_SCALE_FACTOR_NONE: cef_scale_factor_t = 0;
pub const cef_scale_factor_t_SCALE_FACTOR_100P: cef_scale_factor_t = 1;
pub const cef_scale_factor_t_SCALE_FACTOR_125P: cef_scale_factor_t = 2;
pub const cef_scale_factor_t_SCALE_FACTOR_133P: cef_scale_factor_t = 3;
pub const cef_scale_factor_t_SCALE_FACTOR_140P: cef_scale_factor_t = 4;
pub const cef_scale_factor_t_SCALE_FACTOR_150P: cef_scale_factor_t = 5;
pub const cef_scale_factor_t_SCALE_FACTOR_180P: cef_scale_factor_t = 6;
pub const cef_scale_factor_t_SCALE_FACTOR_200P: cef_scale_factor_t = 7;
pub const cef_scale_factor_t_SCALE_FACTOR_250P: cef_scale_factor_t = 8;
pub const cef_scale_factor_t_SCALE_FACTOR_300P: cef_scale_factor_t = 9;
#[doc = "\n Supported UI scale factors for the platform. SCALE_FACTOR_NONE is used for\n density independent resources such as string, html/js files or an image that\n can be used for any scale factors (such as wallpapers).\n"]
pub type cef_scale_factor_t = i32;
#[doc = "\n Allow the content.\n"]
pub const cef_plugin_policy_t_PLUGIN_POLICY_ALLOW: cef_plugin_policy_t = 0;
#[doc = "\n Allow important content and block unimportant content based on heuristics.\n The user can manually load blocked content.\n"]
pub const cef_plugin_policy_t_PLUGIN_POLICY_DETECT_IMPORTANT: cef_plugin_policy_t = 1;
#[doc = "\n Block the content. The user can manually load blocked content.\n"]
pub const cef_plugin_policy_t_PLUGIN_POLICY_BLOCK: cef_plugin_policy_t = 2;
#[doc = "\n Disable the content. The user cannot load disabled content.\n"]
pub const cef_plugin_policy_t_PLUGIN_POLICY_DISABLE: cef_plugin_policy_t = 3;
#[doc = "\n Plugin policies supported by CefRequestContextHandler::OnBeforePluginLoad.\n"]
pub type cef_plugin_policy_t = i32;
#[doc = "\n Clear the referrer header if the header value is HTTPS but the request\n destination is HTTP. This is the default behavior.\n"]
pub const cef_referrer_policy_t_REFERRER_POLICY_CLEAR_REFERRER_ON_TRANSITION_FROM_SECURE_TO_INSECURE : cef_referrer_policy_t = 0 ;
#[doc = "\n Clear the referrer header if the header value is HTTPS but the request\n destination is HTTP. This is the default behavior.\n"]
pub const cef_referrer_policy_t_REFERRER_POLICY_DEFAULT: cef_referrer_policy_t = 0;
#[doc = "\n A slight variant on CLEAR_REFERRER_ON_TRANSITION_FROM_SECURE_TO_INSECURE:\n If the request destination is HTTP, an HTTPS referrer will be cleared. If\n the request's destination is cross-origin with the referrer (but does not\n downgrade), the referrer's granularity will be stripped down to an origin\n rather than a full URL. Same-origin requests will send the full referrer.\n"]
pub const cef_referrer_policy_t_REFERRER_POLICY_REDUCE_REFERRER_GRANULARITY_ON_TRANSITION_CROSS_ORIGIN : cef_referrer_policy_t = 1 ;
#[doc = "\n Strip the referrer down to an origin when the origin of the referrer is\n different from the destination's origin.\n"]
pub const cef_referrer_policy_t_REFERRER_POLICY_ORIGIN_ONLY_ON_TRANSITION_CROSS_ORIGIN:
    cef_referrer_policy_t = 2;
#[doc = "\n Never change the referrer.\n"]
pub const cef_referrer_policy_t_REFERRER_POLICY_NEVER_CLEAR_REFERRER: cef_referrer_policy_t = 3;
#[doc = "\n Strip the referrer down to the origin regardless of the redirect location.\n"]
pub const cef_referrer_policy_t_REFERRER_POLICY_ORIGIN: cef_referrer_policy_t = 4;
#[doc = "\n Clear the referrer when the request's referrer is cross-origin with the\n request's destination.\n"]
pub const cef_referrer_policy_t_REFERRER_POLICY_CLEAR_REFERRER_ON_TRANSITION_CROSS_ORIGIN:
    cef_referrer_policy_t = 5;
#[doc = "\n Strip the referrer down to the origin, but clear it entirely if the\n referrer value is HTTPS and the destination is HTTP.\n"]
pub const cef_referrer_policy_t_REFERRER_POLICY_ORIGIN_CLEAR_ON_TRANSITION_FROM_SECURE_TO_INSECURE : cef_referrer_policy_t = 6 ;
#[doc = "\n Always clear the referrer regardless of the request destination.\n"]
pub const cef_referrer_policy_t_REFERRER_POLICY_NO_REFERRER: cef_referrer_policy_t = 7;
#[doc = " Always the last value in this enumeration."]
pub const cef_referrer_policy_t_REFERRER_POLICY_LAST_VALUE: cef_referrer_policy_t = 7;
#[doc = "\n Policy for how the Referrer HTTP header value will be sent during navigation.\n If the `--no-referrers` command-line flag is specified then the policy value\n will be ignored and the Referrer value will never be sent.\n Must be kept synchronized with net::URLRequest::ReferrerPolicy from Chromium.\n"]
pub type cef_referrer_policy_t = i32;
#[doc = "\n Some or all of the pre-filter data was read successfully but more data is\n needed in order to continue filtering (filtered output is pending).\n"]
pub const cef_response_filter_status_t_RESPONSE_FILTER_NEED_MORE_DATA:
    cef_response_filter_status_t = 0;
#[doc = "\n Some or all of the pre-filter data was read successfully and all available\n filtered output has been written.\n"]
pub const cef_response_filter_status_t_RESPONSE_FILTER_DONE: cef_response_filter_status_t = 1;
#[doc = "\n An error occurred during filtering.\n"]
pub const cef_response_filter_status_t_RESPONSE_FILTER_ERROR: cef_response_filter_status_t = 2;
#[doc = "\n Return values for CefResponseFilter::Filter().\n"]
pub type cef_response_filter_status_t = i32;
#[doc = "\n RGBA with 8 bits per pixel (32bits total).\n"]
pub const cef_color_type_t_CEF_COLOR_TYPE_RGBA_8888: cef_color_type_t = 0;
#[doc = "\n BGRA with 8 bits per pixel (32bits total).\n"]
pub const cef_color_type_t_CEF_COLOR_TYPE_BGRA_8888: cef_color_type_t = 1;
#[doc = "\n Describes how to interpret the components of a pixel.\n"]
pub type cef_color_type_t = i32;
#[doc = "\n No transparency. The alpha component is ignored.\n"]
pub const cef_alpha_type_t_CEF_ALPHA_TYPE_OPAQUE: cef_alpha_type_t = 0;
#[doc = "\n Transparency with pre-multiplied alpha component.\n"]
pub const cef_alpha_type_t_CEF_ALPHA_TYPE_PREMULTIPLIED: cef_alpha_type_t = 1;
#[doc = "\n Transparency with post-multiplied alpha component.\n"]
pub const cef_alpha_type_t_CEF_ALPHA_TYPE_POSTMULTIPLIED: cef_alpha_type_t = 2;
#[doc = "\n Describes how to interpret the alpha component of a pixel.\n"]
pub type cef_alpha_type_t = i32;
pub const cef_text_style_t_CEF_TEXT_STYLE_BOLD: cef_text_style_t = 0;
pub const cef_text_style_t_CEF_TEXT_STYLE_ITALIC: cef_text_style_t = 1;
pub const cef_text_style_t_CEF_TEXT_STYLE_STRIKE: cef_text_style_t = 2;
pub const cef_text_style_t_CEF_TEXT_STYLE_DIAGONAL_STRIKE: cef_text_style_t = 3;
pub const cef_text_style_t_CEF_TEXT_STYLE_UNDERLINE: cef_text_style_t = 4;
#[doc = "\n Text style types. Should be kepy in sync with gfx::TextStyle.\n"]
pub type cef_text_style_t = i32;
#[doc = "\n Child views will be left-aligned.\n"]
pub const cef_main_axis_alignment_t_CEF_MAIN_AXIS_ALIGNMENT_START: cef_main_axis_alignment_t = 0;
#[doc = "\n Child views will be center-aligned.\n"]
pub const cef_main_axis_alignment_t_CEF_MAIN_AXIS_ALIGNMENT_CENTER: cef_main_axis_alignment_t = 1;
#[doc = "\n Child views will be right-aligned.\n"]
pub const cef_main_axis_alignment_t_CEF_MAIN_AXIS_ALIGNMENT_END: cef_main_axis_alignment_t = 2;
#[doc = "\n Specifies where along the main axis the CefBoxLayout child views should be\n laid out.\n"]
pub type cef_main_axis_alignment_t = i32;
#[doc = "\n Child views will be stretched to fit.\n"]
pub const cef_cross_axis_alignment_t_CEF_CROSS_AXIS_ALIGNMENT_STRETCH: cef_cross_axis_alignment_t =
    0;
#[doc = "\n Child views will be left-aligned.\n"]
pub const cef_cross_axis_alignment_t_CEF_CROSS_AXIS_ALIGNMENT_START: cef_cross_axis_alignment_t = 1;
#[doc = "\n Child views will be center-aligned.\n"]
pub const cef_cross_axis_alignment_t_CEF_CROSS_AXIS_ALIGNMENT_CENTER: cef_cross_axis_alignment_t =
    2;
#[doc = "\n Child views will be right-aligned.\n"]
pub const cef_cross_axis_alignment_t_CEF_CROSS_AXIS_ALIGNMENT_END: cef_cross_axis_alignment_t = 3;
#[doc = "\n Specifies where along the cross axis the CefBoxLayout child views should be\n laid out.\n"]
pub type cef_cross_axis_alignment_t = i32;
#[doc = "\n Settings used when initializing a CefBoxLayout.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_box_layout_settings_t {
    #[doc = "\n If true (1) the layout will be horizontal, otherwise the layout will be\n vertical.\n"]
    pub horizontal: ::core::ffi::c_int,
    #[doc = "\n Adds additional horizontal space between the child view area and the host\n view border.\n"]
    pub inside_border_horizontal_spacing: ::core::ffi::c_int,
    #[doc = "\n Adds additional vertical space between the child view area and the host\n view border.\n"]
    pub inside_border_vertical_spacing: ::core::ffi::c_int,
    #[doc = "\n Adds additional space around the child view area.\n"]
    pub inside_border_insets: cef_insets_t,
    #[doc = "\n Adds additional space between child views.\n"]
    pub between_child_spacing: ::core::ffi::c_int,
    #[doc = "\n Specifies where along the main axis the child views should be laid out.\n"]
    pub main_axis_alignment: cef_main_axis_alignment_t,
    #[doc = "\n Specifies where along the cross axis the child views should be laid out.\n"]
    pub cross_axis_alignment: cef_cross_axis_alignment_t,
    #[doc = "\n Minimum cross axis size.\n"]
    pub minimum_cross_axis_size: ::core::ffi::c_int,
    #[doc = "\n Default flex for views when none is specified via CefBoxLayout methods.\n Using the preferred size as the basis, free space along the main axis is\n distributed to views in the ratio of their flex weights. Similarly, if the\n views will overflow the parent, space is subtracted in these ratios. A flex\n of 0 means this view is not resized. Flex values must not be negative.\n"]
    pub default_flex: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout__cef_box_layout_settings_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_box_layout_settings_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_box_layout_settings_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_box_layout_settings_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_box_layout_settings_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_cef_box_layout_settings_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).horizontal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_box_layout_settings_t),
            "::",
            stringify!(horizontal)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).inside_border_horizontal_spacing) as usize - ptr as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_box_layout_settings_t),
            "::",
            stringify!(inside_border_horizontal_spacing)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).inside_border_vertical_spacing) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_box_layout_settings_t),
            "::",
            stringify!(inside_border_vertical_spacing)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inside_border_insets) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_box_layout_settings_t),
            "::",
            stringify!(inside_border_insets)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).between_child_spacing) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_box_layout_settings_t),
            "::",
            stringify!(between_child_spacing)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).main_axis_alignment) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_box_layout_settings_t),
            "::",
            stringify!(main_axis_alignment)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cross_axis_alignment) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_box_layout_settings_t),
            "::",
            stringify!(cross_axis_alignment)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).minimum_cross_axis_size) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_box_layout_settings_t),
            "::",
            stringify!(minimum_cross_axis_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).default_flex) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_box_layout_settings_t),
            "::",
            stringify!(default_flex)
        )
    );
}
#[doc = "\n Settings used when initializing a CefBoxLayout.\n"]
pub type cef_box_layout_settings_t = _cef_box_layout_settings_t;
pub const cef_button_state_t_CEF_BUTTON_STATE_NORMAL: cef_button_state_t = 0;
pub const cef_button_state_t_CEF_BUTTON_STATE_HOVERED: cef_button_state_t = 1;
pub const cef_button_state_t_CEF_BUTTON_STATE_PRESSED: cef_button_state_t = 2;
pub const cef_button_state_t_CEF_BUTTON_STATE_DISABLED: cef_button_state_t = 3;
#[doc = "\n Specifies the button display state.\n"]
pub type cef_button_state_t = i32;
#[doc = "\n Align the text's left edge with that of its display area.\n"]
pub const cef_horizontal_alignment_t_CEF_HORIZONTAL_ALIGNMENT_LEFT: cef_horizontal_alignment_t = 0;
#[doc = "\n Align the text's center with that of its display area.\n"]
pub const cef_horizontal_alignment_t_CEF_HORIZONTAL_ALIGNMENT_CENTER: cef_horizontal_alignment_t =
    1;
#[doc = "\n Align the text's right edge with that of its display area.\n"]
pub const cef_horizontal_alignment_t_CEF_HORIZONTAL_ALIGNMENT_RIGHT: cef_horizontal_alignment_t = 2;
#[doc = "\n Specifies the horizontal text alignment mode.\n"]
pub type cef_horizontal_alignment_t = i32;
pub const cef_menu_anchor_position_t_CEF_MENU_ANCHOR_TOPLEFT: cef_menu_anchor_position_t = 0;
pub const cef_menu_anchor_position_t_CEF_MENU_ANCHOR_TOPRIGHT: cef_menu_anchor_position_t = 1;
pub const cef_menu_anchor_position_t_CEF_MENU_ANCHOR_BOTTOMCENTER: cef_menu_anchor_position_t = 2;
#[doc = "\n Specifies how a menu will be anchored for non-RTL languages. The opposite\n position will be used for RTL languages.\n"]
pub type cef_menu_anchor_position_t = i32;
pub const cef_menu_color_type_t_CEF_MENU_COLOR_TEXT: cef_menu_color_type_t = 0;
pub const cef_menu_color_type_t_CEF_MENU_COLOR_TEXT_HOVERED: cef_menu_color_type_t = 1;
pub const cef_menu_color_type_t_CEF_MENU_COLOR_TEXT_ACCELERATOR: cef_menu_color_type_t = 2;
pub const cef_menu_color_type_t_CEF_MENU_COLOR_TEXT_ACCELERATOR_HOVERED: cef_menu_color_type_t = 3;
pub const cef_menu_color_type_t_CEF_MENU_COLOR_BACKGROUND: cef_menu_color_type_t = 4;
pub const cef_menu_color_type_t_CEF_MENU_COLOR_BACKGROUND_HOVERED: cef_menu_color_type_t = 5;
pub const cef_menu_color_type_t_CEF_MENU_COLOR_COUNT: cef_menu_color_type_t = 6;
#[doc = "\n Supported color types for menu items.\n"]
pub type cef_menu_color_type_t = i32;
#[doc = " Unknown SSL version."]
pub const cef_ssl_version_t_SSL_CONNECTION_VERSION_UNKNOWN: cef_ssl_version_t = 0;
pub const cef_ssl_version_t_SSL_CONNECTION_VERSION_SSL2: cef_ssl_version_t = 1;
pub const cef_ssl_version_t_SSL_CONNECTION_VERSION_SSL3: cef_ssl_version_t = 2;
pub const cef_ssl_version_t_SSL_CONNECTION_VERSION_TLS1: cef_ssl_version_t = 3;
pub const cef_ssl_version_t_SSL_CONNECTION_VERSION_TLS1_1: cef_ssl_version_t = 4;
pub const cef_ssl_version_t_SSL_CONNECTION_VERSION_TLS1_2: cef_ssl_version_t = 5;
pub const cef_ssl_version_t_SSL_CONNECTION_VERSION_TLS1_3: cef_ssl_version_t = 6;
pub const cef_ssl_version_t_SSL_CONNECTION_VERSION_QUIC: cef_ssl_version_t = 7;
#[doc = " Supported SSL version values. See net/ssl/ssl_connection_status_flags.h\n for more information."]
pub type cef_ssl_version_t = i32;
pub const cef_ssl_content_status_t_SSL_CONTENT_NORMAL_CONTENT: cef_ssl_content_status_t = 0;
pub const cef_ssl_content_status_t_SSL_CONTENT_DISPLAYED_INSECURE_CONTENT:
    cef_ssl_content_status_t = 1;
pub const cef_ssl_content_status_t_SSL_CONTENT_RAN_INSECURE_CONTENT: cef_ssl_content_status_t = 2;
#[doc = " Supported SSL content status flags. See content/public/common/ssl_status.h\n for more information."]
pub type cef_ssl_content_status_t = i32;
pub const cef_scheme_options_t_CEF_SCHEME_OPTION_NONE: cef_scheme_options_t = 0;
#[doc = "\n If CEF_SCHEME_OPTION_STANDARD is set the scheme will be treated as a\n standard scheme. Standard schemes are subject to URL canonicalization and\n parsing rules as defined in the Common Internet Scheme Syntax RFC 1738\n Section 3.1 available at http://www.ietf.org/rfc/rfc1738.txt\n\n In particular, the syntax for standard scheme URLs must be of the form:\n <pre>\n  [scheme]://[username]:[password]@[host]:[port]/[url-path]\n </pre> Standard scheme URLs must have a host component that is a fully\n qualified domain name as defined in Section 3.5 of RFC 1034 [13] and\n Section 2.1 of RFC 1123. These URLs will be canonicalized to\n \"scheme://host/path\" in the simplest case and\n \"scheme://username:password@host:port/path\" in the most explicit case. For\n example, \"scheme:host/path\" and \"scheme:///host/path\" will both be\n canonicalized to \"scheme://host/path\". The origin of a standard scheme URL\n is the combination of scheme, host and port (i.e., \"scheme://host:port\" in\n the most explicit case).\n\n For non-standard scheme URLs only the \"scheme:\" component is parsed and\n canonicalized. The remainder of the URL will be passed to the handler as-\n is. For example, \"scheme:///some%20text\" will remain the same. Non-standard\n scheme URLs cannot be used as a target for form submission.\n"]
pub const cef_scheme_options_t_CEF_SCHEME_OPTION_STANDARD: cef_scheme_options_t = 1;
#[doc = "\n If CEF_SCHEME_OPTION_LOCAL is set the scheme will be treated with the same\n security rules as those applied to \"file\" URLs. Normal pages cannot link to\n or access local URLs. Also, by default, local URLs can only perform\n XMLHttpRequest calls to the same URL (origin + path) that originated the\n request. To allow XMLHttpRequest calls from a local URL to other URLs with\n the same origin set the CefSettings.file_access_from_file_urls_allowed\n value to true (1). To allow XMLHttpRequest calls from a local URL to all\n origins set the CefSettings.universal_access_from_file_urls_allowed value\n to true (1).\n"]
pub const cef_scheme_options_t_CEF_SCHEME_OPTION_LOCAL: cef_scheme_options_t = 2;
#[doc = "\n If CEF_SCHEME_OPTION_DISPLAY_ISOLATED is set the scheme can only be\n displayed from other content hosted with the same scheme. For example,\n pages in other origins cannot create iframes or hyperlinks to URLs with the\n scheme. For schemes that must be accessible from other schemes don't set\n this, set CEF_SCHEME_OPTION_CORS_ENABLED, and use CORS\n \"Access-Control-Allow-Origin\" headers to further restrict access.\n"]
pub const cef_scheme_options_t_CEF_SCHEME_OPTION_DISPLAY_ISOLATED: cef_scheme_options_t = 4;
#[doc = "\n If CEF_SCHEME_OPTION_SECURE is set the scheme will be treated with the same\n security rules as those applied to \"https\" URLs. For example, loading this\n scheme from other secure schemes will not trigger mixed content warnings.\n"]
pub const cef_scheme_options_t_CEF_SCHEME_OPTION_SECURE: cef_scheme_options_t = 8;
#[doc = "\n If CEF_SCHEME_OPTION_CORS_ENABLED is set the scheme can be sent CORS\n requests. This value should be set in most cases where\n CEF_SCHEME_OPTION_STANDARD is set.\n"]
pub const cef_scheme_options_t_CEF_SCHEME_OPTION_CORS_ENABLED: cef_scheme_options_t = 16;
#[doc = "\n If CEF_SCHEME_OPTION_CSP_BYPASSING is set the scheme can bypass Content-\n Security-Policy (CSP) checks. This value should not be set in most cases\n where CEF_SCHEME_OPTION_STANDARD is set.\n"]
pub const cef_scheme_options_t_CEF_SCHEME_OPTION_CSP_BYPASSING: cef_scheme_options_t = 32;
#[doc = "\n If CEF_SCHEME_OPTION_FETCH_ENABLED is set the scheme can perform Fetch API\n requests.\n"]
pub const cef_scheme_options_t_CEF_SCHEME_OPTION_FETCH_ENABLED: cef_scheme_options_t = 64;
#[doc = "\n Configuration options for registering a custom scheme.\n These values are used when calling AddCustomScheme.\n"]
pub type cef_scheme_options_t = i32;
#[doc = "\n No error. Registration completed successfully.\n"]
pub const cef_cdm_registration_error_t_CEF_CDM_REGISTRATION_ERROR_NONE:
    cef_cdm_registration_error_t = 0;
#[doc = "\n Required files or manifest contents are missing.\n"]
pub const cef_cdm_registration_error_t_CEF_CDM_REGISTRATION_ERROR_INCORRECT_CONTENTS:
    cef_cdm_registration_error_t = 1;
#[doc = "\n The CDM is incompatible with the current Chromium version.\n"]
pub const cef_cdm_registration_error_t_CEF_CDM_REGISTRATION_ERROR_INCOMPATIBLE:
    cef_cdm_registration_error_t = 2;
#[doc = "\n CDM registration is not supported at this time.\n"]
pub const cef_cdm_registration_error_t_CEF_CDM_REGISTRATION_ERROR_NOT_SUPPORTED:
    cef_cdm_registration_error_t = 3;
#[doc = "\n Error codes for CDM registration. See cef_web_plugin.h for details.\n"]
pub type cef_cdm_registration_error_t = i32;
pub const cef_composition_underline_style_t_CEF_CUS_SOLID: cef_composition_underline_style_t = 0;
pub const cef_composition_underline_style_t_CEF_CUS_DOT: cef_composition_underline_style_t = 1;
pub const cef_composition_underline_style_t_CEF_CUS_DASH: cef_composition_underline_style_t = 2;
pub const cef_composition_underline_style_t_CEF_CUS_NONE: cef_composition_underline_style_t = 3;
#[doc = "\n Composition underline style.\n"]
pub type cef_composition_underline_style_t = i32;
#[doc = "\n Structure representing IME composition underline information. This is a thin\n wrapper around Blink's WebCompositionUnderline class and should be kept in\n sync with that.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_composition_underline_t {
    #[doc = "\n Underline character range.\n"]
    pub range: cef_range_t,
    #[doc = "\n Text color.\n"]
    pub color: cef_color_t,
    #[doc = "\n Background color.\n"]
    pub background_color: cef_color_t,
    #[doc = "\n Set to true (1) for thick underline.\n"]
    pub thick: ::core::ffi::c_int,
    #[doc = "\n Style.\n"]
    pub style: cef_composition_underline_style_t,
}
#[test]
fn bindgen_test_layout__cef_composition_underline_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_composition_underline_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_composition_underline_t>(),
        24usize,
        concat!("Size of: ", stringify!(_cef_composition_underline_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_composition_underline_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_cef_composition_underline_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).range) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_composition_underline_t),
            "::",
            stringify!(range)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).color) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_composition_underline_t),
            "::",
            stringify!(color)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).background_color) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_composition_underline_t),
            "::",
            stringify!(background_color)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).thick) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_composition_underline_t),
            "::",
            stringify!(thick)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).style) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_composition_underline_t),
            "::",
            stringify!(style)
        )
    );
}
#[doc = "\n Structure representing IME composition underline information. This is a thin\n wrapper around Blink's WebCompositionUnderline class and should be kept in\n sync with that.\n"]
pub type cef_composition_underline_t = _cef_composition_underline_t;
pub const cef_channel_layout_t_CEF_CHANNEL_LAYOUT_NONE: cef_channel_layout_t = 0;
pub const cef_channel_layout_t_CEF_CHANNEL_LAYOUT_UNSUPPORTED: cef_channel_layout_t = 1;
#[doc = " Front C"]
pub const cef_channel_layout_t_CEF_CHANNEL_LAYOUT_MONO: cef_channel_layout_t = 2;
#[doc = " Front L, Front R"]
pub const cef_channel_layout_t_CEF_CHANNEL_LAYOUT_STEREO: cef_channel_layout_t = 3;
#[doc = " Front L, Front R, Back C"]
pub const cef_channel_layout_t_CEF_CHANNEL_LAYOUT_2_1: cef_channel_layout_t = 4;
#[doc = " Front L, Front R, Front C"]
pub const cef_channel_layout_t_CEF_CHANNEL_LAYOUT_SURROUND: cef_channel_layout_t = 5;
#[doc = " Front L, Front R, Front C, Back C"]
pub const cef_channel_layout_t_CEF_CHANNEL_LAYOUT_4_0: cef_channel_layout_t = 6;
#[doc = " Front L, Front R, Side L, Side R"]
pub const cef_channel_layout_t_CEF_CHANNEL_LAYOUT_2_2: cef_channel_layout_t = 7;
#[doc = " Front L, Front R, Back L, Back R"]
pub const cef_channel_layout_t_CEF_CHANNEL_LAYOUT_QUAD: cef_channel_layout_t = 8;
#[doc = " Front L, Front R, Front C, Side L, Side R"]
pub const cef_channel_layout_t_CEF_CHANNEL_LAYOUT_5_0: cef_channel_layout_t = 9;
#[doc = " Front L, Front R, Front C, LFE, Side L, Side R"]
pub const cef_channel_layout_t_CEF_CHANNEL_LAYOUT_5_1: cef_channel_layout_t = 10;
#[doc = " Front L, Front R, Front C, Back L, Back R"]
pub const cef_channel_layout_t_CEF_CHANNEL_LAYOUT_5_0_BACK: cef_channel_layout_t = 11;
#[doc = " Front L, Front R, Front C, LFE, Back L, Back R"]
pub const cef_channel_layout_t_CEF_CHANNEL_LAYOUT_5_1_BACK: cef_channel_layout_t = 12;
#[doc = " Front L, Front R, Front C, Side L, Side R, Back L, Back R"]
pub const cef_channel_layout_t_CEF_CHANNEL_LAYOUT_7_0: cef_channel_layout_t = 13;
#[doc = " Front L, Front R, Front C, LFE, Side L, Side R, Back L, Back R"]
pub const cef_channel_layout_t_CEF_CHANNEL_LAYOUT_7_1: cef_channel_layout_t = 14;
#[doc = " Front L, Front R, Front C, LFE, Side L, Side R, Front LofC, Front RofC"]
pub const cef_channel_layout_t_CEF_CHANNEL_LAYOUT_7_1_WIDE: cef_channel_layout_t = 15;
#[doc = " Stereo L, Stereo R"]
pub const cef_channel_layout_t_CEF_CHANNEL_LAYOUT_STEREO_DOWNMIX: cef_channel_layout_t = 16;
#[doc = " Stereo L, Stereo R, LFE"]
pub const cef_channel_layout_t_CEF_CHANNEL_LAYOUT_2POINT1: cef_channel_layout_t = 17;
#[doc = " Stereo L, Stereo R, Front C, LFE"]
pub const cef_channel_layout_t_CEF_CHANNEL_LAYOUT_3_1: cef_channel_layout_t = 18;
#[doc = " Stereo L, Stereo R, Front C, Rear C, LFE"]
pub const cef_channel_layout_t_CEF_CHANNEL_LAYOUT_4_1: cef_channel_layout_t = 19;
#[doc = " Stereo L, Stereo R, Front C, Side L, Side R, Back C"]
pub const cef_channel_layout_t_CEF_CHANNEL_LAYOUT_6_0: cef_channel_layout_t = 20;
#[doc = " Stereo L, Stereo R, Side L, Side R, Front LofC, Front RofC"]
pub const cef_channel_layout_t_CEF_CHANNEL_LAYOUT_6_0_FRONT: cef_channel_layout_t = 21;
#[doc = " Stereo L, Stereo R, Front C, Rear L, Rear R, Rear C"]
pub const cef_channel_layout_t_CEF_CHANNEL_LAYOUT_HEXAGONAL: cef_channel_layout_t = 22;
#[doc = " Stereo L, Stereo R, Front C, LFE, Side L, Side R, Rear Center"]
pub const cef_channel_layout_t_CEF_CHANNEL_LAYOUT_6_1: cef_channel_layout_t = 23;
#[doc = " Stereo L, Stereo R, Front C, LFE, Back L, Back R, Rear Center"]
pub const cef_channel_layout_t_CEF_CHANNEL_LAYOUT_6_1_BACK: cef_channel_layout_t = 24;
#[doc = " Stereo L, Stereo R, Side L, Side R, Front LofC, Front RofC, LFE"]
pub const cef_channel_layout_t_CEF_CHANNEL_LAYOUT_6_1_FRONT: cef_channel_layout_t = 25;
#[doc = " Front L, Front R, Front C, Side L, Side R, Front LofC, Front RofC"]
pub const cef_channel_layout_t_CEF_CHANNEL_LAYOUT_7_0_FRONT: cef_channel_layout_t = 26;
#[doc = " Front L, Front R, Front C, LFE, Back L, Back R, Front LofC, Front RofC"]
pub const cef_channel_layout_t_CEF_CHANNEL_LAYOUT_7_1_WIDE_BACK: cef_channel_layout_t = 27;
#[doc = " Front L, Front R, Front C, Side L, Side R, Rear L, Back R, Back C."]
pub const cef_channel_layout_t_CEF_CHANNEL_LAYOUT_OCTAGONAL: cef_channel_layout_t = 28;
#[doc = " Channels are not explicitly mapped to speakers."]
pub const cef_channel_layout_t_CEF_CHANNEL_LAYOUT_DISCRETE: cef_channel_layout_t = 29;
#[doc = " Front L, Front R, Front C. Front C contains the keyboard mic audio. This\n layout is only intended for input for WebRTC. The Front C channel\n is stripped away in the WebRTC audio input pipeline and never seen outside\n of that."]
pub const cef_channel_layout_t_CEF_CHANNEL_LAYOUT_STEREO_AND_KEYBOARD_MIC: cef_channel_layout_t =
    30;
#[doc = " Front L, Front R, Side L, Side R, LFE"]
pub const cef_channel_layout_t_CEF_CHANNEL_LAYOUT_4_1_QUAD_SIDE: cef_channel_layout_t = 31;
#[doc = " Actual channel layout is specified in the bitstream and the actual channel\n count is unknown at Chromium media pipeline level (useful for audio\n pass-through mode)."]
pub const cef_channel_layout_t_CEF_CHANNEL_LAYOUT_BITSTREAM: cef_channel_layout_t = 32;
#[doc = " Max value, must always equal the largest entry ever logged."]
pub const cef_channel_layout_t_CEF_CHANNEL_LAYOUT_MAX: cef_channel_layout_t = 32;
#[doc = "\n Enumerates the various representations of the ordering of audio channels.\n Must be kept synchronized with media::ChannelLayout from Chromium.\n See media\\base\\channel_layout.h\n"]
pub type cef_channel_layout_t = i32;
#[doc = "\n Structure representing the audio parameters for setting up the audio handler.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_audio_parameters_t {
    #[doc = "\n Layout of the audio channels\n"]
    pub channel_layout: cef_channel_layout_t,
    #[doc = "\n Sample rate\n"]
    pub sample_rate: ::core::ffi::c_int,
    #[doc = "\n Number of frames per buffer\n"]
    pub frames_per_buffer: ::core::ffi::c_int,
}
#[test]
fn bindgen_test_layout__cef_audio_parameters_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_audio_parameters_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_audio_parameters_t>(),
        12usize,
        concat!("Size of: ", stringify!(_cef_audio_parameters_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_audio_parameters_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_cef_audio_parameters_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).channel_layout) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_audio_parameters_t),
            "::",
            stringify!(channel_layout)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sample_rate) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_audio_parameters_t),
            "::",
            stringify!(sample_rate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frames_per_buffer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_audio_parameters_t),
            "::",
            stringify!(frames_per_buffer)
        )
    );
}
#[doc = "\n Structure representing the audio parameters for setting up the audio handler.\n"]
pub type cef_audio_parameters_t = _cef_audio_parameters_t;
pub const cef_media_route_create_result_t_CEF_MRCR_UNKNOWN_ERROR: cef_media_route_create_result_t =
    0;
pub const cef_media_route_create_result_t_CEF_MRCR_OK: cef_media_route_create_result_t = 1;
pub const cef_media_route_create_result_t_CEF_MRCR_TIMED_OUT: cef_media_route_create_result_t = 2;
pub const cef_media_route_create_result_t_CEF_MRCR_ROUTE_NOT_FOUND:
    cef_media_route_create_result_t = 3;
pub const cef_media_route_create_result_t_CEF_MRCR_SINK_NOT_FOUND: cef_media_route_create_result_t =
    4;
pub const cef_media_route_create_result_t_CEF_MRCR_INVALID_ORIGIN: cef_media_route_create_result_t =
    5;
pub const cef_media_route_create_result_t_CEF_MRCR_NO_SUPPORTED_PROVIDER:
    cef_media_route_create_result_t = 7;
pub const cef_media_route_create_result_t_CEF_MRCR_CANCELLED: cef_media_route_create_result_t = 8;
pub const cef_media_route_create_result_t_CEF_MRCR_ROUTE_ALREADY_EXISTS:
    cef_media_route_create_result_t = 9;
pub const cef_media_route_create_result_t_CEF_MRCR_ROUTE_ALREADY_TERMINATED:
    cef_media_route_create_result_t = 11;
#[doc = " The total number of values."]
pub const cef_media_route_create_result_t_CEF_MRCR_TOTAL_COUNT: cef_media_route_create_result_t =
    12;
#[doc = "\n Result codes for CefMediaRouter::CreateRoute. Should be kept in sync with\n Chromium's media_router::RouteRequestResult::ResultCode type.\n"]
pub type cef_media_route_create_result_t = i32;
pub const cef_media_route_connection_state_t_CEF_MRCS_UNKNOWN: cef_media_route_connection_state_t =
    0;
pub const cef_media_route_connection_state_t_CEF_MRCS_CONNECTING:
    cef_media_route_connection_state_t = 1;
pub const cef_media_route_connection_state_t_CEF_MRCS_CONNECTED:
    cef_media_route_connection_state_t = 2;
pub const cef_media_route_connection_state_t_CEF_MRCS_CLOSED: cef_media_route_connection_state_t =
    3;
pub const cef_media_route_connection_state_t_CEF_MRCS_TERMINATED:
    cef_media_route_connection_state_t = 4;
#[doc = "\n Connection state for a MediaRoute object.\n"]
pub type cef_media_route_connection_state_t = i32;
pub const cef_media_sink_icon_type_t_CEF_MSIT_CAST: cef_media_sink_icon_type_t = 0;
pub const cef_media_sink_icon_type_t_CEF_MSIT_CAST_AUDIO_GROUP: cef_media_sink_icon_type_t = 1;
pub const cef_media_sink_icon_type_t_CEF_MSIT_CAST_AUDIO: cef_media_sink_icon_type_t = 2;
pub const cef_media_sink_icon_type_t_CEF_MSIT_MEETING: cef_media_sink_icon_type_t = 3;
pub const cef_media_sink_icon_type_t_CEF_MSIT_HANGOUT: cef_media_sink_icon_type_t = 4;
pub const cef_media_sink_icon_type_t_CEF_MSIT_EDUCATION: cef_media_sink_icon_type_t = 5;
pub const cef_media_sink_icon_type_t_CEF_MSIT_WIRED_DISPLAY: cef_media_sink_icon_type_t = 6;
pub const cef_media_sink_icon_type_t_CEF_MSIT_GENERIC: cef_media_sink_icon_type_t = 7;
#[doc = " The total number of values."]
pub const cef_media_sink_icon_type_t_CEF_MSIT_TOTAL_COUNT: cef_media_sink_icon_type_t = 8;
#[doc = "\n Icon types for a MediaSink object. Should be kept in sync with Chromium's\n media_router::SinkIconType type.\n"]
pub type cef_media_sink_icon_type_t = i32;
#[doc = "\n Device information for a MediaSink object.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_media_sink_device_info_t {
    pub ip_address: cef_string_t,
    pub port: ::core::ffi::c_int,
    pub model_name: cef_string_t,
}
#[test]
fn bindgen_test_layout__cef_media_sink_device_info_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_media_sink_device_info_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_media_sink_device_info_t>(),
        56usize,
        concat!("Size of: ", stringify!(_cef_media_sink_device_info_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_media_sink_device_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_media_sink_device_info_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ip_address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_media_sink_device_info_t),
            "::",
            stringify!(ip_address)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_media_sink_device_info_t),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).model_name) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_media_sink_device_info_t),
            "::",
            stringify!(model_name)
        )
    );
}
#[doc = "\n Device information for a MediaSink object.\n"]
pub type cef_media_sink_device_info_t = _cef_media_sink_device_info_t;
pub const cef_text_field_commands_t_CEF_TFC_CUT: cef_text_field_commands_t = 1;
pub const cef_text_field_commands_t_CEF_TFC_COPY: cef_text_field_commands_t = 2;
pub const cef_text_field_commands_t_CEF_TFC_PASTE: cef_text_field_commands_t = 3;
pub const cef_text_field_commands_t_CEF_TFC_UNDO: cef_text_field_commands_t = 4;
pub const cef_text_field_commands_t_CEF_TFC_DELETE: cef_text_field_commands_t = 5;
pub const cef_text_field_commands_t_CEF_TFC_SELECT_ALL: cef_text_field_commands_t = 6;
#[doc = "\n Represents commands available to TextField.\n"]
pub type cef_text_field_commands_t = i32;
pub const cef_chrome_toolbar_type_t_CEF_CTT_NONE: cef_chrome_toolbar_type_t = 1;
pub const cef_chrome_toolbar_type_t_CEF_CTT_NORMAL: cef_chrome_toolbar_type_t = 2;
pub const cef_chrome_toolbar_type_t_CEF_CTT_LOCATION: cef_chrome_toolbar_type_t = 3;
#[doc = "\n Supported Chrome toolbar types.\n"]
pub type cef_chrome_toolbar_type_t = i32;
#[doc = "\n All ref-counted framework structures must include this structure first.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_base_ref_counted_t {
    #[doc = "\n Size of the data structure.\n"]
    pub size: usize,
    #[doc = "\n Called to increment the reference count for the object. Should be called\n for every new copy of a pointer to a given object.\n"]
    pub add_ref: ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_base_ref_counted_t)>,
    #[doc = "\n Called to decrement the reference count for the object. If the reference\n count falls to 0 the object should self-delete. Returns true (1) if the\n resulting reference count is 0.\n"]
    pub release: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_base_ref_counted_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if the current reference count is 1.\n"]
    pub has_one_ref: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_base_ref_counted_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if the current reference count is at least 1.\n"]
    pub has_at_least_one_ref: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_base_ref_counted_t) -> ::core::ffi::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_base_ref_counted_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_base_ref_counted_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_base_ref_counted_t>(),
        40usize,
        concat!("Size of: ", stringify!(_cef_base_ref_counted_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_base_ref_counted_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_base_ref_counted_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_base_ref_counted_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).add_ref) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_base_ref_counted_t),
            "::",
            stringify!(add_ref)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_base_ref_counted_t),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_one_ref) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_base_ref_counted_t),
            "::",
            stringify!(has_one_ref)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_at_least_one_ref) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_base_ref_counted_t),
            "::",
            stringify!(has_at_least_one_ref)
        )
    );
}
#[doc = "\n All ref-counted framework structures must include this structure first.\n"]
pub type cef_base_ref_counted_t = _cef_base_ref_counted_t;
#[doc = "\n All scoped framework structures must include this structure first.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_base_scoped_t {
    #[doc = "\n Size of the data structure.\n"]
    pub size: usize,
    #[doc = "\n Called to delete this object. May be NULL if the object is not owned.\n"]
    pub del: ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_base_scoped_t)>,
}
#[test]
fn bindgen_test_layout__cef_base_scoped_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_base_scoped_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_base_scoped_t>(),
        16usize,
        concat!("Size of: ", stringify!(_cef_base_scoped_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_base_scoped_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_base_scoped_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_base_scoped_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).del) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_base_scoped_t),
            "::",
            stringify!(del)
        )
    );
}
#[doc = "\n All scoped framework structures must include this structure first.\n"]
pub type cef_base_scoped_t = _cef_base_scoped_t;
#[doc = "\n Structure that wraps other data value types. Complex types (binary,\n dictionary and list) will be referenced but not owned by this object. Can be\n used on any process and thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_value_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Returns true (1) if the underlying data is valid. This will always be true\n (1) for simple types. For complex types (binary, dictionary and list) the\n underlying data may become invalid if owned by another object (e.g. list or\n dictionary) and that other object is then modified or destroyed. This value\n object can be re-used by calling Set*() even if the underlying data is\n invalid.\n"]
    pub is_valid: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_value_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if the underlying data is owned by another object.\n"]
    pub is_owned: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_value_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if the underlying data is read-only. Some APIs may expose\n read-only objects.\n"]
    pub is_read_only: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_value_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if this object and |that| object have the same underlying\n data. If true (1) modifications to this object will also affect |that|\n object and vice-versa.\n"]
    pub is_same: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_value_t,
            that: *mut _cef_value_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if this object and |that| object have an equivalent\n underlying value but are not necessarily the same object.\n"]
    pub is_equal: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_value_t,
            that: *mut _cef_value_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns a copy of this object. The underlying data will also be copied.\n"]
    pub copy:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_value_t) -> *mut _cef_value_t>,
    #[doc = "\n Returns the underlying value type.\n"]
    pub get_type:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_value_t) -> cef_value_type_t>,
    #[doc = "\n Returns the underlying value as type bool.\n"]
    pub get_bool: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_value_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the underlying value as type int.\n"]
    pub get_int: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_value_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the underlying value as type double.\n"]
    pub get_double: ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_value_t) -> f64>,
    #[doc = "\n Returns the underlying value as type string.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_string: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_value_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the underlying value as type binary. The returned reference may\n become invalid if the value is owned by another object or if ownership is\n transferred to another object in the future. To maintain a reference to the\n value after assigning ownership to a dictionary or list pass this object to\n the set_value() function instead of passing the returned reference to\n set_binary().\n"]
    pub get_binary: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_value_t) -> *mut _cef_binary_value_t,
    >,
    #[doc = "\n Returns the underlying value as type dictionary. The returned reference may\n become invalid if the value is owned by another object or if ownership is\n transferred to another object in the future. To maintain a reference to the\n value after assigning ownership to a dictionary or list pass this object to\n the set_value() function instead of passing the returned reference to\n set_dictionary().\n"]
    pub get_dictionary: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_value_t) -> *mut _cef_dictionary_value_t,
    >,
    #[doc = "\n Returns the underlying value as type list. The returned reference may\n become invalid if the value is owned by another object or if ownership is\n transferred to another object in the future. To maintain a reference to the\n value after assigning ownership to a dictionary or list pass this object to\n the set_value() function instead of passing the returned reference to\n set_list().\n"]
    pub get_list: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_value_t) -> *mut _cef_list_value_t,
    >,
    #[doc = "\n Sets the underlying value as type null. Returns true (1) if the value was\n set successfully.\n"]
    pub set_null: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_value_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Sets the underlying value as type bool. Returns true (1) if the value was\n set successfully.\n"]
    pub set_bool: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_value_t,
            value: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Sets the underlying value as type int. Returns true (1) if the value was\n set successfully.\n"]
    pub set_int: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_value_t,
            value: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Sets the underlying value as type double. Returns true (1) if the value was\n set successfully.\n"]
    pub set_double: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_value_t, value: f64) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Sets the underlying value as type string. Returns true (1) if the value was\n set successfully.\n"]
    pub set_string: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_value_t,
            value: *const cef_string_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Sets the underlying value as type binary. Returns true (1) if the value was\n set successfully. This object keeps a reference to |value| and ownership of\n the underlying data remains unchanged.\n"]
    pub set_binary: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_value_t,
            value: *mut _cef_binary_value_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Sets the underlying value as type dict. Returns true (1) if the value was\n set successfully. This object keeps a reference to |value| and ownership of\n the underlying data remains unchanged.\n"]
    pub set_dictionary: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_value_t,
            value: *mut _cef_dictionary_value_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Sets the underlying value as type list. Returns true (1) if the value was\n set successfully. This object keeps a reference to |value| and ownership of\n the underlying data remains unchanged.\n"]
    pub set_list: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_value_t,
            value: *mut _cef_list_value_t,
        ) -> ::core::ffi::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_value_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_value_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_value_t>(),
        216usize,
        concat!("Size of: ", stringify!(_cef_value_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_value_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_value_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_value_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_valid) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_value_t),
            "::",
            stringify!(is_valid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_owned) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_value_t),
            "::",
            stringify!(is_owned)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_read_only) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_value_t),
            "::",
            stringify!(is_read_only)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_same) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_value_t),
            "::",
            stringify!(is_same)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_equal) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_value_t),
            "::",
            stringify!(is_equal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).copy) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_value_t),
            "::",
            stringify!(copy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_type) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_value_t),
            "::",
            stringify!(get_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_bool) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_value_t),
            "::",
            stringify!(get_bool)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_int) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_value_t),
            "::",
            stringify!(get_int)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_double) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_value_t),
            "::",
            stringify!(get_double)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_string) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_value_t),
            "::",
            stringify!(get_string)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_binary) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_value_t),
            "::",
            stringify!(get_binary)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_dictionary) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_value_t),
            "::",
            stringify!(get_dictionary)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_list) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_value_t),
            "::",
            stringify!(get_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_null) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_value_t),
            "::",
            stringify!(set_null)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_bool) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_value_t),
            "::",
            stringify!(set_bool)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_int) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_value_t),
            "::",
            stringify!(set_int)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_double) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_value_t),
            "::",
            stringify!(set_double)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_string) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_value_t),
            "::",
            stringify!(set_string)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_binary) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_value_t),
            "::",
            stringify!(set_binary)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_dictionary) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_value_t),
            "::",
            stringify!(set_dictionary)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_list) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_value_t),
            "::",
            stringify!(set_list)
        )
    );
}
#[doc = "\n Structure that wraps other data value types. Complex types (binary,\n dictionary and list) will be referenced but not owned by this object. Can be\n used on any process and thread.\n"]
pub type cef_value_t = _cef_value_t;
#[doc = "\n Structure representing a binary value. Can be used on any process and thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_binary_value_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Returns true (1) if this object is valid. This object may become invalid if\n the underlying data is owned by another object (e.g. list or dictionary)\n and that other object is then modified or destroyed. Do not call any other\n functions if this function returns false (0).\n"]
    pub is_valid: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_binary_value_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if this object is currently owned by another object.\n"]
    pub is_owned: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_binary_value_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if this object and |that| object have the same underlying\n data.\n"]
    pub is_same: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_binary_value_t,
            that: *mut _cef_binary_value_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if this object and |that| object have an equivalent\n underlying value but are not necessarily the same object.\n"]
    pub is_equal: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_binary_value_t,
            that: *mut _cef_binary_value_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns a copy of this object. The data in this object will also be copied.\n"]
    pub copy: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_binary_value_t) -> *mut _cef_binary_value_t,
    >,
    #[doc = "\n Returns the data size.\n"]
    pub get_size:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_binary_value_t) -> usize>,
    #[doc = "\n Read up to |buffer_size| number of bytes into |buffer|. Reading begins at\n the specified byte |data_offset|. Returns the number of bytes read.\n"]
    pub get_data: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_binary_value_t,
            buffer: *mut ::core::ffi::c_void,
            buffer_size: usize,
            data_offset: usize,
        ) -> usize,
    >,
}
#[test]
fn bindgen_test_layout__cef_binary_value_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_binary_value_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_binary_value_t>(),
        96usize,
        concat!("Size of: ", stringify!(_cef_binary_value_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_binary_value_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_binary_value_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_binary_value_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_valid) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_binary_value_t),
            "::",
            stringify!(is_valid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_owned) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_binary_value_t),
            "::",
            stringify!(is_owned)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_same) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_binary_value_t),
            "::",
            stringify!(is_same)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_equal) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_binary_value_t),
            "::",
            stringify!(is_equal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).copy) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_binary_value_t),
            "::",
            stringify!(copy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_size) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_binary_value_t),
            "::",
            stringify!(get_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_data) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_binary_value_t),
            "::",
            stringify!(get_data)
        )
    );
}
#[doc = "\n Structure representing a binary value. Can be used on any process and thread.\n"]
pub type cef_binary_value_t = _cef_binary_value_t;
#[doc = "\n Structure representing a dictionary value. Can be used on any process and\n thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_dictionary_value_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Returns true (1) if this object is valid. This object may become invalid if\n the underlying data is owned by another object (e.g. list or dictionary)\n and that other object is then modified or destroyed. Do not call any other\n functions if this function returns false (0).\n"]
    pub is_valid: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_dictionary_value_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if this object is currently owned by another object.\n"]
    pub is_owned: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_dictionary_value_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if the values of this object are read-only. Some APIs may\n expose read-only objects.\n"]
    pub is_read_only: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_dictionary_value_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if this object and |that| object have the same underlying\n data. If true (1) modifications to this object will also affect |that|\n object and vice-versa.\n"]
    pub is_same: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            that: *mut _cef_dictionary_value_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if this object and |that| object have an equivalent\n underlying value but are not necessarily the same object.\n"]
    pub is_equal: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            that: *mut _cef_dictionary_value_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns a writable copy of this object. If |exclude_NULL_children| is true\n (1) any NULL dictionaries or lists will be excluded from the copy.\n"]
    pub copy: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            exclude_empty_children: ::core::ffi::c_int,
        ) -> *mut _cef_dictionary_value_t,
    >,
    #[doc = "\n Returns the number of values.\n"]
    pub get_size:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_dictionary_value_t) -> usize>,
    #[doc = "\n Removes all values. Returns true (1) on success.\n"]
    pub clear: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_dictionary_value_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if the current dictionary has a value for the given key.\n"]
    pub has_key: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Reads all keys for this dictionary into the specified vector.\n"]
    pub get_keys: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            keys: cef_string_list_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Removes the value at the specified key. Returns true (1) is the value was\n removed successfully.\n"]
    pub remove: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the value type for the specified key.\n"]
    pub get_type: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
        ) -> cef_value_type_t,
    >,
    #[doc = "\n Returns the value at the specified key. For simple types the returned value\n will copy existing data and modifications to the value will not modify this\n object. For complex types (binary, dictionary and list) the returned value\n will reference existing data and modifications to the value will modify\n this object.\n"]
    pub get_value: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
        ) -> *mut _cef_value_t,
    >,
    #[doc = "\n Returns the value at the specified key as type bool.\n"]
    pub get_bool: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the value at the specified key as type int.\n"]
    pub get_int: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the value at the specified key as type double.\n"]
    pub get_double: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_dictionary_value_t, key: *const cef_string_t) -> f64,
    >,
    #[doc = "\n Returns the value at the specified key as type string.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_string: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
        ) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the value at the specified key as type binary. The returned value\n will reference existing data.\n"]
    pub get_binary: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
        ) -> *mut _cef_binary_value_t,
    >,
    #[doc = "\n Returns the value at the specified key as type dictionary. The returned\n value will reference existing data and modifications to the value will\n modify this object.\n"]
    pub get_dictionary: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
        ) -> *mut _cef_dictionary_value_t,
    >,
    #[doc = "\n Returns the value at the specified key as type list. The returned value\n will reference existing data and modifications to the value will modify\n this object.\n"]
    pub get_list: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
        ) -> *mut _cef_list_value_t,
    >,
    #[doc = "\n Sets the value at the specified key. Returns true (1) if the value was set\n successfully. If |value| represents simple data then the underlying data\n will be copied and modifications to |value| will not modify this object. If\n |value| represents complex data (binary, dictionary or list) then the\n underlying data will be referenced and modifications to |value| will modify\n this object.\n"]
    pub set_value: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
            value: *mut _cef_value_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Sets the value at the specified key as type null. Returns true (1) if the\n value was set successfully.\n"]
    pub set_null: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Sets the value at the specified key as type bool. Returns true (1) if the\n value was set successfully.\n"]
    pub set_bool: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
            value: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Sets the value at the specified key as type int. Returns true (1) if the\n value was set successfully.\n"]
    pub set_int: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
            value: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Sets the value at the specified key as type double. Returns true (1) if the\n value was set successfully.\n"]
    pub set_double: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
            value: f64,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Sets the value at the specified key as type string. Returns true (1) if the\n value was set successfully.\n"]
    pub set_string: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
            value: *const cef_string_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Sets the value at the specified key as type binary. Returns true (1) if the\n value was set successfully. If |value| is currently owned by another object\n then the value will be copied and the |value| reference will not change.\n Otherwise, ownership will be transferred to this object and the |value|\n reference will be invalidated.\n"]
    pub set_binary: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
            value: *mut _cef_binary_value_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Sets the value at the specified key as type dict. Returns true (1) if the\n value was set successfully. If |value| is currently owned by another object\n then the value will be copied and the |value| reference will not change.\n Otherwise, ownership will be transferred to this object and the |value|\n reference will be invalidated.\n"]
    pub set_dictionary: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
            value: *mut _cef_dictionary_value_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Sets the value at the specified key as type list. Returns true (1) if the\n value was set successfully. If |value| is currently owned by another object\n then the value will be copied and the |value| reference will not change.\n Otherwise, ownership will be transferred to this object and the |value|\n reference will be invalidated.\n"]
    pub set_list: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
            value: *mut _cef_list_value_t,
        ) -> ::core::ffi::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_dictionary_value_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_dictionary_value_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_dictionary_value_t>(),
        272usize,
        concat!("Size of: ", stringify!(_cef_dictionary_value_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_dictionary_value_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_dictionary_value_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_dictionary_value_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_valid) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_dictionary_value_t),
            "::",
            stringify!(is_valid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_owned) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_dictionary_value_t),
            "::",
            stringify!(is_owned)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_read_only) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_dictionary_value_t),
            "::",
            stringify!(is_read_only)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_same) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_dictionary_value_t),
            "::",
            stringify!(is_same)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_equal) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_dictionary_value_t),
            "::",
            stringify!(is_equal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).copy) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_dictionary_value_t),
            "::",
            stringify!(copy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_size) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_dictionary_value_t),
            "::",
            stringify!(get_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clear) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_dictionary_value_t),
            "::",
            stringify!(clear)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_key) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_dictionary_value_t),
            "::",
            stringify!(has_key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_keys) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_dictionary_value_t),
            "::",
            stringify!(get_keys)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).remove) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_dictionary_value_t),
            "::",
            stringify!(remove)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_type) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_dictionary_value_t),
            "::",
            stringify!(get_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_value) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_dictionary_value_t),
            "::",
            stringify!(get_value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_bool) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_dictionary_value_t),
            "::",
            stringify!(get_bool)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_int) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_dictionary_value_t),
            "::",
            stringify!(get_int)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_double) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_dictionary_value_t),
            "::",
            stringify!(get_double)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_string) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_dictionary_value_t),
            "::",
            stringify!(get_string)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_binary) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_dictionary_value_t),
            "::",
            stringify!(get_binary)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_dictionary) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_dictionary_value_t),
            "::",
            stringify!(get_dictionary)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_list) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_dictionary_value_t),
            "::",
            stringify!(get_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_value) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_dictionary_value_t),
            "::",
            stringify!(set_value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_null) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_dictionary_value_t),
            "::",
            stringify!(set_null)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_bool) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_dictionary_value_t),
            "::",
            stringify!(set_bool)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_int) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_dictionary_value_t),
            "::",
            stringify!(set_int)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_double) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_dictionary_value_t),
            "::",
            stringify!(set_double)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_string) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_dictionary_value_t),
            "::",
            stringify!(set_string)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_binary) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_dictionary_value_t),
            "::",
            stringify!(set_binary)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_dictionary) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_dictionary_value_t),
            "::",
            stringify!(set_dictionary)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_list) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_dictionary_value_t),
            "::",
            stringify!(set_list)
        )
    );
}
#[doc = "\n Structure representing a dictionary value. Can be used on any process and\n thread.\n"]
pub type cef_dictionary_value_t = _cef_dictionary_value_t;
#[doc = "\n Structure representing a list value. Can be used on any process and thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_list_value_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Returns true (1) if this object is valid. This object may become invalid if\n the underlying data is owned by another object (e.g. list or dictionary)\n and that other object is then modified or destroyed. Do not call any other\n functions if this function returns false (0).\n"]
    pub is_valid: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_list_value_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if this object is currently owned by another object.\n"]
    pub is_owned: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_list_value_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if the values of this object are read-only. Some APIs may\n expose read-only objects.\n"]
    pub is_read_only: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_list_value_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if this object and |that| object have the same underlying\n data. If true (1) modifications to this object will also affect |that|\n object and vice-versa.\n"]
    pub is_same: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_list_value_t,
            that: *mut _cef_list_value_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if this object and |that| object have an equivalent\n underlying value but are not necessarily the same object.\n"]
    pub is_equal: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_list_value_t,
            that: *mut _cef_list_value_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns a writable copy of this object.\n"]
    pub copy: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_list_value_t) -> *mut _cef_list_value_t,
    >,
    #[doc = "\n Sets the number of values. If the number of values is expanded all new\n value slots will default to type null. Returns true (1) on success.\n"]
    pub set_size: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_list_value_t, size: usize) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the number of values.\n"]
    pub get_size:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_list_value_t) -> usize>,
    #[doc = "\n Removes all values. Returns true (1) on success.\n"]
    pub clear: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_list_value_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Removes the value at the specified index.\n"]
    pub remove: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_list_value_t, index: usize) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the value type at the specified index.\n"]
    pub get_type: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_list_value_t, index: usize) -> cef_value_type_t,
    >,
    #[doc = "\n Returns the value at the specified index. For simple types the returned\n value will copy existing data and modifications to the value will not\n modify this object. For complex types (binary, dictionary and list) the\n returned value will reference existing data and modifications to the value\n will modify this object.\n"]
    pub get_value: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_list_value_t, index: usize) -> *mut _cef_value_t,
    >,
    #[doc = "\n Returns the value at the specified index as type bool.\n"]
    pub get_bool: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_list_value_t, index: usize) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the value at the specified index as type int.\n"]
    pub get_int: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_list_value_t, index: usize) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the value at the specified index as type double.\n"]
    pub get_double: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_list_value_t, index: usize) -> f64,
    >,
    #[doc = "\n Returns the value at the specified index as type string.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_string: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_list_value_t, index: usize) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the value at the specified index as type binary. The returned value\n will reference existing data.\n"]
    pub get_binary: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_list_value_t,
            index: usize,
        ) -> *mut _cef_binary_value_t,
    >,
    #[doc = "\n Returns the value at the specified index as type dictionary. The returned\n value will reference existing data and modifications to the value will\n modify this object.\n"]
    pub get_dictionary: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_list_value_t,
            index: usize,
        ) -> *mut _cef_dictionary_value_t,
    >,
    #[doc = "\n Returns the value at the specified index as type list. The returned value\n will reference existing data and modifications to the value will modify\n this object.\n"]
    pub get_list: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_list_value_t, index: usize) -> *mut _cef_list_value_t,
    >,
    #[doc = "\n Sets the value at the specified index. Returns true (1) if the value was\n set successfully. If |value| represents simple data then the underlying\n data will be copied and modifications to |value| will not modify this\n object. If |value| represents complex data (binary, dictionary or list)\n then the underlying data will be referenced and modifications to |value|\n will modify this object.\n"]
    pub set_value: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_list_value_t,
            index: usize,
            value: *mut _cef_value_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Sets the value at the specified index as type null. Returns true (1) if the\n value was set successfully.\n"]
    pub set_null: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_list_value_t, index: usize) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Sets the value at the specified index as type bool. Returns true (1) if the\n value was set successfully.\n"]
    pub set_bool: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_list_value_t,
            index: usize,
            value: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Sets the value at the specified index as type int. Returns true (1) if the\n value was set successfully.\n"]
    pub set_int: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_list_value_t,
            index: usize,
            value: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Sets the value at the specified index as type double. Returns true (1) if\n the value was set successfully.\n"]
    pub set_double: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_list_value_t,
            index: usize,
            value: f64,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Sets the value at the specified index as type string. Returns true (1) if\n the value was set successfully.\n"]
    pub set_string: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_list_value_t,
            index: usize,
            value: *const cef_string_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Sets the value at the specified index as type binary. Returns true (1) if\n the value was set successfully. If |value| is currently owned by another\n object then the value will be copied and the |value| reference will not\n change. Otherwise, ownership will be transferred to this object and the\n |value| reference will be invalidated.\n"]
    pub set_binary: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_list_value_t,
            index: usize,
            value: *mut _cef_binary_value_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Sets the value at the specified index as type dict. Returns true (1) if the\n value was set successfully. If |value| is currently owned by another object\n then the value will be copied and the |value| reference will not change.\n Otherwise, ownership will be transferred to this object and the |value|\n reference will be invalidated.\n"]
    pub set_dictionary: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_list_value_t,
            index: usize,
            value: *mut _cef_dictionary_value_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Sets the value at the specified index as type list. Returns true (1) if the\n value was set successfully. If |value| is currently owned by another object\n then the value will be copied and the |value| reference will not change.\n Otherwise, ownership will be transferred to this object and the |value|\n reference will be invalidated.\n"]
    pub set_list: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_list_value_t,
            index: usize,
            value: *mut _cef_list_value_t,
        ) -> ::core::ffi::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_list_value_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_list_value_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_list_value_t>(),
        264usize,
        concat!("Size of: ", stringify!(_cef_list_value_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_list_value_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_list_value_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_list_value_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_valid) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_list_value_t),
            "::",
            stringify!(is_valid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_owned) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_list_value_t),
            "::",
            stringify!(is_owned)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_read_only) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_list_value_t),
            "::",
            stringify!(is_read_only)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_same) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_list_value_t),
            "::",
            stringify!(is_same)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_equal) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_list_value_t),
            "::",
            stringify!(is_equal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).copy) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_list_value_t),
            "::",
            stringify!(copy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_size) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_list_value_t),
            "::",
            stringify!(set_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_size) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_list_value_t),
            "::",
            stringify!(get_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clear) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_list_value_t),
            "::",
            stringify!(clear)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).remove) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_list_value_t),
            "::",
            stringify!(remove)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_type) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_list_value_t),
            "::",
            stringify!(get_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_value) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_list_value_t),
            "::",
            stringify!(get_value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_bool) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_list_value_t),
            "::",
            stringify!(get_bool)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_int) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_list_value_t),
            "::",
            stringify!(get_int)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_double) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_list_value_t),
            "::",
            stringify!(get_double)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_string) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_list_value_t),
            "::",
            stringify!(get_string)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_binary) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_list_value_t),
            "::",
            stringify!(get_binary)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_dictionary) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_list_value_t),
            "::",
            stringify!(get_dictionary)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_list) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_list_value_t),
            "::",
            stringify!(get_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_value) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_list_value_t),
            "::",
            stringify!(set_value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_null) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_list_value_t),
            "::",
            stringify!(set_null)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_bool) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_list_value_t),
            "::",
            stringify!(set_bool)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_int) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_list_value_t),
            "::",
            stringify!(set_int)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_double) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_list_value_t),
            "::",
            stringify!(set_double)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_string) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_list_value_t),
            "::",
            stringify!(set_string)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_binary) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_list_value_t),
            "::",
            stringify!(set_binary)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_dictionary) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_list_value_t),
            "::",
            stringify!(set_dictionary)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_list) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_list_value_t),
            "::",
            stringify!(set_list)
        )
    );
}
#[doc = "\n Structure representing a list value. Can be used on any process and thread.\n"]
pub type cef_list_value_t = _cef_list_value_t;
#[doc = "\n Implement this structure to receive accessibility notification when\n accessibility events have been registered. The functions of this structure\n will be called on the UI thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_accessibility_handler_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Called after renderer process sends accessibility tree changes to the\n browser process.\n"]
    pub on_accessibility_tree_change: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_accessibility_handler_t, value: *mut _cef_value_t),
    >,
    #[doc = "\n Called after renderer process sends accessibility location changes to the\n browser process.\n"]
    pub on_accessibility_location_change: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_accessibility_handler_t, value: *mut _cef_value_t),
    >,
}
#[test]
fn bindgen_test_layout__cef_accessibility_handler_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_accessibility_handler_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_accessibility_handler_t>(),
        56usize,
        concat!("Size of: ", stringify!(_cef_accessibility_handler_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_accessibility_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_accessibility_handler_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_accessibility_handler_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).on_accessibility_tree_change) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_accessibility_handler_t),
            "::",
            stringify!(on_accessibility_tree_change)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).on_accessibility_location_change) as usize - ptr as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_accessibility_handler_t),
            "::",
            stringify!(on_accessibility_location_change)
        )
    );
}
#[doc = "\n Implement this structure to receive accessibility notification when\n accessibility events have been registered. The functions of this structure\n will be called on the UI thread.\n"]
pub type cef_accessibility_handler_t = _cef_accessibility_handler_t;
#[doc = "\n Callback structure for cef_browser_host_t::AddDevToolsMessageObserver. The\n functions of this structure will be called on the browser process UI thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_dev_tools_message_observer_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Method that will be called on receipt of a DevTools protocol message.\n |browser| is the originating browser instance. |message| is a UTF8-encoded\n JSON dictionary representing either a function result or an event.\n |message| is only valid for the scope of this callback and should be copied\n if necessary. Return true (1) if the message was handled or false (0) if\n the message should be further processed and passed to the\n OnDevToolsMethodResult or OnDevToolsEvent functions as appropriate.\n\n Method result dictionaries include an \"id\" (int) value that identifies the\n orginating function call sent from cef_browser_host_t::SendDevToolsMessage,\n and optionally either a \"result\" (dictionary) or \"error\" (dictionary)\n value. The \"error\" dictionary will contain \"code\" (int) and \"message\"\n (string) values. Event dictionaries include a \"function\" (string) value and\n optionally a \"params\" (dictionary) value. See the DevTools protocol\n documentation at https://chromedevtools.github.io/devtools-protocol/ for\n details of supported function calls and the expected \"result\" or \"params\"\n dictionary contents. JSON dictionaries can be parsed using the CefParseJSON\n function if desired, however be aware of performance considerations when\n parsing large messages (some of which may exceed 1MB in size).\n"]
    pub on_dev_tools_message: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dev_tools_message_observer_t,
            browser: *mut _cef_browser_t,
            message: *const ::core::ffi::c_void,
            message_size: usize,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Method that will be called after attempted execution of a DevTools protocol\n function. |browser| is the originating browser instance. |message_id| is\n the \"id\" value that identifies the originating function call message. If\n the function succeeded |success| will be true (1) and |result| will be the\n UTF8-encoded JSON \"result\" dictionary value (which may be NULL). If the\n function failed |success| will be false (0) and |result| will be the\n UTF8-encoded JSON \"error\" dictionary value. |result| is only valid for the\n scope of this callback and should be copied if necessary. See the\n OnDevToolsMessage documentation for additional details on |result|\n contents.\n"]
    pub on_dev_tools_method_result: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dev_tools_message_observer_t,
            browser: *mut _cef_browser_t,
            message_id: ::core::ffi::c_int,
            success: ::core::ffi::c_int,
            result: *const ::core::ffi::c_void,
            result_size: usize,
        ),
    >,
    #[doc = "\n Method that will be called on receipt of a DevTools protocol event.\n |browser| is the originating browser instance. |function| is the \"function\"\n value. |params| is the UTF8-encoded JSON \"params\" dictionary value (which\n may be NULL). |params| is only valid for the scope of this callback and\n should be copied if necessary. See the OnDevToolsMessage documentation for\n additional details on |params| contents.\n"]
    pub on_dev_tools_event: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dev_tools_message_observer_t,
            browser: *mut _cef_browser_t,
            method: *const cef_string_t,
            params: *const ::core::ffi::c_void,
            params_size: usize,
        ),
    >,
    #[doc = "\n Method that will be called when the DevTools agent has attached. |browser|\n is the originating browser instance. This will generally occur in response\n to the first message sent while the agent is detached.\n"]
    pub on_dev_tools_agent_attached: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dev_tools_message_observer_t,
            browser: *mut _cef_browser_t,
        ),
    >,
    #[doc = "\n Method that will be called when the DevTools agent has detached. |browser|\n is the originating browser instance. Any function results that were pending\n before the agent became detached will not be delivered, and any active\n event subscriptions will be canceled.\n"]
    pub on_dev_tools_agent_detached: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dev_tools_message_observer_t,
            browser: *mut _cef_browser_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_dev_tools_message_observer_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_dev_tools_message_observer_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_dev_tools_message_observer_t>(),
        80usize,
        concat!("Size of: ", stringify!(_cef_dev_tools_message_observer_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_dev_tools_message_observer_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_cef_dev_tools_message_observer_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_dev_tools_message_observer_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_dev_tools_message) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_dev_tools_message_observer_t),
            "::",
            stringify!(on_dev_tools_message)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_dev_tools_method_result) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_dev_tools_message_observer_t),
            "::",
            stringify!(on_dev_tools_method_result)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_dev_tools_event) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_dev_tools_message_observer_t),
            "::",
            stringify!(on_dev_tools_event)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).on_dev_tools_agent_attached) as usize - ptr as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_dev_tools_message_observer_t),
            "::",
            stringify!(on_dev_tools_agent_attached)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).on_dev_tools_agent_detached) as usize - ptr as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_dev_tools_message_observer_t),
            "::",
            stringify!(on_dev_tools_agent_detached)
        )
    );
}
#[doc = "\n Callback structure for cef_browser_host_t::AddDevToolsMessageObserver. The\n functions of this structure will be called on the browser process UI thread.\n"]
pub type cef_dev_tools_message_observer_t = _cef_dev_tools_message_observer_t;
#[doc = "\n Container for a single image represented at different scale factors. All\n image representations should be the same size in density independent pixel\n (DIP) units. For example, if the image at scale factor 1.0 is 100x100 pixels\n then the image at scale factor 2.0 should be 200x200 pixels -- both images\n will display with a DIP size of 100x100 units. The functions of this\n structure can be called on any browser process thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_image_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Returns true (1) if this Image is NULL.\n"]
    pub is_empty: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_image_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if this Image and |that| Image share the same underlying\n storage. Will also return true (1) if both images are NULL.\n"]
    pub is_same: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_image_t,
            that: *mut _cef_image_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Add a bitmap image representation for |scale_factor|. Only 32-bit RGBA/BGRA\n formats are supported. |pixel_width| and |pixel_height| are the bitmap\n representation size in pixel coordinates. |pixel_data| is the array of\n pixel data and should be |pixel_width| x |pixel_height| x 4 bytes in size.\n |color_type| and |alpha_type| values specify the pixel format.\n"]
    pub add_bitmap: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_image_t,
            scale_factor: f32,
            pixel_width: ::core::ffi::c_int,
            pixel_height: ::core::ffi::c_int,
            color_type: cef_color_type_t,
            alpha_type: cef_alpha_type_t,
            pixel_data: *const ::core::ffi::c_void,
            pixel_data_size: usize,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Add a PNG image representation for |scale_factor|. |png_data| is the image\n data of size |png_data_size|. Any alpha transparency in the PNG data will\n be maintained.\n"]
    pub add_png: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_image_t,
            scale_factor: f32,
            png_data: *const ::core::ffi::c_void,
            png_data_size: usize,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Create a JPEG image representation for |scale_factor|. |jpeg_data| is the\n image data of size |jpeg_data_size|. The JPEG format does not support\n transparency so the alpha byte will be set to 0xFF for all pixels.\n"]
    pub add_jpeg: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_image_t,
            scale_factor: f32,
            jpeg_data: *const ::core::ffi::c_void,
            jpeg_data_size: usize,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the image width in density independent pixel (DIP) units.\n"]
    pub get_width: ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_image_t) -> usize>,
    #[doc = "\n Returns the image height in density independent pixel (DIP) units.\n"]
    pub get_height: ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_image_t) -> usize>,
    #[doc = "\n Returns true (1) if this image contains a representation for\n |scale_factor|.\n"]
    pub has_representation: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_image_t, scale_factor: f32) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Removes the representation for |scale_factor|. Returns true (1) on success.\n"]
    pub remove_representation: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_image_t, scale_factor: f32) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns information for the representation that most closely matches\n |scale_factor|. |actual_scale_factor| is the actual scale factor for the\n representation. |pixel_width| and |pixel_height| are the representation\n size in pixel coordinates. Returns true (1) on success.\n"]
    pub get_representation_info: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_image_t,
            scale_factor: f32,
            actual_scale_factor: *mut f32,
            pixel_width: *mut ::core::ffi::c_int,
            pixel_height: *mut ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the bitmap representation that most closely matches |scale_factor|.\n Only 32-bit RGBA/BGRA formats are supported. |color_type| and |alpha_type|\n values specify the desired output pixel format. |pixel_width| and\n |pixel_height| are the output representation size in pixel coordinates.\n Returns a cef_binary_value_t containing the pixel data on success or NULL\n on failure.\n"]
    pub get_as_bitmap: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_image_t,
            scale_factor: f32,
            color_type: cef_color_type_t,
            alpha_type: cef_alpha_type_t,
            pixel_width: *mut ::core::ffi::c_int,
            pixel_height: *mut ::core::ffi::c_int,
        ) -> *mut _cef_binary_value_t,
    >,
    #[doc = "\n Returns the PNG representation that most closely matches |scale_factor|. If\n |with_transparency| is true (1) any alpha transparency in the image will be\n represented in the resulting PNG data. |pixel_width| and |pixel_height| are\n the output representation size in pixel coordinates. Returns a\n cef_binary_value_t containing the PNG image data on success or NULL on\n failure.\n"]
    pub get_as_png: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_image_t,
            scale_factor: f32,
            with_transparency: ::core::ffi::c_int,
            pixel_width: *mut ::core::ffi::c_int,
            pixel_height: *mut ::core::ffi::c_int,
        ) -> *mut _cef_binary_value_t,
    >,
    #[doc = "\n Returns the JPEG representation that most closely matches |scale_factor|.\n |quality| determines the compression level with 0 == lowest and 100 ==\n highest. The JPEG format does not support alpha transparency and the alpha\n channel, if any, will be discarded. |pixel_width| and |pixel_height| are\n the output representation size in pixel coordinates. Returns a\n cef_binary_value_t containing the JPEG image data on success or NULL on\n failure.\n"]
    pub get_as_jpeg: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_image_t,
            scale_factor: f32,
            quality: ::core::ffi::c_int,
            pixel_width: *mut ::core::ffi::c_int,
            pixel_height: *mut ::core::ffi::c_int,
        ) -> *mut _cef_binary_value_t,
    >,
}
#[test]
fn bindgen_test_layout__cef_image_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_image_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_image_t>(),
        144usize,
        concat!("Size of: ", stringify!(_cef_image_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_image_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_image_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_image_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_empty) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_image_t),
            "::",
            stringify!(is_empty)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_same) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_image_t),
            "::",
            stringify!(is_same)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).add_bitmap) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_image_t),
            "::",
            stringify!(add_bitmap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).add_png) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_image_t),
            "::",
            stringify!(add_png)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).add_jpeg) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_image_t),
            "::",
            stringify!(add_jpeg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_width) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_image_t),
            "::",
            stringify!(get_width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_height) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_image_t),
            "::",
            stringify!(get_height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_representation) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_image_t),
            "::",
            stringify!(has_representation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).remove_representation) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_image_t),
            "::",
            stringify!(remove_representation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_representation_info) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_image_t),
            "::",
            stringify!(get_representation_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_as_bitmap) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_image_t),
            "::",
            stringify!(get_as_bitmap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_as_png) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_image_t),
            "::",
            stringify!(get_as_png)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_as_jpeg) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_image_t),
            "::",
            stringify!(get_as_jpeg)
        )
    );
}
#[doc = "\n Container for a single image represented at different scale factors. All\n image representations should be the same size in density independent pixel\n (DIP) units. For example, if the image at scale factor 1.0 is 100x100 pixels\n then the image at scale factor 2.0 should be 200x200 pixels -- both images\n will display with a DIP size of 100x100 units. The functions of this\n structure can be called on any browser process thread.\n"]
pub type cef_image_t = _cef_image_t;
#[doc = "\n Structure the client can implement to provide a custom stream reader. The\n functions of this structure may be called on any thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_read_handler_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Read raw binary data.\n"]
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_read_handler_t,
            ptr: *mut ::core::ffi::c_void,
            size: usize,
            n: usize,
        ) -> usize,
    >,
    #[doc = "\n Seek to the specified offset position. |whence| may be any one of SEEK_CUR,\n SEEK_END or SEEK_SET. Return zero on success and non-zero on failure.\n"]
    pub seek: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_read_handler_t,
            offset: int64,
            whence: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Return the current offset position.\n"]
    pub tell:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_read_handler_t) -> int64>,
    #[doc = "\n Return non-zero if at end of file.\n"]
    pub eof: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_read_handler_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Return true (1) if this handler performs work like accessing the file\n system which may block. Used as a hint for determining the thread to access\n the handler from.\n"]
    pub may_block: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_read_handler_t) -> ::core::ffi::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_read_handler_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_read_handler_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_read_handler_t>(),
        80usize,
        concat!("Size of: ", stringify!(_cef_read_handler_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_read_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_read_handler_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_read_handler_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_read_handler_t),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_read_handler_t),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tell) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_read_handler_t),
            "::",
            stringify!(tell)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).eof) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_read_handler_t),
            "::",
            stringify!(eof)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).may_block) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_read_handler_t),
            "::",
            stringify!(may_block)
        )
    );
}
#[doc = "\n Structure the client can implement to provide a custom stream reader. The\n functions of this structure may be called on any thread.\n"]
pub type cef_read_handler_t = _cef_read_handler_t;
#[doc = "\n Structure used to read data from a stream. The functions of this structure\n may be called on any thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_stream_reader_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Read raw binary data.\n"]
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_stream_reader_t,
            ptr: *mut ::core::ffi::c_void,
            size: usize,
            n: usize,
        ) -> usize,
    >,
    #[doc = "\n Seek to the specified offset position. |whence| may be any one of SEEK_CUR,\n SEEK_END or SEEK_SET. Returns zero on success and non-zero on failure.\n"]
    pub seek: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_stream_reader_t,
            offset: int64,
            whence: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Return the current offset position.\n"]
    pub tell:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_stream_reader_t) -> int64>,
    #[doc = "\n Return non-zero if at end of file.\n"]
    pub eof: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_stream_reader_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if this reader performs work like accessing the file\n system which may block. Used as a hint for determining the thread to access\n the reader from.\n"]
    pub may_block: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_stream_reader_t) -> ::core::ffi::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_stream_reader_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_stream_reader_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_stream_reader_t>(),
        80usize,
        concat!("Size of: ", stringify!(_cef_stream_reader_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_stream_reader_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_stream_reader_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_stream_reader_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_stream_reader_t),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_stream_reader_t),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tell) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_stream_reader_t),
            "::",
            stringify!(tell)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).eof) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_stream_reader_t),
            "::",
            stringify!(eof)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).may_block) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_stream_reader_t),
            "::",
            stringify!(may_block)
        )
    );
}
#[doc = "\n Structure used to read data from a stream. The functions of this structure\n may be called on any thread.\n"]
pub type cef_stream_reader_t = _cef_stream_reader_t;
#[doc = "\n Structure the client can implement to provide a custom stream writer. The\n functions of this structure may be called on any thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_write_handler_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Write raw binary data.\n"]
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_write_handler_t,
            ptr: *const ::core::ffi::c_void,
            size: usize,
            n: usize,
        ) -> usize,
    >,
    #[doc = "\n Seek to the specified offset position. |whence| may be any one of SEEK_CUR,\n SEEK_END or SEEK_SET. Return zero on success and non-zero on failure.\n"]
    pub seek: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_write_handler_t,
            offset: int64,
            whence: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Return the current offset position.\n"]
    pub tell:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_write_handler_t) -> int64>,
    #[doc = "\n Flush the stream.\n"]
    pub flush: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_write_handler_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Return true (1) if this handler performs work like accessing the file\n system which may block. Used as a hint for determining the thread to access\n the handler from.\n"]
    pub may_block: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_write_handler_t) -> ::core::ffi::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_write_handler_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_write_handler_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_write_handler_t>(),
        80usize,
        concat!("Size of: ", stringify!(_cef_write_handler_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_write_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_write_handler_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_write_handler_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_write_handler_t),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_write_handler_t),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tell) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_write_handler_t),
            "::",
            stringify!(tell)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flush) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_write_handler_t),
            "::",
            stringify!(flush)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).may_block) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_write_handler_t),
            "::",
            stringify!(may_block)
        )
    );
}
#[doc = "\n Structure the client can implement to provide a custom stream writer. The\n functions of this structure may be called on any thread.\n"]
pub type cef_write_handler_t = _cef_write_handler_t;
#[doc = "\n Structure used to write data to a stream. The functions of this structure may\n be called on any thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_stream_writer_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Write raw binary data.\n"]
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_stream_writer_t,
            ptr: *const ::core::ffi::c_void,
            size: usize,
            n: usize,
        ) -> usize,
    >,
    #[doc = "\n Seek to the specified offset position. |whence| may be any one of SEEK_CUR,\n SEEK_END or SEEK_SET. Returns zero on success and non-zero on failure.\n"]
    pub seek: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_stream_writer_t,
            offset: int64,
            whence: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Return the current offset position.\n"]
    pub tell:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_stream_writer_t) -> int64>,
    #[doc = "\n Flush the stream.\n"]
    pub flush: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_stream_writer_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if this writer performs work like accessing the file\n system which may block. Used as a hint for determining the thread to access\n the writer from.\n"]
    pub may_block: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_stream_writer_t) -> ::core::ffi::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_stream_writer_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_stream_writer_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_stream_writer_t>(),
        80usize,
        concat!("Size of: ", stringify!(_cef_stream_writer_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_stream_writer_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_stream_writer_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_stream_writer_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_stream_writer_t),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_stream_writer_t),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tell) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_stream_writer_t),
            "::",
            stringify!(tell)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flush) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_stream_writer_t),
            "::",
            stringify!(flush)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).may_block) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_stream_writer_t),
            "::",
            stringify!(may_block)
        )
    );
}
#[doc = "\n Structure used to write data to a stream. The functions of this structure may\n be called on any thread.\n"]
pub type cef_stream_writer_t = _cef_stream_writer_t;
#[doc = "\n Structure used to represent drag data. The functions of this structure may be\n called on any thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_drag_data_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Returns a copy of the current object.\n"]
    pub clone: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> *mut _cef_drag_data_t,
    >,
    #[doc = "\n Returns true (1) if this object is read-only.\n"]
    pub is_read_only: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if the drag data is a link.\n"]
    pub is_link: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if the drag data is a text or html fragment.\n"]
    pub is_fragment: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if the drag data is a file.\n"]
    pub is_file: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Return the link URL that is being dragged.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_link_url: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Return the title associated with the link being dragged.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_link_title: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Return the metadata, if any, associated with the link being dragged.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_link_metadata: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Return the plain text fragment that is being dragged.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_fragment_text: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Return the text/html fragment that is being dragged.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_fragment_html: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Return the base URL that the fragment came from. This value is used for\n resolving relative URLs and may be NULL.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_fragment_base_url: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Return the name of the file being dragged out of the browser window.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_file_name: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Write the contents of the file being dragged out of the web view into\n |writer|. Returns the number of bytes sent to |writer|. If |writer| is NULL\n this function will return the size of the file contents in bytes. Call\n get_file_name() to get a suggested name for the file.\n"]
    pub get_file_contents: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_drag_data_t,
            writer: *mut _cef_stream_writer_t,
        ) -> usize,
    >,
    #[doc = "\n Retrieve the list of file names that are being dragged into the browser\n window.\n"]
    pub get_file_names: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_drag_data_t,
            names: cef_string_list_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Set the link URL that is being dragged.\n"]
    pub set_link_url: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t, url: *const cef_string_t),
    >,
    #[doc = "\n Set the title associated with the link being dragged.\n"]
    pub set_link_title: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t, title: *const cef_string_t),
    >,
    #[doc = "\n Set the metadata associated with the link being dragged.\n"]
    pub set_link_metadata: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t, data: *const cef_string_t),
    >,
    #[doc = "\n Set the plain text fragment that is being dragged.\n"]
    pub set_fragment_text: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t, text: *const cef_string_t),
    >,
    #[doc = "\n Set the text/html fragment that is being dragged.\n"]
    pub set_fragment_html: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t, html: *const cef_string_t),
    >,
    #[doc = "\n Set the base URL that the fragment came from.\n"]
    pub set_fragment_base_url: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t, base_url: *const cef_string_t),
    >,
    #[doc = "\n Reset the file contents. You should do this before calling\n cef_browser_host_t::DragTargetDragEnter as the web view does not allow us\n to drag in this kind of data.\n"]
    pub reset_file_contents:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_drag_data_t)>,
    #[doc = "\n Add a file that is being dragged into the webview.\n"]
    pub add_file: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_drag_data_t,
            path: *const cef_string_t,
            display_name: *const cef_string_t,
        ),
    >,
    #[doc = "\n Get the image representation of drag data. May return NULL if no image\n representation is available.\n"]
    pub get_image: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> *mut _cef_image_t,
    >,
    #[doc = "\n Get the image hotspot (drag start location relative to image dimensions).\n"]
    pub get_image_hotspot:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> cef_point_t>,
    #[doc = "\n Returns true (1) if an image representation of drag data is available.\n"]
    pub has_image: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> ::core::ffi::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_drag_data_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_drag_data_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_drag_data_t>(),
        240usize,
        concat!("Size of: ", stringify!(_cef_drag_data_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_drag_data_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_drag_data_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_drag_data_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clone) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_drag_data_t),
            "::",
            stringify!(clone)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_read_only) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_drag_data_t),
            "::",
            stringify!(is_read_only)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_link) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_drag_data_t),
            "::",
            stringify!(is_link)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_fragment) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_drag_data_t),
            "::",
            stringify!(is_fragment)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_file) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_drag_data_t),
            "::",
            stringify!(is_file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_link_url) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_drag_data_t),
            "::",
            stringify!(get_link_url)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_link_title) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_drag_data_t),
            "::",
            stringify!(get_link_title)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_link_metadata) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_drag_data_t),
            "::",
            stringify!(get_link_metadata)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_fragment_text) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_drag_data_t),
            "::",
            stringify!(get_fragment_text)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_fragment_html) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_drag_data_t),
            "::",
            stringify!(get_fragment_html)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_fragment_base_url) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_drag_data_t),
            "::",
            stringify!(get_fragment_base_url)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_file_name) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_drag_data_t),
            "::",
            stringify!(get_file_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_file_contents) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_drag_data_t),
            "::",
            stringify!(get_file_contents)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_file_names) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_drag_data_t),
            "::",
            stringify!(get_file_names)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_link_url) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_drag_data_t),
            "::",
            stringify!(set_link_url)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_link_title) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_drag_data_t),
            "::",
            stringify!(set_link_title)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_link_metadata) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_drag_data_t),
            "::",
            stringify!(set_link_metadata)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_fragment_text) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_drag_data_t),
            "::",
            stringify!(set_fragment_text)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_fragment_html) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_drag_data_t),
            "::",
            stringify!(set_fragment_html)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_fragment_base_url) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_drag_data_t),
            "::",
            stringify!(set_fragment_base_url)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reset_file_contents) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_drag_data_t),
            "::",
            stringify!(reset_file_contents)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).add_file) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_drag_data_t),
            "::",
            stringify!(add_file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_image) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_drag_data_t),
            "::",
            stringify!(get_image)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_image_hotspot) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_drag_data_t),
            "::",
            stringify!(get_image_hotspot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_image) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_drag_data_t),
            "::",
            stringify!(has_image)
        )
    );
}
#[doc = "\n Structure used to represent drag data. The functions of this structure may be\n called on any thread.\n"]
pub type cef_drag_data_t = _cef_drag_data_t;
#[doc = "\n Structure to implement for visiting the DOM. The functions of this structure\n will be called on the render process main thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_domvisitor_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Method executed for visiting the DOM. The document object passed to this\n function represents a snapshot of the DOM at the time this function is\n executed. DOM objects are only valid for the scope of this function. Do not\n keep references to or attempt to access any DOM objects outside the scope\n of this function.\n"]
    pub visit: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domvisitor_t, document: *mut _cef_domdocument_t),
    >,
}
#[test]
fn bindgen_test_layout__cef_domvisitor_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_domvisitor_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_domvisitor_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_domvisitor_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_domvisitor_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_domvisitor_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_domvisitor_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).visit) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_domvisitor_t),
            "::",
            stringify!(visit)
        )
    );
}
#[doc = "\n Structure to implement for visiting the DOM. The functions of this structure\n will be called on the render process main thread.\n"]
pub type cef_domvisitor_t = _cef_domvisitor_t;
#[doc = "\n Structure used to represent a DOM document. The functions of this structure\n should only be called on the render process main thread thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_domdocument_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Returns the document type.\n"]
    pub get_type: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domdocument_t) -> cef_dom_document_type_t,
    >,
    #[doc = "\n Returns the root document node.\n"]
    pub get_document: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domdocument_t) -> *mut _cef_domnode_t,
    >,
    #[doc = "\n Returns the BODY node of an HTML document.\n"]
    pub get_body: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domdocument_t) -> *mut _cef_domnode_t,
    >,
    #[doc = "\n Returns the HEAD node of an HTML document.\n"]
    pub get_head: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domdocument_t) -> *mut _cef_domnode_t,
    >,
    #[doc = "\n Returns the title of an HTML document.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_title: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domdocument_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the document element with the specified ID value.\n"]
    pub get_element_by_id: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_domdocument_t,
            id: *const cef_string_t,
        ) -> *mut _cef_domnode_t,
    >,
    #[doc = "\n Returns the node that currently has keyboard focus.\n"]
    pub get_focused_node: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domdocument_t) -> *mut _cef_domnode_t,
    >,
    #[doc = "\n Returns true (1) if a portion of the document is selected.\n"]
    pub has_selection: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domdocument_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the selection offset within the start node.\n"]
    pub get_selection_start_offset: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domdocument_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the selection offset within the end node.\n"]
    pub get_selection_end_offset: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domdocument_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the contents of this selection as markup.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_selection_as_markup: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domdocument_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the contents of this selection as text.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_selection_as_text: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domdocument_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the base URL for the document.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_base_url: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domdocument_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns a complete URL based on the document base URL and the specified\n partial URL.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_complete_url: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_domdocument_t,
            partialURL: *const cef_string_t,
        ) -> cef_string_userfree_t,
    >,
}
#[test]
fn bindgen_test_layout__cef_domdocument_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_domdocument_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_domdocument_t>(),
        152usize,
        concat!("Size of: ", stringify!(_cef_domdocument_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_domdocument_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_domdocument_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_domdocument_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_type) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_domdocument_t),
            "::",
            stringify!(get_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_document) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_domdocument_t),
            "::",
            stringify!(get_document)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_body) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_domdocument_t),
            "::",
            stringify!(get_body)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_head) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_domdocument_t),
            "::",
            stringify!(get_head)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_title) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_domdocument_t),
            "::",
            stringify!(get_title)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_element_by_id) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_domdocument_t),
            "::",
            stringify!(get_element_by_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_focused_node) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_domdocument_t),
            "::",
            stringify!(get_focused_node)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_selection) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_domdocument_t),
            "::",
            stringify!(has_selection)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_selection_start_offset) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_domdocument_t),
            "::",
            stringify!(get_selection_start_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_selection_end_offset) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_domdocument_t),
            "::",
            stringify!(get_selection_end_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_selection_as_markup) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_domdocument_t),
            "::",
            stringify!(get_selection_as_markup)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_selection_as_text) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_domdocument_t),
            "::",
            stringify!(get_selection_as_text)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_base_url) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_domdocument_t),
            "::",
            stringify!(get_base_url)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_complete_url) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_domdocument_t),
            "::",
            stringify!(get_complete_url)
        )
    );
}
#[doc = "\n Structure used to represent a DOM document. The functions of this structure\n should only be called on the render process main thread thread.\n"]
pub type cef_domdocument_t = _cef_domdocument_t;
#[doc = "\n Structure used to represent a DOM node. The functions of this structure\n should only be called on the render process main thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_domnode_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Returns the type for this node.\n"]
    pub get_type: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> cef_dom_node_type_t,
    >,
    #[doc = "\n Returns true (1) if this is a text node.\n"]
    pub is_text: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if this is an element node.\n"]
    pub is_element: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if this is an editable node.\n"]
    pub is_editable: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if this is a form control element node.\n"]
    pub is_form_control_element: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the type of this form control element node.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_form_control_element_type: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns true (1) if this object is pointing to the same handle as |that|\n object.\n"]
    pub is_same: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_domnode_t,
            that: *mut _cef_domnode_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the name of this node.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_name: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the value of this node.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_value: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Set the value of this node. Returns true (1) on success.\n"]
    pub set_value: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_domnode_t,
            value: *const cef_string_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the contents of this node as markup.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_as_markup: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the document associated with this node.\n"]
    pub get_document: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> *mut _cef_domdocument_t,
    >,
    #[doc = "\n Returns the parent node.\n"]
    pub get_parent: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> *mut _cef_domnode_t,
    >,
    #[doc = "\n Returns the previous sibling node.\n"]
    pub get_previous_sibling: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> *mut _cef_domnode_t,
    >,
    #[doc = "\n Returns the next sibling node.\n"]
    pub get_next_sibling: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> *mut _cef_domnode_t,
    >,
    #[doc = "\n Returns true (1) if this node has child nodes.\n"]
    pub has_children: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Return the first child node.\n"]
    pub get_first_child: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> *mut _cef_domnode_t,
    >,
    #[doc = "\n Returns the last child node.\n"]
    pub get_last_child: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> *mut _cef_domnode_t,
    >,
    #[doc = "\n Returns the tag name of this element.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_element_tag_name: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns true (1) if this element has attributes.\n"]
    pub has_element_attributes: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if this element has an attribute named |attrName|.\n"]
    pub has_element_attribute: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_domnode_t,
            attrName: *const cef_string_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the element attribute named |attrName|.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_element_attribute: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_domnode_t,
            attrName: *const cef_string_t,
        ) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns a map of all element attributes.\n"]
    pub get_element_attributes: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t, attrMap: cef_string_map_t),
    >,
    #[doc = "\n Set the value for the element attribute named |attrName|. Returns true (1)\n on success.\n"]
    pub set_element_attribute: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_domnode_t,
            attrName: *const cef_string_t,
            value: *const cef_string_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the inner text of the element.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_element_inner_text: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the bounds of the element.\n"]
    pub get_element_bounds:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> cef_rect_t>,
}
#[test]
fn bindgen_test_layout__cef_domnode_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_domnode_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_domnode_t>(),
        248usize,
        concat!("Size of: ", stringify!(_cef_domnode_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_domnode_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_domnode_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_domnode_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_type) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_domnode_t),
            "::",
            stringify!(get_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_text) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_domnode_t),
            "::",
            stringify!(is_text)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_element) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_domnode_t),
            "::",
            stringify!(is_element)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_editable) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_domnode_t),
            "::",
            stringify!(is_editable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_form_control_element) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_domnode_t),
            "::",
            stringify!(is_form_control_element)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).get_form_control_element_type) as usize - ptr as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_domnode_t),
            "::",
            stringify!(get_form_control_element_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_same) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_domnode_t),
            "::",
            stringify!(is_same)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_name) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_domnode_t),
            "::",
            stringify!(get_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_value) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_domnode_t),
            "::",
            stringify!(get_value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_value) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_domnode_t),
            "::",
            stringify!(set_value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_as_markup) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_domnode_t),
            "::",
            stringify!(get_as_markup)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_document) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_domnode_t),
            "::",
            stringify!(get_document)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_parent) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_domnode_t),
            "::",
            stringify!(get_parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_previous_sibling) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_domnode_t),
            "::",
            stringify!(get_previous_sibling)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_next_sibling) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_domnode_t),
            "::",
            stringify!(get_next_sibling)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_children) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_domnode_t),
            "::",
            stringify!(has_children)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_first_child) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_domnode_t),
            "::",
            stringify!(get_first_child)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_last_child) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_domnode_t),
            "::",
            stringify!(get_last_child)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_element_tag_name) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_domnode_t),
            "::",
            stringify!(get_element_tag_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_element_attributes) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_domnode_t),
            "::",
            stringify!(has_element_attributes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_element_attribute) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_domnode_t),
            "::",
            stringify!(has_element_attribute)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_element_attribute) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_domnode_t),
            "::",
            stringify!(get_element_attribute)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_element_attributes) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_domnode_t),
            "::",
            stringify!(get_element_attributes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_element_attribute) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_domnode_t),
            "::",
            stringify!(set_element_attribute)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_element_inner_text) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_domnode_t),
            "::",
            stringify!(get_element_inner_text)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_element_bounds) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_domnode_t),
            "::",
            stringify!(get_element_bounds)
        )
    );
}
#[doc = "\n Structure used to represent a DOM node. The functions of this structure\n should only be called on the render process main thread.\n"]
pub type cef_domnode_t = _cef_domnode_t;
#[doc = "\n Structure representing a message. Can be used on any process and thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_process_message_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Returns true (1) if this object is valid. Do not call any other functions\n if this function returns false (0).\n"]
    pub is_valid: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_process_message_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if the values of this object are read-only. Some APIs may\n expose read-only objects.\n"]
    pub is_read_only: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_process_message_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns a writable copy of this object.\n"]
    pub copy: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_process_message_t) -> *mut _cef_process_message_t,
    >,
    #[doc = "\n Returns the message name.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_name: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_process_message_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the list of arguments.\n"]
    pub get_argument_list: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_process_message_t) -> *mut _cef_list_value_t,
    >,
}
#[test]
fn bindgen_test_layout__cef_process_message_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_process_message_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_process_message_t>(),
        80usize,
        concat!("Size of: ", stringify!(_cef_process_message_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_process_message_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_process_message_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_process_message_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_valid) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_process_message_t),
            "::",
            stringify!(is_valid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_read_only) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_process_message_t),
            "::",
            stringify!(is_read_only)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).copy) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_process_message_t),
            "::",
            stringify!(copy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_name) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_process_message_t),
            "::",
            stringify!(get_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_argument_list) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_process_message_t),
            "::",
            stringify!(get_argument_list)
        )
    );
}
#[doc = "\n Structure representing a message. Can be used on any process and thread.\n"]
pub type cef_process_message_t = _cef_process_message_t;
#[doc = "\n Structure used to represent a web request. The functions of this structure\n may be called on any thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_request_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Returns true (1) if this object is read-only.\n"]
    pub is_read_only: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Get the fully qualified URL.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_url: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Set the fully qualified URL.\n"]
    pub set_url: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t, url: *const cef_string_t),
    >,
    #[doc = "\n Get the request function type. The value will default to POST if post data\n is provided and GET otherwise.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_method: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Set the request function type.\n"]
    pub set_method: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t, method: *const cef_string_t),
    >,
    #[doc = "\n Set the referrer URL and policy. If non-NULL the referrer URL must be fully\n qualified with an HTTP or HTTPS scheme component. Any username, password or\n ref component will be removed.\n"]
    pub set_referrer: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_t,
            referrer_url: *const cef_string_t,
            policy: cef_referrer_policy_t,
        ),
    >,
    #[doc = "\n Get the referrer URL.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_referrer_url: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Get the referrer policy.\n"]
    pub get_referrer_policy: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t) -> cef_referrer_policy_t,
    >,
    #[doc = "\n Get the post data.\n"]
    pub get_post_data: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t) -> *mut _cef_post_data_t,
    >,
    #[doc = "\n Set the post data.\n"]
    pub set_post_data: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t, postData: *mut _cef_post_data_t),
    >,
    #[doc = "\n Get the header values. Will not include the Referer value if any.\n"]
    pub get_header_map: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t, headerMap: cef_string_multimap_t),
    >,
    #[doc = "\n Set the header values. If a Referer value exists in the header map it will\n be removed and ignored.\n"]
    pub set_header_map: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t, headerMap: cef_string_multimap_t),
    >,
    #[doc = "\n Returns the first header value for |name| or an NULL string if not found.\n Will not return the Referer value if any. Use GetHeaderMap instead if\n |name| might have multiple values.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_header_by_name: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_t,
            name: *const cef_string_t,
        ) -> cef_string_userfree_t,
    >,
    #[doc = "\n Set the header |name| to |value|. If |overwrite| is true (1) any existing\n values will be replaced with the new value. If |overwrite| is false (0) any\n existing values will not be overwritten. The Referer value cannot be set\n using this function.\n"]
    pub set_header_by_name: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_t,
            name: *const cef_string_t,
            value: *const cef_string_t,
            overwrite: ::core::ffi::c_int,
        ),
    >,
    #[doc = "\n Set all values at one time.\n"]
    pub set: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_t,
            url: *const cef_string_t,
            method: *const cef_string_t,
            postData: *mut _cef_post_data_t,
            headerMap: cef_string_multimap_t,
        ),
    >,
    #[doc = "\n Get the flags used in combination with cef_urlrequest_t. See\n cef_urlrequest_flags_t for supported values.\n"]
    pub get_flags: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Set the flags used in combination with cef_urlrequest_t.  See\n cef_urlrequest_flags_t for supported values.\n"]
    pub set_flags: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t, flags: ::core::ffi::c_int),
    >,
    #[doc = "\n Get the URL to the first party for cookies used in combination with\n cef_urlrequest_t.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_first_party_for_cookies: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Set the URL to the first party for cookies used in combination with\n cef_urlrequest_t.\n"]
    pub set_first_party_for_cookies: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t, url: *const cef_string_t),
    >,
    #[doc = "\n Get the resource type for this request. Only available in the browser\n process.\n"]
    pub get_resource_type: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t) -> cef_resource_type_t,
    >,
    #[doc = "\n Get the transition type for this request. Only available in the browser\n process and only applies to requests that represent a main frame or sub-\n frame navigation.\n"]
    pub get_transition_type: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t) -> cef_transition_type_t,
    >,
    #[doc = "\n Returns the globally unique identifier for this request or 0 if not\n specified. Can be used by cef_resource_request_handler_t implementations in\n the browser process to track a single request across multiple callbacks.\n"]
    pub get_identifier:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_request_t) -> uint64>,
}
#[test]
fn bindgen_test_layout__cef_request_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_request_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_request_t>(),
        216usize,
        concat!("Size of: ", stringify!(_cef_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_request_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_request_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_read_only) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_t),
            "::",
            stringify!(is_read_only)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_url) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_t),
            "::",
            stringify!(get_url)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_url) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_t),
            "::",
            stringify!(set_url)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_method) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_t),
            "::",
            stringify!(get_method)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_method) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_t),
            "::",
            stringify!(set_method)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_referrer) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_t),
            "::",
            stringify!(set_referrer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_referrer_url) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_t),
            "::",
            stringify!(get_referrer_url)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_referrer_policy) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_t),
            "::",
            stringify!(get_referrer_policy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_post_data) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_t),
            "::",
            stringify!(get_post_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_post_data) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_t),
            "::",
            stringify!(set_post_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_header_map) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_t),
            "::",
            stringify!(get_header_map)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_header_map) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_t),
            "::",
            stringify!(set_header_map)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_header_by_name) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_t),
            "::",
            stringify!(get_header_by_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_header_by_name) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_t),
            "::",
            stringify!(set_header_by_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_t),
            "::",
            stringify!(set)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_flags) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_t),
            "::",
            stringify!(get_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_flags) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_t),
            "::",
            stringify!(set_flags)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).get_first_party_for_cookies) as usize - ptr as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_t),
            "::",
            stringify!(get_first_party_for_cookies)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).set_first_party_for_cookies) as usize - ptr as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_t),
            "::",
            stringify!(set_first_party_for_cookies)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_resource_type) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_t),
            "::",
            stringify!(get_resource_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_transition_type) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_t),
            "::",
            stringify!(get_transition_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_identifier) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_t),
            "::",
            stringify!(get_identifier)
        )
    );
}
#[doc = "\n Structure used to represent a web request. The functions of this structure\n may be called on any thread.\n"]
pub type cef_request_t = _cef_request_t;
#[doc = "\n Structure used to represent post data for a web request. The functions of\n this structure may be called on any thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_post_data_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Returns true (1) if this object is read-only.\n"]
    pub is_read_only: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_post_data_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if the underlying POST data includes elements that are not\n represented by this cef_post_data_t object (for example, multi-part file\n upload data). Modifying cef_post_data_t objects with excluded elements may\n result in the request failing.\n"]
    pub has_excluded_elements: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_post_data_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the number of existing post data elements.\n"]
    pub get_element_count:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_post_data_t) -> usize>,
    #[doc = "\n Retrieve the post data elements.\n"]
    pub get_elements: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_post_data_t,
            elementsCount: *mut usize,
            elements: *mut *mut _cef_post_data_element_t,
        ),
    >,
    #[doc = "\n Remove the specified post data element.  Returns true (1) if the removal\n succeeds.\n"]
    pub remove_element: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_post_data_t,
            element: *mut _cef_post_data_element_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Add the specified post data element.  Returns true (1) if the add succeeds.\n"]
    pub add_element: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_post_data_t,
            element: *mut _cef_post_data_element_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Remove all existing post data elements.\n"]
    pub remove_elements: ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_post_data_t)>,
}
#[test]
fn bindgen_test_layout__cef_post_data_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_post_data_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_post_data_t>(),
        96usize,
        concat!("Size of: ", stringify!(_cef_post_data_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_post_data_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_post_data_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_post_data_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_read_only) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_post_data_t),
            "::",
            stringify!(is_read_only)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_excluded_elements) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_post_data_t),
            "::",
            stringify!(has_excluded_elements)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_element_count) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_post_data_t),
            "::",
            stringify!(get_element_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_elements) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_post_data_t),
            "::",
            stringify!(get_elements)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).remove_element) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_post_data_t),
            "::",
            stringify!(remove_element)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).add_element) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_post_data_t),
            "::",
            stringify!(add_element)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).remove_elements) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_post_data_t),
            "::",
            stringify!(remove_elements)
        )
    );
}
#[doc = "\n Structure used to represent post data for a web request. The functions of\n this structure may be called on any thread.\n"]
pub type cef_post_data_t = _cef_post_data_t;
#[doc = "\n Structure used to represent a single element in the request post data. The\n functions of this structure may be called on any thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_post_data_element_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Returns true (1) if this object is read-only.\n"]
    pub is_read_only: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_post_data_element_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Remove all contents from the post data element.\n"]
    pub set_to_empty:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_post_data_element_t)>,
    #[doc = "\n The post data element will represent a file.\n"]
    pub set_to_file: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_post_data_element_t, fileName: *const cef_string_t),
    >,
    #[doc = "\n The post data element will represent bytes.  The bytes passed in will be\n copied.\n"]
    pub set_to_bytes: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_post_data_element_t,
            size: usize,
            bytes: *const ::core::ffi::c_void,
        ),
    >,
    #[doc = "\n Return the type of this post data element.\n"]
    pub get_type: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_post_data_element_t) -> cef_postdataelement_type_t,
    >,
    #[doc = "\n Return the file name.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_file: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_post_data_element_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Return the number of bytes.\n"]
    pub get_bytes_count:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_post_data_element_t) -> usize>,
    #[doc = "\n Read up to |size| bytes into |bytes| and return the number of bytes\n actually read.\n"]
    pub get_bytes: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_post_data_element_t,
            size: usize,
            bytes: *mut ::core::ffi::c_void,
        ) -> usize,
    >,
}
#[test]
fn bindgen_test_layout__cef_post_data_element_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_post_data_element_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_post_data_element_t>(),
        104usize,
        concat!("Size of: ", stringify!(_cef_post_data_element_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_post_data_element_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_post_data_element_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_post_data_element_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_read_only) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_post_data_element_t),
            "::",
            stringify!(is_read_only)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_to_empty) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_post_data_element_t),
            "::",
            stringify!(set_to_empty)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_to_file) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_post_data_element_t),
            "::",
            stringify!(set_to_file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_to_bytes) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_post_data_element_t),
            "::",
            stringify!(set_to_bytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_type) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_post_data_element_t),
            "::",
            stringify!(get_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_file) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_post_data_element_t),
            "::",
            stringify!(get_file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_bytes_count) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_post_data_element_t),
            "::",
            stringify!(get_bytes_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_bytes) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_post_data_element_t),
            "::",
            stringify!(get_bytes)
        )
    );
}
#[doc = "\n Structure used to represent a single element in the request post data. The\n functions of this structure may be called on any thread.\n"]
pub type cef_post_data_element_t = _cef_post_data_element_t;
#[doc = "\n Implement this structure to receive string values asynchronously.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_string_visitor_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Method that will be executed.\n"]
    pub visit: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_string_visitor_t, string: *const cef_string_t),
    >,
}
#[test]
fn bindgen_test_layout__cef_string_visitor_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_string_visitor_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_string_visitor_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_string_visitor_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_string_visitor_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_string_visitor_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_string_visitor_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).visit) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_string_visitor_t),
            "::",
            stringify!(visit)
        )
    );
}
#[doc = "\n Implement this structure to receive string values asynchronously.\n"]
pub type cef_string_visitor_t = _cef_string_visitor_t;
#[doc = "\n Structure used to represent a frame in the browser window. When used in the\n browser process the functions of this structure may be called on any thread\n unless otherwise indicated in the comments. When used in the render process\n the functions of this structure may only be called on the main thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_frame_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n True if this object is currently attached to a valid frame.\n"]
    pub is_valid: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_frame_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Execute undo in this frame.\n"]
    pub undo: ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_frame_t)>,
    #[doc = "\n Execute redo in this frame.\n"]
    pub redo: ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_frame_t)>,
    #[doc = "\n Execute cut in this frame.\n"]
    pub cut: ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_frame_t)>,
    #[doc = "\n Execute copy in this frame.\n"]
    pub copy: ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_frame_t)>,
    #[doc = "\n Execute paste in this frame.\n"]
    pub paste: ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_frame_t)>,
    #[doc = "\n Execute delete in this frame.\n"]
    pub del: ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_frame_t)>,
    #[doc = "\n Execute select all in this frame.\n"]
    pub select_all: ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_frame_t)>,
    #[doc = "\n Save this frame's HTML source to a temporary file and open it in the\n default text viewing application. This function can only be called from the\n browser process.\n"]
    pub view_source: ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_frame_t)>,
    #[doc = "\n Retrieve this frame's HTML source as a string sent to the specified\n visitor.\n"]
    pub get_source: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_frame_t, visitor: *mut _cef_string_visitor_t),
    >,
    #[doc = "\n Retrieve this frame's display text as a string sent to the specified\n visitor.\n"]
    pub get_text: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_frame_t, visitor: *mut _cef_string_visitor_t),
    >,
    #[doc = "\n Load the request represented by the |request| object.\n\n WARNING: This function will fail with \"bad IPC message\" reason\n INVALID_INITIATOR_ORIGIN (213) unless you first navigate to the request\n origin using some other mechanism (LoadURL, link click, etc).\n"]
    pub load_request: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_frame_t, request: *mut _cef_request_t),
    >,
    #[doc = "\n Load the specified |url|.\n"]
    pub load_url: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_frame_t, url: *const cef_string_t),
    >,
    #[doc = "\n Execute a string of JavaScript code in this frame. The |script_url|\n parameter is the URL where the script in question can be found, if any. The\n renderer may request this URL to show the developer the source of the\n error.  The |start_line| parameter is the base line number to use for error\n reporting.\n"]
    pub execute_java_script: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_frame_t,
            code: *const cef_string_t,
            script_url: *const cef_string_t,
            start_line: ::core::ffi::c_int,
        ),
    >,
    #[doc = "\n Returns true (1) if this is the main (top-level) frame.\n"]
    pub is_main: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_frame_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if this is the focused frame.\n"]
    pub is_focused: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_frame_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the name for this frame. If the frame has an assigned name (for\n example, set via the iframe \"name\" attribute) then that value will be\n returned. Otherwise a unique name will be constructed based on the frame\n parent hierarchy. The main (top-level) frame will always have an NULL name\n value.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_name: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_frame_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the globally unique identifier for this frame or < 0 if the\n underlying frame does not yet exist.\n"]
    pub get_identifier:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_frame_t) -> int64>,
    #[doc = "\n Returns the parent of this frame or NULL if this is the main (top-level)\n frame.\n"]
    pub get_parent:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_frame_t) -> *mut _cef_frame_t>,
    #[doc = "\n Returns the URL currently loaded in this frame.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_url: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_frame_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the browser that this frame belongs to.\n"]
    pub get_browser: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_frame_t) -> *mut _cef_browser_t,
    >,
    #[doc = "\n Get the V8 context associated with the frame. This function can only be\n called from the render process.\n"]
    pub get_v8context: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_frame_t) -> *mut _cef_v8context_t,
    >,
    #[doc = "\n Visit the DOM document. This function can only be called from the render\n process.\n"]
    pub visit_dom: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_frame_t, visitor: *mut _cef_domvisitor_t),
    >,
    #[doc = "\n Create a new URL request that will be treated as originating from this\n frame and the associated browser. This request may be intercepted by the\n client via cef_resource_request_handler_t or cef_scheme_handler_factory_t.\n Use cef_urlrequest_t::Create instead if you do not want the request to have\n this association, in which case it may be handled differently (see\n documentation on that function). Requests may originate from both the\n browser process and the render process.\n\n For requests originating from the browser process:\n   - POST data may only contain a single element of type PDE_TYPE_FILE or\n     PDE_TYPE_BYTES.\n For requests originating from the render process:\n   - POST data may only contain a single element of type PDE_TYPE_BYTES.\n   - If the response contains Content-Disposition or Mime-Type header values\n     that would not normally be rendered then the response may receive\n     special handling inside the browser (for example, via the file download\n     code path instead of the URL request code path).\n\n The |request| object will be marked as read-only after calling this\n function.\n"]
    pub create_urlrequest: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_frame_t,
            request: *mut _cef_request_t,
            client: *mut _cef_urlrequest_client_t,
        ) -> *mut _cef_urlrequest_t,
    >,
    #[doc = "\n Send a message to the specified |target_process|. Message delivery is not\n guaranteed in all cases (for example, if the browser is closing,\n navigating, or if the target process crashes). Send an ACK message back\n from the target process if confirmation is required.\n"]
    pub send_process_message: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_frame_t,
            target_process: cef_process_id_t,
            message: *mut _cef_process_message_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_frame_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_frame_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_frame_t>(),
        240usize,
        concat!("Size of: ", stringify!(_cef_frame_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_frame_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_frame_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_frame_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_valid) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_frame_t),
            "::",
            stringify!(is_valid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).undo) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_frame_t),
            "::",
            stringify!(undo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).redo) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_frame_t),
            "::",
            stringify!(redo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cut) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_frame_t),
            "::",
            stringify!(cut)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).copy) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_frame_t),
            "::",
            stringify!(copy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).paste) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_frame_t),
            "::",
            stringify!(paste)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).del) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_frame_t),
            "::",
            stringify!(del)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).select_all) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_frame_t),
            "::",
            stringify!(select_all)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).view_source) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_frame_t),
            "::",
            stringify!(view_source)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_source) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_frame_t),
            "::",
            stringify!(get_source)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_text) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_frame_t),
            "::",
            stringify!(get_text)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).load_request) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_frame_t),
            "::",
            stringify!(load_request)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).load_url) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_frame_t),
            "::",
            stringify!(load_url)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).execute_java_script) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_frame_t),
            "::",
            stringify!(execute_java_script)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_main) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_frame_t),
            "::",
            stringify!(is_main)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_focused) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_frame_t),
            "::",
            stringify!(is_focused)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_name) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_frame_t),
            "::",
            stringify!(get_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_identifier) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_frame_t),
            "::",
            stringify!(get_identifier)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_parent) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_frame_t),
            "::",
            stringify!(get_parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_url) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_frame_t),
            "::",
            stringify!(get_url)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_browser) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_frame_t),
            "::",
            stringify!(get_browser)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_v8context) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_frame_t),
            "::",
            stringify!(get_v8context)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).visit_dom) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_frame_t),
            "::",
            stringify!(visit_dom)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).create_urlrequest) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_frame_t),
            "::",
            stringify!(create_urlrequest)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_process_message) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_frame_t),
            "::",
            stringify!(send_process_message)
        )
    );
}
#[doc = "\n Structure used to represent a frame in the browser window. When used in the\n browser process the functions of this structure may be called on any thread\n unless otherwise indicated in the comments. When used in the render process\n the functions of this structure may only be called on the main thread.\n"]
pub type cef_frame_t = _cef_frame_t;
#[doc = "\n Structure representing the issuer or subject field of an X.509 certificate.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_x509cert_principal_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Returns a name that can be used to represent the issuer. It tries in this\n order: Common Name (CN), Organization Name (O) and Organizational Unit Name\n (OU) and returns the first non-NULL one found.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_display_name: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509cert_principal_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the common name.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_common_name: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509cert_principal_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the locality name.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_locality_name: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509cert_principal_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the state or province name.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_state_or_province_name: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509cert_principal_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the country name.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_country_name: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509cert_principal_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Retrieve the list of street addresses.\n"]
    pub get_street_addresses: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509cert_principal_t, addresses: cef_string_list_t),
    >,
    #[doc = "\n Retrieve the list of organization names.\n"]
    pub get_organization_names: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509cert_principal_t, names: cef_string_list_t),
    >,
    #[doc = "\n Retrieve the list of organization unit names.\n"]
    pub get_organization_unit_names: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509cert_principal_t, names: cef_string_list_t),
    >,
    #[doc = "\n Retrieve the list of domain components.\n"]
    pub get_domain_components: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509cert_principal_t, components: cef_string_list_t),
    >,
}
#[test]
fn bindgen_test_layout__cef_x509cert_principal_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_x509cert_principal_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_x509cert_principal_t>(),
        112usize,
        concat!("Size of: ", stringify!(_cef_x509cert_principal_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_x509cert_principal_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_x509cert_principal_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_x509cert_principal_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_display_name) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_x509cert_principal_t),
            "::",
            stringify!(get_display_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_common_name) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_x509cert_principal_t),
            "::",
            stringify!(get_common_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_locality_name) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_x509cert_principal_t),
            "::",
            stringify!(get_locality_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_state_or_province_name) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_x509cert_principal_t),
            "::",
            stringify!(get_state_or_province_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_country_name) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_x509cert_principal_t),
            "::",
            stringify!(get_country_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_street_addresses) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_x509cert_principal_t),
            "::",
            stringify!(get_street_addresses)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_organization_names) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_x509cert_principal_t),
            "::",
            stringify!(get_organization_names)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).get_organization_unit_names) as usize - ptr as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_x509cert_principal_t),
            "::",
            stringify!(get_organization_unit_names)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_domain_components) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_x509cert_principal_t),
            "::",
            stringify!(get_domain_components)
        )
    );
}
#[doc = "\n Structure representing the issuer or subject field of an X.509 certificate.\n"]
pub type cef_x509cert_principal_t = _cef_x509cert_principal_t;
#[doc = "\n Structure representing a X.509 certificate.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_x509certificate_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Returns the subject of the X.509 certificate. For HTTPS server certificates\n this represents the web server.  The common name of the subject should\n match the host name of the web server.\n"]
    pub get_subject: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509certificate_t) -> *mut _cef_x509cert_principal_t,
    >,
    #[doc = "\n Returns the issuer of the X.509 certificate.\n"]
    pub get_issuer: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509certificate_t) -> *mut _cef_x509cert_principal_t,
    >,
    #[doc = "\n Returns the DER encoded serial number for the X.509 certificate. The value\n possibly includes a leading 00 byte.\n"]
    pub get_serial_number: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509certificate_t) -> *mut _cef_binary_value_t,
    >,
    #[doc = "\n Returns the date before which the X.509 certificate is invalid.\n CefTime.GetTimeT() will return 0 if no date was specified.\n"]
    pub get_valid_start: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509certificate_t) -> cef_time_t,
    >,
    #[doc = "\n Returns the date after which the X.509 certificate is invalid.\n CefTime.GetTimeT() will return 0 if no date was specified.\n"]
    pub get_valid_expiry: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509certificate_t) -> cef_time_t,
    >,
    #[doc = "\n Returns the DER encoded data for the X.509 certificate.\n"]
    pub get_derencoded: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509certificate_t) -> *mut _cef_binary_value_t,
    >,
    #[doc = "\n Returns the PEM encoded data for the X.509 certificate.\n"]
    pub get_pemencoded: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509certificate_t) -> *mut _cef_binary_value_t,
    >,
    #[doc = "\n Returns the number of certificates in the issuer chain. If 0, the\n certificate is self-signed.\n"]
    pub get_issuer_chain_size:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_x509certificate_t) -> usize>,
    #[doc = "\n Returns the DER encoded data for the certificate issuer chain. If we failed\n to encode a certificate in the chain it is still present in the array but\n is an NULL string.\n"]
    pub get_derencoded_issuer_chain: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_x509certificate_t,
            chainCount: *mut usize,
            chain: *mut *mut _cef_binary_value_t,
        ),
    >,
    #[doc = "\n Returns the PEM encoded data for the certificate issuer chain. If we failed\n to encode a certificate in the chain it is still present in the array but\n is an NULL string.\n"]
    pub get_pemencoded_issuer_chain: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_x509certificate_t,
            chainCount: *mut usize,
            chain: *mut *mut _cef_binary_value_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_x509certificate_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_x509certificate_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_x509certificate_t>(),
        120usize,
        concat!("Size of: ", stringify!(_cef_x509certificate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_x509certificate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_x509certificate_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_x509certificate_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_subject) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_x509certificate_t),
            "::",
            stringify!(get_subject)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_issuer) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_x509certificate_t),
            "::",
            stringify!(get_issuer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_serial_number) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_x509certificate_t),
            "::",
            stringify!(get_serial_number)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_valid_start) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_x509certificate_t),
            "::",
            stringify!(get_valid_start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_valid_expiry) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_x509certificate_t),
            "::",
            stringify!(get_valid_expiry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_derencoded) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_x509certificate_t),
            "::",
            stringify!(get_derencoded)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_pemencoded) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_x509certificate_t),
            "::",
            stringify!(get_pemencoded)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_issuer_chain_size) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_x509certificate_t),
            "::",
            stringify!(get_issuer_chain_size)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).get_derencoded_issuer_chain) as usize - ptr as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_x509certificate_t),
            "::",
            stringify!(get_derencoded_issuer_chain)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).get_pemencoded_issuer_chain) as usize - ptr as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_x509certificate_t),
            "::",
            stringify!(get_pemencoded_issuer_chain)
        )
    );
}
#[doc = "\n Structure representing a X.509 certificate.\n"]
pub type cef_x509certificate_t = _cef_x509certificate_t;
#[doc = "\n Structure representing the SSL information for a navigation entry.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_sslstatus_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Returns true (1) if the status is related to a secure SSL/TLS connection.\n"]
    pub is_secure_connection: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_sslstatus_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns a bitmask containing any and all problems verifying the server\n certificate.\n"]
    pub get_cert_status: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_sslstatus_t) -> cef_cert_status_t,
    >,
    #[doc = "\n Returns the SSL version used for the SSL connection.\n"]
    pub get_sslversion: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_sslstatus_t) -> cef_ssl_version_t,
    >,
    #[doc = "\n Returns a bitmask containing the page security content status.\n"]
    pub get_content_status: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_sslstatus_t) -> cef_ssl_content_status_t,
    >,
    #[doc = "\n Returns the X.509 certificate.\n"]
    pub get_x509certificate: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_sslstatus_t) -> *mut _cef_x509certificate_t,
    >,
}
#[test]
fn bindgen_test_layout__cef_sslstatus_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_sslstatus_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_sslstatus_t>(),
        80usize,
        concat!("Size of: ", stringify!(_cef_sslstatus_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_sslstatus_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_sslstatus_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_sslstatus_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_secure_connection) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_sslstatus_t),
            "::",
            stringify!(is_secure_connection)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_cert_status) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_sslstatus_t),
            "::",
            stringify!(get_cert_status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_sslversion) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_sslstatus_t),
            "::",
            stringify!(get_sslversion)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_content_status) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_sslstatus_t),
            "::",
            stringify!(get_content_status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_x509certificate) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_sslstatus_t),
            "::",
            stringify!(get_x509certificate)
        )
    );
}
#[doc = "\n Structure representing the SSL information for a navigation entry.\n"]
pub type cef_sslstatus_t = _cef_sslstatus_t;
#[doc = "\n Structure used to represent an entry in navigation history.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_navigation_entry_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Returns true (1) if this object is valid. Do not call any other functions\n if this function returns false (0).\n"]
    pub is_valid: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_navigation_entry_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the actual URL of the page. For some pages this may be data: URL or\n similar. Use get_display_url() to return a display-friendly version.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_url: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_navigation_entry_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns a display-friendly version of the URL.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_display_url: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_navigation_entry_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the original URL that was entered by the user before any redirects.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_original_url: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_navigation_entry_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the title set by the page. This value may be NULL.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_title: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_navigation_entry_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the transition type which indicates what the user did to move to\n this page from the previous page.\n"]
    pub get_transition_type: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_navigation_entry_t) -> cef_transition_type_t,
    >,
    #[doc = "\n Returns true (1) if this navigation includes post data.\n"]
    pub has_post_data: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_navigation_entry_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the time for the last known successful navigation completion. A\n navigation may be completed more than once if the page is reloaded. May be\n 0 if the navigation has not yet completed.\n"]
    pub get_completion_time: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_navigation_entry_t) -> cef_time_t,
    >,
    #[doc = "\n Returns the HTTP status code for the last known successful navigation\n response. May be 0 if the response has not yet been received or if the\n navigation has not yet completed.\n"]
    pub get_http_status_code: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_navigation_entry_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the SSL information for this navigation entry.\n"]
    pub get_sslstatus: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_navigation_entry_t) -> *mut _cef_sslstatus_t,
    >,
}
#[test]
fn bindgen_test_layout__cef_navigation_entry_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_navigation_entry_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_navigation_entry_t>(),
        120usize,
        concat!("Size of: ", stringify!(_cef_navigation_entry_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_navigation_entry_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_navigation_entry_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_navigation_entry_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_valid) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_navigation_entry_t),
            "::",
            stringify!(is_valid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_url) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_navigation_entry_t),
            "::",
            stringify!(get_url)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_display_url) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_navigation_entry_t),
            "::",
            stringify!(get_display_url)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_original_url) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_navigation_entry_t),
            "::",
            stringify!(get_original_url)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_title) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_navigation_entry_t),
            "::",
            stringify!(get_title)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_transition_type) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_navigation_entry_t),
            "::",
            stringify!(get_transition_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_post_data) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_navigation_entry_t),
            "::",
            stringify!(has_post_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_completion_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_navigation_entry_t),
            "::",
            stringify!(get_completion_time)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_http_status_code) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_navigation_entry_t),
            "::",
            stringify!(get_http_status_code)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_sslstatus) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_navigation_entry_t),
            "::",
            stringify!(get_sslstatus)
        )
    );
}
#[doc = "\n Structure used to represent an entry in navigation history.\n"]
pub type cef_navigation_entry_t = _cef_navigation_entry_t;
#[doc = "\n Generic callback structure used for managing the lifespan of a registration.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_registration_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
}
#[test]
fn bindgen_test_layout__cef_registration_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_registration_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_registration_t>(),
        40usize,
        concat!("Size of: ", stringify!(_cef_registration_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_registration_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_registration_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_registration_t),
            "::",
            stringify!(base)
        )
    );
}
#[doc = "\n Generic callback structure used for managing the lifespan of a registration.\n"]
pub type cef_registration_t = _cef_registration_t;
#[doc = "\n Generic callback structure used for asynchronous continuation.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_callback_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Continue processing.\n"]
    pub cont: ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_callback_t)>,
    #[doc = "\n Cancel processing.\n"]
    pub cancel: ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_callback_t)>,
}
#[test]
fn bindgen_test_layout__cef_callback_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_callback_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_callback_t>(),
        56usize,
        concat!("Size of: ", stringify!(_cef_callback_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_callback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_callback_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_callback_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cont) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_callback_t),
            "::",
            stringify!(cont)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cancel) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_callback_t),
            "::",
            stringify!(cancel)
        )
    );
}
#[doc = "\n Generic callback structure used for asynchronous continuation.\n"]
pub type cef_callback_t = _cef_callback_t;
#[doc = "\n Generic callback structure used for asynchronous completion.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_completion_callback_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Method that will be called once the task is complete.\n"]
    pub on_complete:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_completion_callback_t)>,
}
#[test]
fn bindgen_test_layout__cef_completion_callback_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_completion_callback_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_completion_callback_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_completion_callback_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_completion_callback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_completion_callback_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_completion_callback_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_complete) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_completion_callback_t),
            "::",
            stringify!(on_complete)
        )
    );
}
#[doc = "\n Generic callback structure used for asynchronous completion.\n"]
pub type cef_completion_callback_t = _cef_completion_callback_t;
#[doc = "\n Structure used for managing cookies. The functions of this structure may be\n called on any thread unless otherwise indicated.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_cookie_manager_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Visit all cookies on the UI thread. The returned cookies are ordered by\n longest path, then by earliest creation date. Returns false (0) if cookies\n cannot be accessed.\n"]
    pub visit_all_cookies: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_cookie_manager_t,
            visitor: *mut _cef_cookie_visitor_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Visit a subset of cookies on the UI thread. The results are filtered by the\n given url scheme, host, domain and path. If |includeHttpOnly| is true (1)\n HTTP-only cookies will also be included in the results. The returned\n cookies are ordered by longest path, then by earliest creation date.\n Returns false (0) if cookies cannot be accessed.\n"]
    pub visit_url_cookies: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_cookie_manager_t,
            url: *const cef_string_t,
            includeHttpOnly: ::core::ffi::c_int,
            visitor: *mut _cef_cookie_visitor_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Sets a cookie given a valid URL and explicit user-provided cookie\n attributes. This function expects each attribute to be well-formed. It will\n check for disallowed characters (e.g. the ';' character is disallowed\n within the cookie value attribute) and fail without setting the cookie if\n such characters are found. If |callback| is non-NULL it will be executed\n asnychronously on the UI thread after the cookie has been set. Returns\n false (0) if an invalid URL is specified or if cookies cannot be accessed.\n"]
    pub set_cookie: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_cookie_manager_t,
            url: *const cef_string_t,
            cookie: *const _cef_cookie_t,
            callback: *mut _cef_set_cookie_callback_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Delete all cookies that match the specified parameters. If both |url| and\n |cookie_name| values are specified all host and domain cookies matching\n both will be deleted. If only |url| is specified all host cookies (but not\n domain cookies) irrespective of path will be deleted. If |url| is NULL all\n cookies for all hosts and domains will be deleted. If |callback| is non-\n NULL it will be executed asnychronously on the UI thread after the cookies\n have been deleted. Returns false (0) if a non-NULL invalid URL is specified\n or if cookies cannot be accessed. Cookies can alternately be deleted using\n the Visit*Cookies() functions.\n"]
    pub delete_cookies: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_cookie_manager_t,
            url: *const cef_string_t,
            cookie_name: *const cef_string_t,
            callback: *mut _cef_delete_cookies_callback_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Flush the backing store (if any) to disk. If |callback| is non-NULL it will\n be executed asnychronously on the UI thread after the flush is complete.\n Returns false (0) if cookies cannot be accessed.\n"]
    pub flush_store: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_cookie_manager_t,
            callback: *mut _cef_completion_callback_t,
        ) -> ::core::ffi::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_cookie_manager_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_cookie_manager_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_cookie_manager_t>(),
        80usize,
        concat!("Size of: ", stringify!(_cef_cookie_manager_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_cookie_manager_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_cookie_manager_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_cookie_manager_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).visit_all_cookies) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_cookie_manager_t),
            "::",
            stringify!(visit_all_cookies)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).visit_url_cookies) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_cookie_manager_t),
            "::",
            stringify!(visit_url_cookies)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_cookie) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_cookie_manager_t),
            "::",
            stringify!(set_cookie)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).delete_cookies) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_cookie_manager_t),
            "::",
            stringify!(delete_cookies)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flush_store) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_cookie_manager_t),
            "::",
            stringify!(flush_store)
        )
    );
}
#[doc = "\n Structure used for managing cookies. The functions of this structure may be\n called on any thread unless otherwise indicated.\n"]
pub type cef_cookie_manager_t = _cef_cookie_manager_t;
#[doc = "\n Structure to implement for visiting cookie values. The functions of this\n structure will always be called on the UI thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_cookie_visitor_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Method that will be called once for each cookie. |count| is the 0-based\n index for the current cookie. |total| is the total number of cookies. Set\n |deleteCookie| to true (1) to delete the cookie currently being visited.\n Return false (0) to stop visiting cookies. This function may never be\n called if no cookies are found.\n"]
    pub visit: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_cookie_visitor_t,
            cookie: *const _cef_cookie_t,
            count: ::core::ffi::c_int,
            total: ::core::ffi::c_int,
            deleteCookie: *mut ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_cookie_visitor_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_cookie_visitor_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_cookie_visitor_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_cookie_visitor_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_cookie_visitor_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_cookie_visitor_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_cookie_visitor_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).visit) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_cookie_visitor_t),
            "::",
            stringify!(visit)
        )
    );
}
#[doc = "\n Structure to implement for visiting cookie values. The functions of this\n structure will always be called on the UI thread.\n"]
pub type cef_cookie_visitor_t = _cef_cookie_visitor_t;
#[doc = "\n Structure to implement to be notified of asynchronous completion via\n cef_cookie_manager_t::set_cookie().\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_set_cookie_callback_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Method that will be called upon completion. |success| will be true (1) if\n the cookie was set successfully.\n"]
    pub on_complete: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_set_cookie_callback_t, success: ::core::ffi::c_int),
    >,
}
#[test]
fn bindgen_test_layout__cef_set_cookie_callback_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_set_cookie_callback_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_set_cookie_callback_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_set_cookie_callback_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_set_cookie_callback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_set_cookie_callback_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_set_cookie_callback_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_complete) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_set_cookie_callback_t),
            "::",
            stringify!(on_complete)
        )
    );
}
#[doc = "\n Structure to implement to be notified of asynchronous completion via\n cef_cookie_manager_t::set_cookie().\n"]
pub type cef_set_cookie_callback_t = _cef_set_cookie_callback_t;
#[doc = "\n Structure to implement to be notified of asynchronous completion via\n cef_cookie_manager_t::delete_cookies().\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_delete_cookies_callback_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Method that will be called upon completion. |num_deleted| will be the\n number of cookies that were deleted.\n"]
    pub on_complete: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_delete_cookies_callback_t,
            num_deleted: ::core::ffi::c_int,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_delete_cookies_callback_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_delete_cookies_callback_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_delete_cookies_callback_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_delete_cookies_callback_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_delete_cookies_callback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_delete_cookies_callback_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_delete_cookies_callback_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_complete) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_delete_cookies_callback_t),
            "::",
            stringify!(on_complete)
        )
    );
}
#[doc = "\n Structure to implement to be notified of asynchronous completion via\n cef_cookie_manager_t::delete_cookies().\n"]
pub type cef_delete_cookies_callback_t = _cef_delete_cookies_callback_t;
#[doc = "\n Object representing an extension. Methods may be called on any thread unless\n otherwise indicated.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_extension_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Returns the unique extension identifier. This is calculated based on the\n extension public key, if available, or on the extension path. See\n https://developer.chrome.com/extensions/manifest/key for details.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_identifier: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_extension_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the absolute path to the extension directory on disk. This value\n will be prefixed with PK_DIR_RESOURCES if a relative path was passed to\n cef_request_context_t::LoadExtension.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_path: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_extension_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the extension manifest contents as a cef_dictionary_value_t object.\n See https://developer.chrome.com/extensions/manifest for details.\n"]
    pub get_manifest: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_extension_t) -> *mut _cef_dictionary_value_t,
    >,
    #[doc = "\n Returns true (1) if this object is the same extension as |that| object.\n Extensions are considered the same if identifier, path and loader context\n match.\n"]
    pub is_same: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_extension_t,
            that: *mut _cef_extension_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the handler for this extension. Will return NULL for internal\n extensions or if no handler was passed to\n cef_request_context_t::LoadExtension.\n"]
    pub get_handler: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_extension_t) -> *mut _cef_extension_handler_t,
    >,
    #[doc = "\n Returns the request context that loaded this extension. Will return NULL\n for internal extensions or if the extension has been unloaded. See the\n cef_request_context_t::LoadExtension documentation for more information\n about loader contexts. Must be called on the browser process UI thread.\n"]
    pub get_loader_context: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_extension_t) -> *mut _cef_request_context_t,
    >,
    #[doc = "\n Returns true (1) if this extension is currently loaded. Must be called on\n the browser process UI thread.\n"]
    pub is_loaded: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_extension_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Unload this extension if it is not an internal extension and is currently\n loaded. Will result in a call to\n cef_extension_handler_t::OnExtensionUnloaded on success.\n"]
    pub unload: ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_extension_t)>,
}
#[test]
fn bindgen_test_layout__cef_extension_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_extension_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_extension_t>(),
        104usize,
        concat!("Size of: ", stringify!(_cef_extension_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_extension_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_extension_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_extension_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_identifier) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_extension_t),
            "::",
            stringify!(get_identifier)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_path) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_extension_t),
            "::",
            stringify!(get_path)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_manifest) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_extension_t),
            "::",
            stringify!(get_manifest)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_same) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_extension_t),
            "::",
            stringify!(is_same)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_handler) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_extension_t),
            "::",
            stringify!(get_handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_loader_context) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_extension_t),
            "::",
            stringify!(get_loader_context)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_loaded) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_extension_t),
            "::",
            stringify!(is_loaded)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unload) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_extension_t),
            "::",
            stringify!(unload)
        )
    );
}
#[doc = "\n Object representing an extension. Methods may be called on any thread unless\n otherwise indicated.\n"]
pub type cef_extension_t = _cef_extension_t;
#[doc = "\n Callback structure used for asynchronous continuation of\n cef_extension_handler_t::GetExtensionResource.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_get_extension_resource_callback_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Continue the request. Read the resource contents from |stream|.\n"]
    pub cont: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_get_extension_resource_callback_t,
            stream: *mut _cef_stream_reader_t,
        ),
    >,
    #[doc = "\n Cancel the request.\n"]
    pub cancel: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_get_extension_resource_callback_t),
    >,
}
#[test]
fn bindgen_test_layout__cef_get_extension_resource_callback_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_get_extension_resource_callback_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_get_extension_resource_callback_t>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(_cef_get_extension_resource_callback_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_get_extension_resource_callback_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_cef_get_extension_resource_callback_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_get_extension_resource_callback_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cont) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_get_extension_resource_callback_t),
            "::",
            stringify!(cont)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cancel) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_get_extension_resource_callback_t),
            "::",
            stringify!(cancel)
        )
    );
}
#[doc = "\n Callback structure used for asynchronous continuation of\n cef_extension_handler_t::GetExtensionResource.\n"]
pub type cef_get_extension_resource_callback_t = _cef_get_extension_resource_callback_t;
#[doc = "\n Implement this structure to handle events related to browser extensions. The\n functions of this structure will be called on the UI thread. See\n cef_request_context_t::LoadExtension for information about extension loading.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_extension_handler_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Called if the cef_request_context_t::LoadExtension request fails. |result|\n will be the error code.\n"]
    pub on_extension_load_failed: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_extension_handler_t, result: cef_errorcode_t),
    >,
    #[doc = "\n Called if the cef_request_context_t::LoadExtension request succeeds.\n |extension| is the loaded extension.\n"]
    pub on_extension_loaded: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_extension_handler_t,
            extension: *mut _cef_extension_t,
        ),
    >,
    #[doc = "\n Called after the cef_extension_t::Unload request has completed.\n"]
    pub on_extension_unloaded: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_extension_handler_t,
            extension: *mut _cef_extension_t,
        ),
    >,
    #[doc = "\n Called when an extension needs a browser to host a background script\n specified via the \"background\" manifest key. The browser will have no\n visible window and cannot be displayed. |extension| is the extension that\n is loading the background script. |url| is an internally generated\n reference to an HTML page that will be used to load the background script\n via a <script> src attribute. To allow creation of the browser optionally\n modify |client| and |settings| and return false (0). To cancel creation of\n the browser (and consequently cancel load of the background script) return\n true (1). Successful creation will be indicated by a call to\n cef_life_span_handler_t::OnAfterCreated, and\n cef_browser_host_t::IsBackgroundHost will return true (1) for the resulting\n browser. See https://developer.chrome.com/extensions/event_pages for more\n information about extension background script usage.\n"]
    pub on_before_background_browser: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_extension_handler_t,
            extension: *mut _cef_extension_t,
            url: *const cef_string_t,
            client: *mut *mut _cef_client_t,
            settings: *mut _cef_browser_settings_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Called when an extension API (e.g. chrome.tabs.create) requests creation of\n a new browser. |extension| and |browser| are the source of the API call.\n |active_browser| may optionally be specified via the windowId property or\n returned via the get_active_browser() callback and provides the default\n |client| and |settings| values for the new browser. |index| is the position\n value optionally specified via the index property. |url| is the URL that\n will be loaded in the browser. |active| is true (1) if the new browser\n should be active when opened.  To allow creation of the browser optionally\n modify |windowInfo|, |client| and |settings| and return false (0). To\n cancel creation of the browser return true (1). Successful creation will be\n indicated by a call to cef_life_span_handler_t::OnAfterCreated. Any\n modifications to |windowInfo| will be ignored if |active_browser| is\n wrapped in a cef_browser_view_t.\n"]
    pub on_before_browser: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_extension_handler_t,
            extension: *mut _cef_extension_t,
            browser: *mut _cef_browser_t,
            active_browser: *mut _cef_browser_t,
            index: ::core::ffi::c_int,
            url: *const cef_string_t,
            active: ::core::ffi::c_int,
            windowInfo: *mut _cef_window_info_t,
            client: *mut *mut _cef_client_t,
            settings: *mut _cef_browser_settings_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Called when no tabId is specified to an extension API call that accepts a\n tabId parameter (e.g. chrome.tabs.*). |extension| and |browser| are the\n source of the API call. Return the browser that will be acted on by the API\n call or return NULL to act on |browser|. The returned browser must share\n the same cef_request_context_t as |browser|. Incognito browsers should not\n be considered unless the source extension has incognito access enabled, in\n which case |include_incognito| will be true (1).\n"]
    pub get_active_browser: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_extension_handler_t,
            extension: *mut _cef_extension_t,
            browser: *mut _cef_browser_t,
            include_incognito: ::core::ffi::c_int,
        ) -> *mut _cef_browser_t,
    >,
    #[doc = "\n Called when the tabId associated with |target_browser| is specified to an\n extension API call that accepts a tabId parameter (e.g. chrome.tabs.*).\n |extension| and |browser| are the source of the API call. Return true (1)\n to allow access of false (0) to deny access. Access to incognito browsers\n should not be allowed unless the source extension has incognito access\n enabled, in which case |include_incognito| will be true (1).\n"]
    pub can_access_browser: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_extension_handler_t,
            extension: *mut _cef_extension_t,
            browser: *mut _cef_browser_t,
            include_incognito: ::core::ffi::c_int,
            target_browser: *mut _cef_browser_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Called to retrieve an extension resource that would normally be loaded from\n disk (e.g. if a file parameter is specified to chrome.tabs.executeScript).\n |extension| and |browser| are the source of the resource request. |file| is\n the requested relative file path. To handle the resource request return\n true (1) and execute |callback| either synchronously or asynchronously. For\n the default behavior which reads the resource from the extension directory\n on disk return false (0). Localization substitutions will not be applied to\n resources handled via this function.\n"]
    pub get_extension_resource: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_extension_handler_t,
            extension: *mut _cef_extension_t,
            browser: *mut _cef_browser_t,
            file: *const cef_string_t,
            callback: *mut _cef_get_extension_resource_callback_t,
        ) -> ::core::ffi::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_extension_handler_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_extension_handler_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_extension_handler_t>(),
        104usize,
        concat!("Size of: ", stringify!(_cef_extension_handler_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_extension_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_extension_handler_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_extension_handler_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_extension_load_failed) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_extension_handler_t),
            "::",
            stringify!(on_extension_load_failed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_extension_loaded) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_extension_handler_t),
            "::",
            stringify!(on_extension_loaded)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_extension_unloaded) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_extension_handler_t),
            "::",
            stringify!(on_extension_unloaded)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).on_before_background_browser) as usize - ptr as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_extension_handler_t),
            "::",
            stringify!(on_before_background_browser)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_before_browser) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_extension_handler_t),
            "::",
            stringify!(on_before_browser)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_active_browser) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_extension_handler_t),
            "::",
            stringify!(get_active_browser)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).can_access_browser) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_extension_handler_t),
            "::",
            stringify!(can_access_browser)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_extension_resource) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_extension_handler_t),
            "::",
            stringify!(get_extension_resource)
        )
    );
}
#[doc = "\n Implement this structure to handle events related to browser extensions. The\n functions of this structure will be called on the UI thread. See\n cef_request_context_t::LoadExtension for information about extension loading.\n"]
pub type cef_extension_handler_t = _cef_extension_handler_t;
#[doc = "\n Supports discovery of and communication with media devices on the local\n network via the Cast and DIAL protocols. The functions of this structure may\n be called on any browser process thread unless otherwise indicated.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_media_router_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Add an observer for MediaRouter events. The observer will remain registered\n until the returned Registration object is destroyed.\n"]
    pub add_observer: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_media_router_t,
            observer: *mut _cef_media_observer_t,
        ) -> *mut _cef_registration_t,
    >,
    #[doc = "\n Returns a MediaSource object for the specified media source URN. Supported\n URN schemes include \"cast:\" and \"dial:\", and will be already known by the\n client application (e.g. \"cast:<appId>?clientId=<clientId>\").\n"]
    pub get_source: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_media_router_t,
            urn: *const cef_string_t,
        ) -> *mut _cef_media_source_t,
    >,
    #[doc = "\n Trigger an asynchronous call to cef_media_observer_t::OnSinks on all\n registered observers.\n"]
    pub notify_current_sinks:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_media_router_t)>,
    #[doc = "\n Create a new route between |source| and |sink|. Source and sink must be\n valid, compatible (as reported by cef_media_sink_t::IsCompatibleWith), and\n a route between them must not already exist. |callback| will be executed on\n success or failure. If route creation succeeds it will also trigger an\n asynchronous call to cef_media_observer_t::OnRoutes on all registered\n observers.\n"]
    pub create_route: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_media_router_t,
            source: *mut _cef_media_source_t,
            sink: *mut _cef_media_sink_t,
            callback: *mut _cef_media_route_create_callback_t,
        ),
    >,
    #[doc = "\n Trigger an asynchronous call to cef_media_observer_t::OnRoutes on all\n registered observers.\n"]
    pub notify_current_routes:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_media_router_t)>,
}
#[test]
fn bindgen_test_layout__cef_media_router_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_media_router_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_media_router_t>(),
        80usize,
        concat!("Size of: ", stringify!(_cef_media_router_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_media_router_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_media_router_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_media_router_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).add_observer) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_media_router_t),
            "::",
            stringify!(add_observer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_source) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_media_router_t),
            "::",
            stringify!(get_source)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).notify_current_sinks) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_media_router_t),
            "::",
            stringify!(notify_current_sinks)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).create_route) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_media_router_t),
            "::",
            stringify!(create_route)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).notify_current_routes) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_media_router_t),
            "::",
            stringify!(notify_current_routes)
        )
    );
}
#[doc = "\n Supports discovery of and communication with media devices on the local\n network via the Cast and DIAL protocols. The functions of this structure may\n be called on any browser process thread unless otherwise indicated.\n"]
pub type cef_media_router_t = _cef_media_router_t;
#[doc = "\n Implemented by the client to observe MediaRouter events and registered via\n cef_media_router_t::AddObserver. The functions of this structure will be\n called on the browser process UI thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_media_observer_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n The list of available media sinks has changed or\n cef_media_router_t::NotifyCurrentSinks was called.\n"]
    pub on_sinks: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_media_observer_t,
            sinksCount: usize,
            sinks: *const *mut _cef_media_sink_t,
        ),
    >,
    #[doc = "\n The list of available media routes has changed or\n cef_media_router_t::NotifyCurrentRoutes was called.\n"]
    pub on_routes: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_media_observer_t,
            routesCount: usize,
            routes: *const *mut _cef_media_route_t,
        ),
    >,
    #[doc = "\n The connection state of |route| has changed.\n"]
    pub on_route_state_changed: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_media_observer_t,
            route: *mut _cef_media_route_t,
            state: cef_media_route_connection_state_t,
        ),
    >,
    #[doc = "\n A message was recieved over |route|. |message| is only valid for the scope\n of this callback and should be copied if necessary.\n"]
    pub on_route_message_received: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_media_observer_t,
            route: *mut _cef_media_route_t,
            message: *const ::core::ffi::c_void,
            message_size: usize,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_media_observer_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_media_observer_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_media_observer_t>(),
        72usize,
        concat!("Size of: ", stringify!(_cef_media_observer_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_media_observer_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_media_observer_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_media_observer_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_sinks) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_media_observer_t),
            "::",
            stringify!(on_sinks)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_routes) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_media_observer_t),
            "::",
            stringify!(on_routes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_route_state_changed) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_media_observer_t),
            "::",
            stringify!(on_route_state_changed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_route_message_received) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_media_observer_t),
            "::",
            stringify!(on_route_message_received)
        )
    );
}
#[doc = "\n Implemented by the client to observe MediaRouter events and registered via\n cef_media_router_t::AddObserver. The functions of this structure will be\n called on the browser process UI thread.\n"]
pub type cef_media_observer_t = _cef_media_observer_t;
#[doc = "\n Represents the route between a media source and sink. Instances of this\n object are created via cef_media_router_t::CreateRoute and retrieved via\n cef_media_observer_t::OnRoutes. Contains the status and metadata of a routing\n operation. The functions of this structure may be called on any browser\n process thread unless otherwise indicated.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_media_route_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Returns the ID for this route.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_id: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_media_route_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the source associated with this route.\n"]
    pub get_source: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_media_route_t) -> *mut _cef_media_source_t,
    >,
    #[doc = "\n Returns the sink associated with this route.\n"]
    pub get_sink: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_media_route_t) -> *mut _cef_media_sink_t,
    >,
    #[doc = "\n Send a message over this route. |message| will be copied if necessary.\n"]
    pub send_route_message: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_media_route_t,
            message: *const ::core::ffi::c_void,
            message_size: usize,
        ),
    >,
    #[doc = "\n Terminate this route. Will result in an asynchronous call to\n cef_media_observer_t::OnRoutes on all registered observers.\n"]
    pub terminate: ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_media_route_t)>,
}
#[test]
fn bindgen_test_layout__cef_media_route_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_media_route_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_media_route_t>(),
        80usize,
        concat!("Size of: ", stringify!(_cef_media_route_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_media_route_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_media_route_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_media_route_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_id) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_media_route_t),
            "::",
            stringify!(get_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_source) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_media_route_t),
            "::",
            stringify!(get_source)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_sink) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_media_route_t),
            "::",
            stringify!(get_sink)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_route_message) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_media_route_t),
            "::",
            stringify!(send_route_message)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).terminate) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_media_route_t),
            "::",
            stringify!(terminate)
        )
    );
}
#[doc = "\n Represents the route between a media source and sink. Instances of this\n object are created via cef_media_router_t::CreateRoute and retrieved via\n cef_media_observer_t::OnRoutes. Contains the status and metadata of a routing\n operation. The functions of this structure may be called on any browser\n process thread unless otherwise indicated.\n"]
pub type cef_media_route_t = _cef_media_route_t;
#[doc = "\n Callback structure for cef_media_router_t::CreateRoute. The functions of this\n structure will be called on the browser process UI thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_media_route_create_callback_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Method that will be executed when the route creation has finished. |result|\n will be CEF_MRCR_OK if the route creation succeeded. |error| will be a\n description of the error if the route creation failed. |route| is the\n resulting route, or NULL if the route creation failed.\n"]
    pub on_media_route_create_finished: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_media_route_create_callback_t,
            result: cef_media_route_create_result_t,
            error: *const cef_string_t,
            route: *mut _cef_media_route_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_media_route_create_callback_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_media_route_create_callback_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_media_route_create_callback_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_media_route_create_callback_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_media_route_create_callback_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_cef_media_route_create_callback_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_media_route_create_callback_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).on_media_route_create_finished) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_media_route_create_callback_t),
            "::",
            stringify!(on_media_route_create_finished)
        )
    );
}
#[doc = "\n Callback structure for cef_media_router_t::CreateRoute. The functions of this\n structure will be called on the browser process UI thread.\n"]
pub type cef_media_route_create_callback_t = _cef_media_route_create_callback_t;
#[doc = "\n Represents a sink to which media can be routed. Instances of this object are\n retrieved via cef_media_observer_t::OnSinks. The functions of this structure\n may be called on any browser process thread unless otherwise indicated.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_media_sink_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Returns the ID for this sink.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_id: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_media_sink_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the name of this sink.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_name: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_media_sink_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the description of this sink.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_description: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_media_sink_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the icon type for this sink.\n"]
    pub get_icon_type: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_media_sink_t) -> cef_media_sink_icon_type_t,
    >,
    #[doc = "\n Asynchronously retrieves device info.\n"]
    pub get_device_info: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_media_sink_t,
            callback: *mut _cef_media_sink_device_info_callback_t,
        ),
    >,
    #[doc = "\n Returns true (1) if this sink accepts content via Cast.\n"]
    pub is_cast_sink: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_media_sink_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if this sink accepts content via DIAL.\n"]
    pub is_dial_sink: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_media_sink_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if this sink is compatible with |source|.\n"]
    pub is_compatible_with: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_media_sink_t,
            source: *mut _cef_media_source_t,
        ) -> ::core::ffi::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_media_sink_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_media_sink_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_media_sink_t>(),
        104usize,
        concat!("Size of: ", stringify!(_cef_media_sink_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_media_sink_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_media_sink_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_media_sink_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_id) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_media_sink_t),
            "::",
            stringify!(get_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_name) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_media_sink_t),
            "::",
            stringify!(get_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_description) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_media_sink_t),
            "::",
            stringify!(get_description)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_icon_type) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_media_sink_t),
            "::",
            stringify!(get_icon_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_device_info) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_media_sink_t),
            "::",
            stringify!(get_device_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_cast_sink) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_media_sink_t),
            "::",
            stringify!(is_cast_sink)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_dial_sink) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_media_sink_t),
            "::",
            stringify!(is_dial_sink)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_compatible_with) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_media_sink_t),
            "::",
            stringify!(is_compatible_with)
        )
    );
}
#[doc = "\n Represents a sink to which media can be routed. Instances of this object are\n retrieved via cef_media_observer_t::OnSinks. The functions of this structure\n may be called on any browser process thread unless otherwise indicated.\n"]
pub type cef_media_sink_t = _cef_media_sink_t;
#[doc = "\n Callback structure for cef_media_sink_t::GetDeviceInfo. The functions of this\n structure will be called on the browser process UI thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_media_sink_device_info_callback_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Method that will be executed asyncronously once device information has been\n retrieved.\n"]
    pub on_media_sink_device_info: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_media_sink_device_info_callback_t,
            device_info: *const _cef_media_sink_device_info_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_media_sink_device_info_callback_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_media_sink_device_info_callback_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_media_sink_device_info_callback_t>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_cef_media_sink_device_info_callback_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_media_sink_device_info_callback_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_cef_media_sink_device_info_callback_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_media_sink_device_info_callback_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_media_sink_device_info) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_media_sink_device_info_callback_t),
            "::",
            stringify!(on_media_sink_device_info)
        )
    );
}
#[doc = "\n Callback structure for cef_media_sink_t::GetDeviceInfo. The functions of this\n structure will be called on the browser process UI thread.\n"]
pub type cef_media_sink_device_info_callback_t = _cef_media_sink_device_info_callback_t;
#[doc = "\n Represents a source from which media can be routed. Instances of this object\n are retrieved via cef_media_router_t::GetSource. The functions of this\n structure may be called on any browser process thread unless otherwise\n indicated.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_media_source_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Returns the ID (media source URN or URL) for this source.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_id: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_media_source_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns true (1) if this source outputs its content via Cast.\n"]
    pub is_cast_source: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_media_source_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if this source outputs its content via DIAL.\n"]
    pub is_dial_source: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_media_source_t) -> ::core::ffi::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_media_source_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_media_source_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_media_source_t>(),
        64usize,
        concat!("Size of: ", stringify!(_cef_media_source_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_media_source_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_media_source_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_media_source_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_id) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_media_source_t),
            "::",
            stringify!(get_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_cast_source) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_media_source_t),
            "::",
            stringify!(is_cast_source)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_dial_source) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_media_source_t),
            "::",
            stringify!(is_dial_source)
        )
    );
}
#[doc = "\n Represents a source from which media can be routed. Instances of this object\n are retrieved via cef_media_router_t::GetSource. The functions of this\n structure may be called on any browser process thread unless otherwise\n indicated.\n"]
pub type cef_media_source_t = _cef_media_source_t;
#[doc = "\n Callback structure for cef_request_context_t::ResolveHost.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_resolve_callback_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Called on the UI thread after the ResolveHost request has completed.\n |result| will be the result code. |resolved_ips| will be the list of\n resolved IP addresses or NULL if the resolution failed.\n"]
    pub on_resolve_completed: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resolve_callback_t,
            result: cef_errorcode_t,
            resolved_ips: cef_string_list_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_resolve_callback_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_resolve_callback_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_resolve_callback_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_resolve_callback_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_resolve_callback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_resolve_callback_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_resolve_callback_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_resolve_completed) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_resolve_callback_t),
            "::",
            stringify!(on_resolve_completed)
        )
    );
}
#[doc = "\n Callback structure for cef_request_context_t::ResolveHost.\n"]
pub type cef_resolve_callback_t = _cef_resolve_callback_t;
#[doc = "\n A request context provides request handling for a set of related browser or\n URL request objects. A request context can be specified when creating a new\n browser via the cef_browser_host_t static factory functions or when creating\n a new URL request via the cef_urlrequest_t static factory functions. Browser\n objects with different request contexts will never be hosted in the same\n render process. Browser objects with the same request context may or may not\n be hosted in the same render process depending on the process model. Browser\n objects created indirectly via the JavaScript window.open function or\n targeted links will share the same render process and the same request\n context as the source browser. When running in single-process mode there is\n only a single render process (the main process) and so all browsers created\n in single-process mode will share the same request context. This will be the\n first request context passed into a cef_browser_host_t static factory\n function and all other request context objects will be ignored.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_request_context_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Returns true (1) if this object is pointing to the same context as |that|\n object.\n"]
    pub is_same: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            other: *mut _cef_request_context_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if this object is sharing the same storage as |that|\n object.\n"]
    pub is_sharing_with: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            other: *mut _cef_request_context_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if this object is the global context. The global context\n is used by default when creating a browser or URL request with a NULL\n context argument.\n"]
    pub is_global: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_context_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the handler for this context if any.\n"]
    pub get_handler: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
        ) -> *mut _cef_request_context_handler_t,
    >,
    #[doc = "\n Returns the cache path for this object. If NULL an \"incognito mode\" in-\n memory cache is being used.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_cache_path: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_context_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the cookie manager for this object. If |callback| is non-NULL it\n will be executed asnychronously on the UI thread after the manager's\n storage has been initialized.\n"]
    pub get_cookie_manager: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            callback: *mut _cef_completion_callback_t,
        ) -> *mut _cef_cookie_manager_t,
    >,
    #[doc = "\n Register a scheme handler factory for the specified |scheme_name| and\n optional |domain_name|. An NULL |domain_name| value for a standard scheme\n will cause the factory to match all domain names. The |domain_name| value\n will be ignored for non-standard schemes. If |scheme_name| is a built-in\n scheme and no handler is returned by |factory| then the built-in scheme\n handler factory will be called. If |scheme_name| is a custom scheme then\n you must also implement the cef_app_t::on_register_custom_schemes()\n function in all processes. This function may be called multiple times to\n change or remove the factory that matches the specified |scheme_name| and\n optional |domain_name|. Returns false (0) if an error occurs. This function\n may be called on any thread in the browser process.\n"]
    pub register_scheme_handler_factory: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            scheme_name: *const cef_string_t,
            domain_name: *const cef_string_t,
            factory: *mut _cef_scheme_handler_factory_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Clear all registered scheme handler factories. Returns false (0) on error.\n This function may be called on any thread in the browser process.\n"]
    pub clear_scheme_handler_factories: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_context_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Tells all renderer processes associated with this context to throw away\n their plugin list cache. If |reload_pages| is true (1) they will also\n reload all pages with plugins.\n cef_request_context_handler_t::OnBeforePluginLoad may be called to rebuild\n the plugin list cache.\n"]
    pub purge_plugin_list_cache: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_context_t, reload_pages: ::core::ffi::c_int),
    >,
    #[doc = "\n Returns true (1) if a preference with the specified |name| exists. This\n function must be called on the browser process UI thread.\n"]
    pub has_preference: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            name: *const cef_string_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the value for the preference with the specified |name|. Returns\n NULL if the preference does not exist. The returned object contains a copy\n of the underlying preference value and modifications to the returned object\n will not modify the underlying preference value. This function must be\n called on the browser process UI thread.\n"]
    pub get_preference: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            name: *const cef_string_t,
        ) -> *mut _cef_value_t,
    >,
    #[doc = "\n Returns all preferences as a dictionary. If |include_defaults| is true (1)\n then preferences currently at their default value will be included. The\n returned object contains a copy of the underlying preference values and\n modifications to the returned object will not modify the underlying\n preference values. This function must be called on the browser process UI\n thread.\n"]
    pub get_all_preferences: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            include_defaults: ::core::ffi::c_int,
        ) -> *mut _cef_dictionary_value_t,
    >,
    #[doc = "\n Returns true (1) if the preference with the specified |name| can be\n modified using SetPreference. As one example preferences set via the\n command-line usually cannot be modified. This function must be called on\n the browser process UI thread.\n"]
    pub can_set_preference: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            name: *const cef_string_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Set the |value| associated with preference |name|. Returns true (1) if the\n value is set successfully and false (0) otherwise. If |value| is NULL the\n preference will be restored to its default value. If setting the preference\n fails then |error| will be populated with a detailed description of the\n problem. This function must be called on the browser process UI thread.\n"]
    pub set_preference: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            name: *const cef_string_t,
            value: *mut _cef_value_t,
            error: *mut cef_string_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Clears all certificate exceptions that were added as part of handling\n cef_request_handler_t::on_certificate_error(). If you call this it is\n recommended that you also call close_all_connections() or you risk not\n being prompted again for server certificates if you reconnect quickly. If\n |callback| is non-NULL it will be executed on the UI thread after\n completion.\n"]
    pub clear_certificate_exceptions: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            callback: *mut _cef_completion_callback_t,
        ),
    >,
    #[doc = "\n Clears all HTTP authentication credentials that were added as part of\n handling GetAuthCredentials. If |callback| is non-NULL it will be executed\n on the UI thread after completion.\n"]
    pub clear_http_auth_credentials: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            callback: *mut _cef_completion_callback_t,
        ),
    >,
    #[doc = "\n Clears all active and idle connections that Chromium currently has. This is\n only recommended if you have released all other CEF objects but don't yet\n want to call cef_shutdown(). If |callback| is non-NULL it will be executed\n on the UI thread after completion.\n"]
    pub close_all_connections: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            callback: *mut _cef_completion_callback_t,
        ),
    >,
    #[doc = "\n Attempts to resolve |origin| to a list of associated IP addresses.\n |callback| will be executed on the UI thread after completion.\n"]
    pub resolve_host: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            origin: *const cef_string_t,
            callback: *mut _cef_resolve_callback_t,
        ),
    >,
    #[doc = "\n Load an extension.\n\n If extension resources will be read from disk using the default load\n implementation then |root_directory| should be the absolute path to the\n extension resources directory and |manifest| should be NULL. If extension\n resources will be provided by the client (e.g. via cef_request_handler_t\n and/or cef_extension_handler_t) then |root_directory| should be a path\n component unique to the extension (if not absolute this will be internally\n prefixed with the PK_DIR_RESOURCES path) and |manifest| should contain the\n contents that would otherwise be read from the \"manifest.json\" file on\n disk.\n\n The loaded extension will be accessible in all contexts sharing the same\n storage (HasExtension returns true (1)). However, only the context on which\n this function was called is considered the loader (DidLoadExtension returns\n true (1)) and only the loader will receive cef_request_context_handler_t\n callbacks for the extension.\n\n cef_extension_handler_t::OnExtensionLoaded will be called on load success\n or cef_extension_handler_t::OnExtensionLoadFailed will be called on load\n failure.\n\n If the extension specifies a background script via the \"background\"\n manifest key then cef_extension_handler_t::OnBeforeBackgroundBrowser will\n be called to create the background browser. See that function for\n additional information about background scripts.\n\n For visible extension views the client application should evaluate the\n manifest to determine the correct extension URL to load and then pass that\n URL to the cef_browser_host_t::CreateBrowser* function after the extension\n has loaded. For example, the client can look for the \"browser_action\"\n manifest key as documented at\n https://developer.chrome.com/extensions/browserAction. Extension URLs take\n the form \"chrome-extension://<extension_id>/<path>\".\n\n Browsers that host extensions differ from normal browsers as follows:\n  - Can access chrome.* JavaScript APIs if allowed by the manifest. Visit\n    chrome://extensions-support for the list of extension APIs currently\n    supported by CEF.\n  - Main frame navigation to non-extension content is blocked.\n  - Pinch-zooming is disabled.\n  - CefBrowserHost::GetExtension returns the hosted extension.\n  - CefBrowserHost::IsBackgroundHost returns true for background hosts.\n\n See https://developer.chrome.com/extensions for extension implementation\n and usage documentation.\n"]
    pub load_extension: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            root_directory: *const cef_string_t,
            manifest: *mut _cef_dictionary_value_t,
            handler: *mut _cef_extension_handler_t,
        ),
    >,
    #[doc = "\n Returns true (1) if this context was used to load the extension identified\n by |extension_id|. Other contexts sharing the same storage will also have\n access to the extension (see HasExtension). This function must be called on\n the browser process UI thread.\n"]
    pub did_load_extension: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            extension_id: *const cef_string_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if this context has access to the extension identified by\n |extension_id|. This may not be the context that was used to load the\n extension (see DidLoadExtension). This function must be called on the\n browser process UI thread.\n"]
    pub has_extension: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            extension_id: *const cef_string_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Retrieve the list of all extensions that this context has access to (see\n HasExtension). |extension_ids| will be populated with the list of extension\n ID values. Returns true (1) on success. This function must be called on the\n browser process UI thread.\n"]
    pub get_extensions: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            extension_ids: cef_string_list_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the extension matching |extension_id| or NULL if no matching\n extension is accessible in this context (see HasExtension). This function\n must be called on the browser process UI thread.\n"]
    pub get_extension: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            extension_id: *const cef_string_t,
        ) -> *mut _cef_extension_t,
    >,
    #[doc = "\n Returns the MediaRouter object associated with this context.  If |callback|\n is non-NULL it will be executed asnychronously on the UI thread after the\n manager's context has been initialized.\n"]
    pub get_media_router: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            callback: *mut _cef_completion_callback_t,
        ) -> *mut _cef_media_router_t,
    >,
}
#[test]
fn bindgen_test_layout__cef_request_context_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_request_context_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_request_context_t>(),
        232usize,
        concat!("Size of: ", stringify!(_cef_request_context_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_request_context_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_request_context_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_context_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_same) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_context_t),
            "::",
            stringify!(is_same)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_sharing_with) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_context_t),
            "::",
            stringify!(is_sharing_with)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_global) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_context_t),
            "::",
            stringify!(is_global)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_handler) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_context_t),
            "::",
            stringify!(get_handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_cache_path) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_context_t),
            "::",
            stringify!(get_cache_path)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_cookie_manager) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_context_t),
            "::",
            stringify!(get_cookie_manager)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).register_scheme_handler_factory) as usize - ptr as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_context_t),
            "::",
            stringify!(register_scheme_handler_factory)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).clear_scheme_handler_factories) as usize - ptr as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_context_t),
            "::",
            stringify!(clear_scheme_handler_factories)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).purge_plugin_list_cache) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_context_t),
            "::",
            stringify!(purge_plugin_list_cache)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_preference) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_context_t),
            "::",
            stringify!(has_preference)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_preference) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_context_t),
            "::",
            stringify!(get_preference)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_all_preferences) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_context_t),
            "::",
            stringify!(get_all_preferences)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).can_set_preference) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_context_t),
            "::",
            stringify!(can_set_preference)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_preference) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_context_t),
            "::",
            stringify!(set_preference)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).clear_certificate_exceptions) as usize - ptr as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_context_t),
            "::",
            stringify!(clear_certificate_exceptions)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).clear_http_auth_credentials) as usize - ptr as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_context_t),
            "::",
            stringify!(clear_http_auth_credentials)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).close_all_connections) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_context_t),
            "::",
            stringify!(close_all_connections)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).resolve_host) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_context_t),
            "::",
            stringify!(resolve_host)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).load_extension) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_context_t),
            "::",
            stringify!(load_extension)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).did_load_extension) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_context_t),
            "::",
            stringify!(did_load_extension)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_extension) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_context_t),
            "::",
            stringify!(has_extension)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_extensions) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_context_t),
            "::",
            stringify!(get_extensions)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_extension) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_context_t),
            "::",
            stringify!(get_extension)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_media_router) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_context_t),
            "::",
            stringify!(get_media_router)
        )
    );
}
#[doc = "\n A request context provides request handling for a set of related browser or\n URL request objects. A request context can be specified when creating a new\n browser via the cef_browser_host_t static factory functions or when creating\n a new URL request via the cef_urlrequest_t static factory functions. Browser\n objects with different request contexts will never be hosted in the same\n render process. Browser objects with the same request context may or may not\n be hosted in the same render process depending on the process model. Browser\n objects created indirectly via the JavaScript window.open function or\n targeted links will share the same render process and the same request\n context as the source browser. When running in single-process mode there is\n only a single render process (the main process) and so all browsers created\n in single-process mode will share the same request context. This will be the\n first request context passed into a cef_browser_host_t static factory\n function and all other request context objects will be ignored.\n"]
pub type cef_request_context_t = _cef_request_context_t;
#[doc = "\n Structure used to represent a browser window. When used in the browser\n process the functions of this structure may be called on any thread unless\n otherwise indicated in the comments. When used in the render process the\n functions of this structure may only be called on the main thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_browser_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Returns the browser host object. This function can only be called in the\n browser process.\n"]
    pub get_host: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_t) -> *mut _cef_browser_host_t,
    >,
    #[doc = "\n Returns true (1) if the browser can navigate backwards.\n"]
    pub can_go_back: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Navigate backwards.\n"]
    pub go_back: ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_t)>,
    #[doc = "\n Returns true (1) if the browser can navigate forwards.\n"]
    pub can_go_forward: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Navigate forwards.\n"]
    pub go_forward: ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_t)>,
    #[doc = "\n Returns true (1) if the browser is currently loading.\n"]
    pub is_loading: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Reload the current page.\n"]
    pub reload: ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_t)>,
    #[doc = "\n Reload the current page ignoring any cached data.\n"]
    pub reload_ignore_cache:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_t)>,
    #[doc = "\n Stop loading the page.\n"]
    pub stop_load: ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_t)>,
    #[doc = "\n Returns the globally unique identifier for this browser. This value is also\n used as the tabId for extension APIs.\n"]
    pub get_identifier: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if this object is pointing to the same handle as |that|\n object.\n"]
    pub is_same: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_t,
            that: *mut _cef_browser_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if the window is a popup window.\n"]
    pub is_popup: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if a document has been loaded in the browser.\n"]
    pub has_document: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the main (top-level) frame for the browser window. In the browser\n process this will return a valid object until after\n cef_life_span_handler_t::OnBeforeClose is called. In the renderer process\n this will return NULL if the main frame is hosted in a different renderer\n process (e.g. for cross-origin sub-frames).\n"]
    pub get_main_frame: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_t) -> *mut _cef_frame_t,
    >,
    #[doc = "\n Returns the focused frame for the browser window.\n"]
    pub get_focused_frame: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_t) -> *mut _cef_frame_t,
    >,
    #[doc = "\n Returns the frame with the specified identifier, or NULL if not found.\n"]
    pub get_frame_byident: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_t, identifier: int64) -> *mut _cef_frame_t,
    >,
    #[doc = "\n Returns the frame with the specified name, or NULL if not found.\n"]
    pub get_frame: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_t,
            name: *const cef_string_t,
        ) -> *mut _cef_frame_t,
    >,
    #[doc = "\n Returns the number of frames that currently exist.\n"]
    pub get_frame_count:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_t) -> usize>,
    #[doc = "\n Returns the identifiers of all existing frames.\n"]
    pub get_frame_identifiers: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_t,
            identifiersCount: *mut usize,
            identifiers: *mut int64,
        ),
    >,
    #[doc = "\n Returns the names of all existing frames.\n"]
    pub get_frame_names: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_t, names: cef_string_list_t),
    >,
}
#[test]
fn bindgen_test_layout__cef_browser_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_browser_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_browser_t>(),
        200usize,
        concat!("Size of: ", stringify!(_cef_browser_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_browser_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_browser_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_host) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_t),
            "::",
            stringify!(get_host)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).can_go_back) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_t),
            "::",
            stringify!(can_go_back)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).go_back) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_t),
            "::",
            stringify!(go_back)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).can_go_forward) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_t),
            "::",
            stringify!(can_go_forward)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).go_forward) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_t),
            "::",
            stringify!(go_forward)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_loading) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_t),
            "::",
            stringify!(is_loading)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reload) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_t),
            "::",
            stringify!(reload)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reload_ignore_cache) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_t),
            "::",
            stringify!(reload_ignore_cache)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stop_load) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_t),
            "::",
            stringify!(stop_load)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_identifier) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_t),
            "::",
            stringify!(get_identifier)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_same) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_t),
            "::",
            stringify!(is_same)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_popup) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_t),
            "::",
            stringify!(is_popup)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_document) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_t),
            "::",
            stringify!(has_document)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_main_frame) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_t),
            "::",
            stringify!(get_main_frame)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_focused_frame) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_t),
            "::",
            stringify!(get_focused_frame)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_frame_byident) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_t),
            "::",
            stringify!(get_frame_byident)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_frame) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_t),
            "::",
            stringify!(get_frame)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_frame_count) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_t),
            "::",
            stringify!(get_frame_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_frame_identifiers) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_t),
            "::",
            stringify!(get_frame_identifiers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_frame_names) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_t),
            "::",
            stringify!(get_frame_names)
        )
    );
}
#[doc = "\n Structure used to represent a browser window. When used in the browser\n process the functions of this structure may be called on any thread unless\n otherwise indicated in the comments. When used in the render process the\n functions of this structure may only be called on the main thread.\n"]
pub type cef_browser_t = _cef_browser_t;
#[doc = "\n Callback structure for cef_browser_host_t::RunFileDialog. The functions of\n this structure will be called on the browser process UI thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_run_file_dialog_callback_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Called asynchronously after the file dialog is dismissed.\n |selected_accept_filter| is the 0-based index of the value selected from\n the accept filters array passed to cef_browser_host_t::RunFileDialog.\n |file_paths| will be a single value or a list of values depending on the\n dialog mode. If the selection was cancelled |file_paths| will be NULL.\n"]
    pub on_file_dialog_dismissed: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_run_file_dialog_callback_t,
            selected_accept_filter: ::core::ffi::c_int,
            file_paths: cef_string_list_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_run_file_dialog_callback_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_run_file_dialog_callback_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_run_file_dialog_callback_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_run_file_dialog_callback_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_run_file_dialog_callback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_run_file_dialog_callback_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_run_file_dialog_callback_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_file_dialog_dismissed) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_run_file_dialog_callback_t),
            "::",
            stringify!(on_file_dialog_dismissed)
        )
    );
}
#[doc = "\n Callback structure for cef_browser_host_t::RunFileDialog. The functions of\n this structure will be called on the browser process UI thread.\n"]
pub type cef_run_file_dialog_callback_t = _cef_run_file_dialog_callback_t;
#[doc = "\n Callback structure for cef_browser_host_t::GetNavigationEntries. The\n functions of this structure will be called on the browser process UI thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_navigation_entry_visitor_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Method that will be executed. Do not keep a reference to |entry| outside of\n this callback. Return true (1) to continue visiting entries or false (0) to\n stop. |current| is true (1) if this entry is the currently loaded\n navigation entry. |index| is the 0-based index of this entry and |total| is\n the total number of entries.\n"]
    pub visit: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_navigation_entry_visitor_t,
            entry: *mut _cef_navigation_entry_t,
            current: ::core::ffi::c_int,
            index: ::core::ffi::c_int,
            total: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_navigation_entry_visitor_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_navigation_entry_visitor_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_navigation_entry_visitor_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_navigation_entry_visitor_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_navigation_entry_visitor_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_navigation_entry_visitor_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_navigation_entry_visitor_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).visit) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_navigation_entry_visitor_t),
            "::",
            stringify!(visit)
        )
    );
}
#[doc = "\n Callback structure for cef_browser_host_t::GetNavigationEntries. The\n functions of this structure will be called on the browser process UI thread.\n"]
pub type cef_navigation_entry_visitor_t = _cef_navigation_entry_visitor_t;
#[doc = "\n Callback structure for cef_browser_host_t::PrintToPDF. The functions of this\n structure will be called on the browser process UI thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_pdf_print_callback_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Method that will be executed when the PDF printing has completed. |path| is\n the output path. |ok| will be true (1) if the printing completed\n successfully or false (0) otherwise.\n"]
    pub on_pdf_print_finished: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_pdf_print_callback_t,
            path: *const cef_string_t,
            ok: ::core::ffi::c_int,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_pdf_print_callback_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_pdf_print_callback_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_pdf_print_callback_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_pdf_print_callback_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_pdf_print_callback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_pdf_print_callback_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_pdf_print_callback_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_pdf_print_finished) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_pdf_print_callback_t),
            "::",
            stringify!(on_pdf_print_finished)
        )
    );
}
#[doc = "\n Callback structure for cef_browser_host_t::PrintToPDF. The functions of this\n structure will be called on the browser process UI thread.\n"]
pub type cef_pdf_print_callback_t = _cef_pdf_print_callback_t;
#[doc = "\n Callback structure for cef_browser_host_t::DownloadImage. The functions of\n this structure will be called on the browser process UI thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_download_image_callback_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Method that will be executed when the image download has completed.\n |image_url| is the URL that was downloaded and |http_status_code| is the\n resulting HTTP status code. |image| is the resulting image, possibly at\n multiple scale factors, or NULL if the download failed.\n"]
    pub on_download_image_finished: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_download_image_callback_t,
            image_url: *const cef_string_t,
            http_status_code: ::core::ffi::c_int,
            image: *mut _cef_image_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_download_image_callback_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_download_image_callback_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_download_image_callback_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_download_image_callback_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_download_image_callback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_download_image_callback_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_download_image_callback_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_download_image_finished) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_download_image_callback_t),
            "::",
            stringify!(on_download_image_finished)
        )
    );
}
#[doc = "\n Callback structure for cef_browser_host_t::DownloadImage. The functions of\n this structure will be called on the browser process UI thread.\n"]
pub type cef_download_image_callback_t = _cef_download_image_callback_t;
#[doc = "\n Structure used to represent the browser process aspects of a browser window.\n The functions of this structure can only be called in the browser process.\n They may be called on any thread in that process unless otherwise indicated\n in the comments.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_browser_host_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Returns the hosted browser object.\n"]
    pub get_browser: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t) -> *mut _cef_browser_t,
    >,
    #[doc = "\n Request that the browser close. The JavaScript 'onbeforeunload' event will\n be fired. If |force_close| is false (0) the event handler, if any, will be\n allowed to prompt the user and the user can optionally cancel the close. If\n |force_close| is true (1) the prompt will not be displayed and the close\n will proceed. Results in a call to cef_life_span_handler_t::do_close() if\n the event handler allows the close or if |force_close| is true (1). See\n cef_life_span_handler_t::do_close() documentation for additional usage\n information.\n"]
    pub close_browser: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, force_close: ::core::ffi::c_int),
    >,
    #[doc = "\n Helper for closing a browser. Call this function from the top-level window\n close handler. Internally this calls CloseBrowser(false (0)) if the close\n has not yet been initiated. This function returns false (0) while the close\n is pending and true (1) after the close has completed. See close_browser()\n and cef_life_span_handler_t::do_close() documentation for additional usage\n information. This function must be called on the browser process UI thread.\n"]
    pub try_close_browser: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Set whether the browser is focused.\n"]
    pub set_focus: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, focus: ::core::ffi::c_int),
    >,
    #[doc = "\n Retrieve the window handle for this browser. If this browser is wrapped in\n a cef_browser_view_t this function should be called on the browser process\n UI thread and it will return the handle for the top-level native window.\n"]
    pub get_window_handle:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_host_t) -> HWND>,
    #[doc = "\n Retrieve the window handle of the browser that opened this browser. Will\n return NULL for non-popup windows or if this browser is wrapped in a\n cef_browser_view_t. This function can be used in combination with custom\n handling of modal windows.\n"]
    pub get_opener_window_handle:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_host_t) -> HWND>,
    #[doc = "\n Returns true (1) if this browser is wrapped in a cef_browser_view_t.\n"]
    pub has_view: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the client for this browser.\n"]
    pub get_client: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t) -> *mut _cef_client_t,
    >,
    #[doc = "\n Returns the request context for this browser.\n"]
    pub get_request_context: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t) -> *mut _cef_request_context_t,
    >,
    #[doc = "\n Get the current zoom level. The default zoom level is 0.0. This function\n can only be called on the UI thread.\n"]
    pub get_zoom_level:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_host_t) -> f64>,
    #[doc = "\n Change the zoom level to the specified value. Specify 0.0 to reset the zoom\n level. If called on the UI thread the change will be applied immediately.\n Otherwise, the change will be applied asynchronously on the UI thread.\n"]
    pub set_zoom_level: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, zoomLevel: f64),
    >,
    #[doc = "\n Call to run a file chooser dialog. Only a single file chooser dialog may be\n pending at any given time. |mode| represents the type of dialog to display.\n |title| to the title to be used for the dialog and may be NULL to show the\n default title (\"Open\" or \"Save\" depending on the mode). |default_file_path|\n is the path with optional directory and/or file name component that will be\n initially selected in the dialog. |accept_filters| are used to restrict the\n selectable file types and may any combination of (a) valid lower-cased MIME\n types (e.g. \"text/*\" or \"image/*\"), (b) individual file extensions (e.g.\n \".txt\" or \".png\"), or (c) combined description and file extension delimited\n using \"|\" and \";\" (e.g. \"Image Types|.png;.gif;.jpg\").\n |selected_accept_filter| is the 0-based index of the filter that will be\n selected by default. |callback| will be executed after the dialog is\n dismissed or immediately if another dialog is already pending. The dialog\n will be initiated asynchronously on the UI thread.\n"]
    pub run_file_dialog: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            mode: cef_file_dialog_mode_t,
            title: *const cef_string_t,
            default_file_path: *const cef_string_t,
            accept_filters: cef_string_list_t,
            selected_accept_filter: ::core::ffi::c_int,
            callback: *mut _cef_run_file_dialog_callback_t,
        ),
    >,
    #[doc = "\n Download the file at |url| using cef_download_handler_t.\n"]
    pub start_download: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, url: *const cef_string_t),
    >,
    #[doc = "\n Download |image_url| and execute |callback| on completion with the images\n received from the renderer. If |is_favicon| is true (1) then cookies are\n not sent and not accepted during download. Images with density independent\n pixel (DIP) sizes larger than |max_image_size| are filtered out from the\n image results. Versions of the image at different scale factors may be\n downloaded up to the maximum scale factor supported by the system. If there\n are no image results <= |max_image_size| then the smallest image is resized\n to |max_image_size| and is the only result. A |max_image_size| of 0 means\n unlimited. If |bypass_cache| is true (1) then |image_url| is requested from\n the server even if it is present in the browser cache.\n"]
    pub download_image: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            image_url: *const cef_string_t,
            is_favicon: ::core::ffi::c_int,
            max_image_size: uint32,
            bypass_cache: ::core::ffi::c_int,
            callback: *mut _cef_download_image_callback_t,
        ),
    >,
    #[doc = "\n Print the current browser contents.\n"]
    pub print: ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_host_t)>,
    #[doc = "\n Print the current browser contents to the PDF file specified by |path| and\n execute |callback| on completion. The caller is responsible for deleting\n |path| when done. For PDF printing to work on Linux you must implement the\n cef_print_handler_t::GetPdfPaperSize function.\n"]
    pub print_to_pdf: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            path: *const cef_string_t,
            settings: *const _cef_pdf_print_settings_t,
            callback: *mut _cef_pdf_print_callback_t,
        ),
    >,
    #[doc = "\n Search for |searchText|. |identifier| must be a unique ID and these IDs\n must strictly increase so that newer requests always have greater IDs than\n older requests. If |identifier| is zero or less than the previous ID value\n then it will be automatically assigned a new valid ID. |forward| indicates\n whether to search forward or backward within the page. |matchCase|\n indicates whether the search should be case-sensitive. |findNext| indicates\n whether this is the first request or a follow-up. The cef_find_handler_t\n instance, if any, returned via cef_client_t::GetFindHandler will be called\n to report find results.\n"]
    pub find: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            identifier: ::core::ffi::c_int,
            searchText: *const cef_string_t,
            forward: ::core::ffi::c_int,
            matchCase: ::core::ffi::c_int,
            findNext: ::core::ffi::c_int,
        ),
    >,
    #[doc = "\n Cancel all searches that are currently going on.\n"]
    pub stop_finding: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, clearSelection: ::core::ffi::c_int),
    >,
    #[doc = "\n Open developer tools (DevTools) in its own browser. The DevTools browser\n will remain associated with this browser. If the DevTools browser is\n already open then it will be focused, in which case the |windowInfo|,\n |client| and |settings| parameters will be ignored. If |inspect_element_at|\n is non-NULL then the element at the specified (x,y) location will be\n inspected. The |windowInfo| parameter will be ignored if this browser is\n wrapped in a cef_browser_view_t.\n"]
    pub show_dev_tools: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            windowInfo: *const _cef_window_info_t,
            client: *mut _cef_client_t,
            settings: *const _cef_browser_settings_t,
            inspect_element_at: *const cef_point_t,
        ),
    >,
    #[doc = "\n Explicitly close the associated DevTools browser, if any.\n"]
    pub close_dev_tools:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_host_t)>,
    #[doc = "\n Returns true (1) if this browser currently has an associated DevTools\n browser. Must be called on the browser process UI thread.\n"]
    pub has_dev_tools: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Send a function call message over the DevTools protocol. |message| must be\n a UTF8-encoded JSON dictionary that contains \"id\" (int), \"function\"\n (string) and \"params\" (dictionary, optional) values. See the DevTools\n protocol documentation at https://chromedevtools.github.io/devtools-\n protocol/ for details of supported functions and the expected \"params\"\n dictionary contents. |message| will be copied if necessary. This function\n will return true (1) if called on the UI thread and the message was\n successfully submitted for validation, otherwise false (0). Validation will\n be applied asynchronously and any messages that fail due to formatting\n errors or missing parameters may be discarded without notification. Prefer\n ExecuteDevToolsMethod if a more structured approach to message formatting\n is desired.\n\n Every valid function call will result in an asynchronous function result or\n error message that references the sent message \"id\". Event messages are\n received while notifications are enabled (for example, between function\n calls for \"Page.enable\" and \"Page.disable\"). All received messages will be\n delivered to the observer(s) registered with AddDevToolsMessageObserver.\n See cef_dev_tools_message_observer_t::OnDevToolsMessage documentation for\n details of received message contents.\n\n Usage of the SendDevToolsMessage, ExecuteDevToolsMethod and\n AddDevToolsMessageObserver functions does not require an active DevTools\n front-end or remote-debugging session. Other active DevTools sessions will\n continue to function independently. However, any modification of global\n browser state by one session may not be reflected in the UI of other\n sessions.\n\n Communication with the DevTools front-end (when displayed) can be logged\n for development purposes by passing the `--devtools-protocol-log-\n file=<path>` command-line flag.\n"]
    pub send_dev_tools_message: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            message: *const ::core::ffi::c_void,
            message_size: usize,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Execute a function call over the DevTools protocol. This is a more\n structured version of SendDevToolsMessage. |message_id| is an incremental\n number that uniquely identifies the message (pass 0 to have the next number\n assigned automatically based on previous values). |function| is the\n function name. |params| are the function parameters, which may be NULL. See\n the DevTools protocol documentation (linked above) for details of supported\n functions and the expected |params| dictionary contents. This function will\n return the assigned message ID if called on the UI thread and the message\n was successfully submitted for validation, otherwise 0. See the\n SendDevToolsMessage documentation for additional usage information.\n"]
    pub execute_dev_tools_method: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            message_id: ::core::ffi::c_int,
            method: *const cef_string_t,
            params: *mut _cef_dictionary_value_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Add an observer for DevTools protocol messages (function results and\n events). The observer will remain registered until the returned\n Registration object is destroyed. See the SendDevToolsMessage documentation\n for additional usage information.\n"]
    pub add_dev_tools_message_observer: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            observer: *mut _cef_dev_tools_message_observer_t,
        ) -> *mut _cef_registration_t,
    >,
    #[doc = "\n Retrieve a snapshot of current navigation entries as values sent to the\n specified visitor. If |current_only| is true (1) only the current\n navigation entry will be sent, otherwise all navigation entries will be\n sent.\n"]
    pub get_navigation_entries: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            visitor: *mut _cef_navigation_entry_visitor_t,
            current_only: ::core::ffi::c_int,
        ),
    >,
    #[doc = "\n If a misspelled word is currently selected in an editable node calling this\n function will replace it with the specified |word|.\n"]
    pub replace_misspelling: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, word: *const cef_string_t),
    >,
    #[doc = "\n Add the specified |word| to the spelling dictionary.\n"]
    pub add_word_to_dictionary: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, word: *const cef_string_t),
    >,
    #[doc = "\n Returns true (1) if window rendering is disabled.\n"]
    pub is_window_rendering_disabled: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Notify the browser that the widget has been resized. The browser will first\n call cef_render_handler_t::GetViewRect to get the new size and then call\n cef_render_handler_t::OnPaint asynchronously with the updated regions. This\n function is only used when window rendering is disabled.\n"]
    pub was_resized: ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_host_t)>,
    #[doc = "\n Notify the browser that it has been hidden or shown. Layouting and\n cef_render_handler_t::OnPaint notification will stop when the browser is\n hidden. This function is only used when window rendering is disabled.\n"]
    pub was_hidden: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, hidden: ::core::ffi::c_int),
    >,
    #[doc = "\n Send a notification to the browser that the screen info has changed. The\n browser will then call cef_render_handler_t::GetScreenInfo to update the\n screen information with the new values. This simulates moving the webview\n window from one display to another, or changing the properties of the\n current display. This function is only used when window rendering is\n disabled.\n"]
    pub notify_screen_info_changed:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_host_t)>,
    #[doc = "\n Invalidate the view. The browser will call cef_render_handler_t::OnPaint\n asynchronously. This function is only used when window rendering is\n disabled.\n"]
    pub invalidate: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, type_: cef_paint_element_type_t),
    >,
    #[doc = "\n Issue a BeginFrame request to Chromium.  Only valid when\n cef_window_tInfo::external_begin_frame_enabled is set to true (1).\n"]
    pub send_external_begin_frame:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_host_t)>,
    #[doc = "\n Send a key event to the browser.\n"]
    pub send_key_event: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, event: *const _cef_key_event_t),
    >,
    #[doc = "\n Send a mouse click event to the browser. The |x| and |y| coordinates are\n relative to the upper-left corner of the view.\n"]
    pub send_mouse_click_event: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            event: *const _cef_mouse_event_t,
            type_: cef_mouse_button_type_t,
            mouseUp: ::core::ffi::c_int,
            clickCount: ::core::ffi::c_int,
        ),
    >,
    #[doc = "\n Send a mouse move event to the browser. The |x| and |y| coordinates are\n relative to the upper-left corner of the view.\n"]
    pub send_mouse_move_event: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            event: *const _cef_mouse_event_t,
            mouseLeave: ::core::ffi::c_int,
        ),
    >,
    #[doc = "\n Send a mouse wheel event to the browser. The |x| and |y| coordinates are\n relative to the upper-left corner of the view. The |deltaX| and |deltaY|\n values represent the movement delta in the X and Y directions respectively.\n In order to scroll inside select popups with window rendering disabled\n cef_render_handler_t::GetScreenPoint should be implemented properly.\n"]
    pub send_mouse_wheel_event: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            event: *const _cef_mouse_event_t,
            deltaX: ::core::ffi::c_int,
            deltaY: ::core::ffi::c_int,
        ),
    >,
    #[doc = "\n Send a touch event to the browser for a windowless browser.\n"]
    pub send_touch_event: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, event: *const _cef_touch_event_t),
    >,
    #[doc = "\n Send a focus event to the browser.\n"]
    pub send_focus_event: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, setFocus: ::core::ffi::c_int),
    >,
    #[doc = "\n Send a capture lost event to the browser.\n"]
    pub send_capture_lost_event:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_host_t)>,
    #[doc = "\n Notify the browser that the window hosting it is about to be moved or\n resized. This function is only used on Windows and Linux.\n"]
    pub notify_move_or_resize_started:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_host_t)>,
    #[doc = "\n Returns the maximum rate in frames per second (fps) that\n cef_render_handler_t:: OnPaint will be called for a windowless browser. The\n actual fps may be lower if the browser cannot generate frames at the\n requested rate. The minimum value is 1 and the maximum value is 60 (default\n 30). This function can only be called on the UI thread.\n"]
    pub get_windowless_frame_rate: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Set the maximum rate in frames per second (fps) that cef_render_handler_t::\n OnPaint will be called for a windowless browser. The actual fps may be\n lower if the browser cannot generate frames at the requested rate. The\n minimum value is 1 and the maximum value is 60 (default 30). Can also be\n set at browser creation via cef_browser_tSettings.windowless_frame_rate.\n"]
    pub set_windowless_frame_rate: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, frame_rate: ::core::ffi::c_int),
    >,
    #[doc = "\n Begins a new composition or updates the existing composition. Blink has a\n special node (a composition node) that allows the input function to change\n text without affecting other DOM nodes. |text| is the optional text that\n will be inserted into the composition node. |underlines| is an optional set\n of ranges that will be underlined in the resulting text.\n |replacement_range| is an optional range of the existing text that will be\n replaced. |selection_range| is an optional range of the resulting text that\n will be selected after insertion or replacement. The |replacement_range|\n value is only used on OS X.\n\n This function may be called multiple times as the composition changes. When\n the client is done making changes the composition should either be canceled\n or completed. To cancel the composition call ImeCancelComposition. To\n complete the composition call either ImeCommitText or\n ImeFinishComposingText. Completion is usually signaled when:\n   A. The client receives a WM_IME_COMPOSITION message with a GCS_RESULTSTR\n      flag (on Windows), or;\n   B. The client receives a \"commit\" signal of GtkIMContext (on Linux), or;\n   C. insertText of NSTextInput is called (on Mac).\n\n This function is only used when window rendering is disabled.\n"]
    pub ime_set_composition: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            text: *const cef_string_t,
            underlinesCount: usize,
            underlines: *const cef_composition_underline_t,
            replacement_range: *const cef_range_t,
            selection_range: *const cef_range_t,
        ),
    >,
    #[doc = "\n Completes the existing composition by optionally inserting the specified\n |text| into the composition node. |replacement_range| is an optional range\n of the existing text that will be replaced. |relative_cursor_pos| is where\n the cursor will be positioned relative to the current cursor position. See\n comments on ImeSetComposition for usage. The |replacement_range| and\n |relative_cursor_pos| values are only used on OS X. This function is only\n used when window rendering is disabled.\n"]
    pub ime_commit_text: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            text: *const cef_string_t,
            replacement_range: *const cef_range_t,
            relative_cursor_pos: ::core::ffi::c_int,
        ),
    >,
    #[doc = "\n Completes the existing composition by applying the current composition node\n contents. If |keep_selection| is false (0) the current selection, if any,\n will be discarded. See comments on ImeSetComposition for usage. This\n function is only used when window rendering is disabled.\n"]
    pub ime_finish_composing_text: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, keep_selection: ::core::ffi::c_int),
    >,
    #[doc = "\n Cancels the existing composition and discards the composition node contents\n without applying them. See comments on ImeSetComposition for usage. This\n function is only used when window rendering is disabled.\n"]
    pub ime_cancel_composition:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_host_t)>,
    #[doc = "\n Call this function when the user drags the mouse into the web view (before\n calling DragTargetDragOver/DragTargetLeave/DragTargetDrop). |drag_data|\n should not contain file contents as this type of data is not allowed to be\n dragged into the web view. File contents can be removed using\n cef_drag_data_t::ResetFileContents (for example, if |drag_data| comes from\n cef_render_handler_t::StartDragging). This function is only used when\n window rendering is disabled.\n"]
    pub drag_target_drag_enter: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            drag_data: *mut _cef_drag_data_t,
            event: *const _cef_mouse_event_t,
            allowed_ops: cef_drag_operations_mask_t,
        ),
    >,
    #[doc = "\n Call this function each time the mouse is moved across the web view during\n a drag operation (after calling DragTargetDragEnter and before calling\n DragTargetDragLeave/DragTargetDrop). This function is only used when window\n rendering is disabled.\n"]
    pub drag_target_drag_over: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            event: *const _cef_mouse_event_t,
            allowed_ops: cef_drag_operations_mask_t,
        ),
    >,
    #[doc = "\n Call this function when the user drags the mouse out of the web view (after\n calling DragTargetDragEnter). This function is only used when window\n rendering is disabled.\n"]
    pub drag_target_drag_leave:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_host_t)>,
    #[doc = "\n Call this function when the user completes the drag operation by dropping\n the object onto the web view (after calling DragTargetDragEnter). The\n object being dropped is |drag_data|, given as an argument to the previous\n DragTargetDragEnter call. This function is only used when window rendering\n is disabled.\n"]
    pub drag_target_drop: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, event: *const _cef_mouse_event_t),
    >,
    #[doc = "\n Call this function when the drag operation started by a\n cef_render_handler_t::StartDragging call has ended either in a drop or by\n being cancelled. |x| and |y| are mouse coordinates relative to the upper-\n left corner of the view. If the web view is both the drag source and the\n drag target then all DragTarget* functions should be called before\n DragSource* mthods. This function is only used when window rendering is\n disabled.\n"]
    pub drag_source_ended_at: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            x: ::core::ffi::c_int,
            y: ::core::ffi::c_int,
            op: cef_drag_operations_mask_t,
        ),
    >,
    #[doc = "\n Call this function when the drag operation started by a\n cef_render_handler_t::StartDragging call has completed. This function may\n be called immediately without first calling DragSourceEndedAt to cancel a\n drag operation. If the web view is both the drag source and the drag target\n then all DragTarget* functions should be called before DragSource* mthods.\n This function is only used when window rendering is disabled.\n"]
    pub drag_source_system_drag_ended:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_host_t)>,
    #[doc = "\n Returns the current visible navigation entry for this browser. This\n function can only be called on the UI thread.\n"]
    pub get_visible_navigation_entry: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t) -> *mut _cef_navigation_entry_t,
    >,
    #[doc = "\n Set accessibility state for all frames. |accessibility_state| may be\n default, enabled or disabled. If |accessibility_state| is STATE_DEFAULT\n then accessibility will be disabled by default and the state may be further\n controlled with the \"force-renderer-accessibility\" and \"disable-renderer-\n accessibility\" command-line switches. If |accessibility_state| is\n STATE_ENABLED then accessibility will be enabled. If |accessibility_state|\n is STATE_DISABLED then accessibility will be completely disabled.\n\n For windowed browsers accessibility will be enabled in Complete mode (which\n corresponds to kAccessibilityModeComplete in Chromium). In this mode all\n platform accessibility objects will be created and managed by Chromium's\n internal implementation. The client needs only to detect the screen reader\n and call this function appropriately. For example, on macOS the client can\n handle the @\"AXEnhancedUserStructure\" accessibility attribute to detect\n VoiceOver state changes and on Windows the client can handle WM_GETOBJECT\n with OBJID_CLIENT to detect accessibility readers.\n\n For windowless browsers accessibility will be enabled in TreeOnly mode\n (which corresponds to kAccessibilityModeWebContentsOnly in Chromium). In\n this mode renderer accessibility is enabled, the full tree is computed, and\n events are passed to CefAccessibiltyHandler, but platform accessibility\n objects are not created. The client may implement platform accessibility\n objects using CefAccessibiltyHandler callbacks if desired.\n"]
    pub set_accessibility_state: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, accessibility_state: cef_state_t),
    >,
    #[doc = "\n Enable notifications of auto resize via\n cef_display_handler_t::OnAutoResize. Notifications are disabled by default.\n |min_size| and |max_size| define the range of allowed sizes.\n"]
    pub set_auto_resize_enabled: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            enabled: ::core::ffi::c_int,
            min_size: *const cef_size_t,
            max_size: *const cef_size_t,
        ),
    >,
    #[doc = "\n Returns the extension hosted in this browser or NULL if no extension is\n hosted. See cef_request_context_t::LoadExtension for details.\n"]
    pub get_extension: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t) -> *mut _cef_extension_t,
    >,
    #[doc = "\n Returns true (1) if this browser is hosting an extension background script.\n Background hosts do not have a window and are not displayable. See\n cef_request_context_t::LoadExtension for details.\n"]
    pub is_background_host: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n  Set whether the browser's audio is muted.\n"]
    pub set_audio_muted: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, mute: ::core::ffi::c_int),
    >,
    #[doc = "\n Returns true (1) if the browser's audio is muted.  This function can only\n be called on the UI thread.\n"]
    pub is_audio_muted: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t) -> ::core::ffi::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_browser_host_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_browser_host_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_browser_host_t>(),
        520usize,
        concat!("Size of: ", stringify!(_cef_browser_host_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_browser_host_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_browser_host_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_browser) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(get_browser)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).close_browser) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(close_browser)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).try_close_browser) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(try_close_browser)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_focus) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(set_focus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_window_handle) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(get_window_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_opener_window_handle) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(get_opener_window_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_view) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(has_view)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_client) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(get_client)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_request_context) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(get_request_context)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_zoom_level) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(get_zoom_level)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_zoom_level) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(set_zoom_level)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).run_file_dialog) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(run_file_dialog)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start_download) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(start_download)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).download_image) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(download_image)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).print) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(print)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).print_to_pdf) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(print_to_pdf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).find) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(find)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stop_finding) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(stop_finding)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).show_dev_tools) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(show_dev_tools)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).close_dev_tools) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(close_dev_tools)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_dev_tools) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(has_dev_tools)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_dev_tools_message) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(send_dev_tools_message)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).execute_dev_tools_method) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(execute_dev_tools_method)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).add_dev_tools_message_observer) as usize - ptr as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(add_dev_tools_message_observer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_navigation_entries) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(get_navigation_entries)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).replace_misspelling) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(replace_misspelling)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).add_word_to_dictionary) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(add_word_to_dictionary)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).is_window_rendering_disabled) as usize - ptr as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(is_window_rendering_disabled)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).was_resized) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(was_resized)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).was_hidden) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(was_hidden)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).notify_screen_info_changed) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(notify_screen_info_changed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).invalidate) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(invalidate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_external_begin_frame) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(send_external_begin_frame)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_key_event) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(send_key_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_mouse_click_event) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(send_mouse_click_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_mouse_move_event) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(send_mouse_move_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_mouse_wheel_event) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(send_mouse_wheel_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_touch_event) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(send_touch_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_focus_event) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(send_focus_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_capture_lost_event) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(send_capture_lost_event)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).notify_move_or_resize_started) as usize - ptr as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(notify_move_or_resize_started)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_windowless_frame_rate) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(get_windowless_frame_rate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_windowless_frame_rate) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(set_windowless_frame_rate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ime_set_composition) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(ime_set_composition)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ime_commit_text) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(ime_commit_text)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ime_finish_composing_text) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(ime_finish_composing_text)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ime_cancel_composition) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(ime_cancel_composition)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).drag_target_drag_enter) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(drag_target_drag_enter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).drag_target_drag_over) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(drag_target_drag_over)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).drag_target_drag_leave) as usize - ptr as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(drag_target_drag_leave)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).drag_target_drop) as usize - ptr as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(drag_target_drop)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).drag_source_ended_at) as usize - ptr as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(drag_source_ended_at)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).drag_source_system_drag_ended) as usize - ptr as usize
        },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(drag_source_system_drag_ended)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).get_visible_navigation_entry) as usize - ptr as usize
        },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(get_visible_navigation_entry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_accessibility_state) as usize - ptr as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(set_accessibility_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_auto_resize_enabled) as usize - ptr as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(set_auto_resize_enabled)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_extension) as usize - ptr as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(get_extension)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_background_host) as usize - ptr as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(is_background_host)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_audio_muted) as usize - ptr as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(set_audio_muted)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_audio_muted) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_host_t),
            "::",
            stringify!(is_audio_muted)
        )
    );
}
#[doc = "\n Structure used to represent the browser process aspects of a browser window.\n The functions of this structure can only be called in the browser process.\n They may be called on any thread in that process unless otherwise indicated\n in the comments.\n"]
pub type cef_browser_host_t = _cef_browser_host_t;
#[doc = "\n Implement this structure to handle audio events.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_audio_handler_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Called on the UI thread to allow configuration of audio stream parameters.\n Return true (1) to proceed with audio stream capture, or false (0) to\n cancel it. All members of |params| can optionally be configured here, but\n they are also pre-filled with some sensible defaults.\n"]
    pub get_audio_parameters: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_audio_handler_t,
            browser: *mut _cef_browser_t,
            params: *mut cef_audio_parameters_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Called on a browser audio capture thread when the browser starts streaming\n audio. OnAudioSteamStopped will always be called after\n OnAudioStreamStarted; both functions may be called multiple times for the\n same browser. |params| contains the audio parameters like sample rate and\n channel layout. |channels| is the number of channels.\n"]
    pub on_audio_stream_started: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_audio_handler_t,
            browser: *mut _cef_browser_t,
            params: *const cef_audio_parameters_t,
            channels: ::core::ffi::c_int,
        ),
    >,
    #[doc = "\n Called on the audio stream thread when a PCM packet is received for the\n stream. |data| is an array representing the raw PCM data as a floating\n point type, i.e. 4-byte value(s). |frames| is the number of frames in the\n PCM packet. |pts| is the presentation timestamp (in milliseconds since the\n Unix Epoch) and represents the time at which the decompressed packet should\n be presented to the user. Based on |frames| and the |channel_layout| value\n passed to OnAudioStreamStarted you can calculate the size of the |data|\n array in bytes.\n"]
    pub on_audio_stream_packet: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_audio_handler_t,
            browser: *mut _cef_browser_t,
            data: *mut *const f32,
            frames: ::core::ffi::c_int,
            pts: int64,
        ),
    >,
    #[doc = "\n Called on the UI thread when the stream has stopped. OnAudioSteamStopped\n will always be called after OnAudioStreamStarted; both functions may be\n called multiple times for the same stream.\n"]
    pub on_audio_stream_stopped: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_audio_handler_t, browser: *mut _cef_browser_t),
    >,
    #[doc = "\n Called on the UI or audio stream thread when an error occurred. During the\n stream creation phase this callback will be called on the UI thread while\n in the capturing phase it will be called on the audio stream thread. The\n stream will be stopped immediately.\n"]
    pub on_audio_stream_error: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_audio_handler_t,
            browser: *mut _cef_browser_t,
            message: *const cef_string_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_audio_handler_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_audio_handler_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_audio_handler_t>(),
        80usize,
        concat!("Size of: ", stringify!(_cef_audio_handler_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_audio_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_audio_handler_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_audio_handler_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_audio_parameters) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_audio_handler_t),
            "::",
            stringify!(get_audio_parameters)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_audio_stream_started) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_audio_handler_t),
            "::",
            stringify!(on_audio_stream_started)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_audio_stream_packet) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_audio_handler_t),
            "::",
            stringify!(on_audio_stream_packet)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_audio_stream_stopped) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_audio_handler_t),
            "::",
            stringify!(on_audio_stream_stopped)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_audio_stream_error) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_audio_handler_t),
            "::",
            stringify!(on_audio_stream_error)
        )
    );
}
#[doc = "\n Implement this structure to handle audio events.\n"]
pub type cef_audio_handler_t = _cef_audio_handler_t;
#[doc = "\n Implement this structure to handle menu model events. The functions of this\n structure will be called on the browser process UI thread unless otherwise\n indicated.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_menu_model_delegate_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Perform the action associated with the specified |command_id| and optional\n |event_flags|.\n"]
    pub execute_command: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_delegate_t,
            menu_model: *mut _cef_menu_model_t,
            command_id: ::core::ffi::c_int,
            event_flags: cef_event_flags_t,
        ),
    >,
    #[doc = "\n Called when the user moves the mouse outside the menu and over the owning\n window.\n"]
    pub mouse_outside_menu: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_delegate_t,
            menu_model: *mut _cef_menu_model_t,
            screen_point: *const cef_point_t,
        ),
    >,
    #[doc = "\n Called on unhandled open submenu keyboard commands. |is_rtl| will be true\n (1) if the menu is displaying a right-to-left language.\n"]
    pub unhandled_open_submenu: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_delegate_t,
            menu_model: *mut _cef_menu_model_t,
            is_rtl: ::core::ffi::c_int,
        ),
    >,
    #[doc = "\n Called on unhandled close submenu keyboard commands. |is_rtl| will be true\n (1) if the menu is displaying a right-to-left language.\n"]
    pub unhandled_close_submenu: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_delegate_t,
            menu_model: *mut _cef_menu_model_t,
            is_rtl: ::core::ffi::c_int,
        ),
    >,
    #[doc = "\n The menu is about to show.\n"]
    pub menu_will_show: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_delegate_t,
            menu_model: *mut _cef_menu_model_t,
        ),
    >,
    #[doc = "\n The menu has closed.\n"]
    pub menu_closed: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_delegate_t,
            menu_model: *mut _cef_menu_model_t,
        ),
    >,
    #[doc = "\n Optionally modify a menu item label. Return true (1) if |label| was\n modified.\n"]
    pub format_label: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_delegate_t,
            menu_model: *mut _cef_menu_model_t,
            label: *mut cef_string_t,
        ) -> ::core::ffi::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_menu_model_delegate_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_menu_model_delegate_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_menu_model_delegate_t>(),
        96usize,
        concat!("Size of: ", stringify!(_cef_menu_model_delegate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_menu_model_delegate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_menu_model_delegate_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_delegate_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).execute_command) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_delegate_t),
            "::",
            stringify!(execute_command)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mouse_outside_menu) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_delegate_t),
            "::",
            stringify!(mouse_outside_menu)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unhandled_open_submenu) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_delegate_t),
            "::",
            stringify!(unhandled_open_submenu)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unhandled_close_submenu) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_delegate_t),
            "::",
            stringify!(unhandled_close_submenu)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).menu_will_show) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_delegate_t),
            "::",
            stringify!(menu_will_show)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).menu_closed) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_delegate_t),
            "::",
            stringify!(menu_closed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).format_label) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_delegate_t),
            "::",
            stringify!(format_label)
        )
    );
}
#[doc = "\n Implement this structure to handle menu model events. The functions of this\n structure will be called on the browser process UI thread unless otherwise\n indicated.\n"]
pub type cef_menu_model_delegate_t = _cef_menu_model_delegate_t;
#[doc = "\n Supports creation and modification of menus. See cef_menu_id_t for the\n command ids that have default implementations. All user-defined command ids\n should be between MENU_ID_USER_FIRST and MENU_ID_USER_LAST. The functions of\n this structure can only be accessed on the browser process the UI thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_menu_model_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Returns true (1) if this menu is a submenu.\n"]
    pub is_sub_menu: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_menu_model_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Clears the menu. Returns true (1) on success.\n"]
    pub clear: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_menu_model_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the number of items in this menu.\n"]
    pub get_count: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_menu_model_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Add a separator to the menu. Returns true (1) on success.\n"]
    pub add_separator: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_menu_model_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Add an item to the menu. Returns true (1) on success.\n"]
    pub add_item: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::core::ffi::c_int,
            label: *const cef_string_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Add a check item to the menu. Returns true (1) on success.\n"]
    pub add_check_item: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::core::ffi::c_int,
            label: *const cef_string_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Add a radio item to the menu. Only a single item with the specified\n |group_id| can be checked at a time. Returns true (1) on success.\n"]
    pub add_radio_item: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::core::ffi::c_int,
            label: *const cef_string_t,
            group_id: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Add a sub-menu to the menu. The new sub-menu is returned.\n"]
    pub add_sub_menu: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::core::ffi::c_int,
            label: *const cef_string_t,
        ) -> *mut _cef_menu_model_t,
    >,
    #[doc = "\n Insert a separator in the menu at the specified |index|. Returns true (1)\n on success.\n"]
    pub insert_separator_at: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Insert an item in the menu at the specified |index|. Returns true (1) on\n success.\n"]
    pub insert_item_at: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::core::ffi::c_int,
            command_id: ::core::ffi::c_int,
            label: *const cef_string_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Insert a check item in the menu at the specified |index|. Returns true (1)\n on success.\n"]
    pub insert_check_item_at: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::core::ffi::c_int,
            command_id: ::core::ffi::c_int,
            label: *const cef_string_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Insert a radio item in the menu at the specified |index|. Only a single\n item with the specified |group_id| can be checked at a time. Returns true\n (1) on success.\n"]
    pub insert_radio_item_at: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::core::ffi::c_int,
            command_id: ::core::ffi::c_int,
            label: *const cef_string_t,
            group_id: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Insert a sub-menu in the menu at the specified |index|. The new sub-menu is\n returned.\n"]
    pub insert_sub_menu_at: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::core::ffi::c_int,
            command_id: ::core::ffi::c_int,
            label: *const cef_string_t,
        ) -> *mut _cef_menu_model_t,
    >,
    #[doc = "\n Removes the item with the specified |command_id|. Returns true (1) on\n success.\n"]
    pub remove: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Removes the item at the specified |index|. Returns true (1) on success.\n"]
    pub remove_at: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the index associated with the specified |command_id| or -1 if not\n found due to the command id not existing in the menu.\n"]
    pub get_index_of: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the command id at the specified |index| or -1 if not found due to\n invalid range or the index being a separator.\n"]
    pub get_command_id_at: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Sets the command id at the specified |index|. Returns true (1) on success.\n"]
    pub set_command_id_at: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::core::ffi::c_int,
            command_id: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the label for the specified |command_id| or NULL if not found.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_label: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::core::ffi::c_int,
        ) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the label at the specified |index| or NULL if not found due to\n invalid range or the index being a separator.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_label_at: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::core::ffi::c_int,
        ) -> cef_string_userfree_t,
    >,
    #[doc = "\n Sets the label for the specified |command_id|. Returns true (1) on success.\n"]
    pub set_label: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::core::ffi::c_int,
            label: *const cef_string_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Set the label at the specified |index|. Returns true (1) on success.\n"]
    pub set_label_at: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::core::ffi::c_int,
            label: *const cef_string_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the item type for the specified |command_id|.\n"]
    pub get_type: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::core::ffi::c_int,
        ) -> cef_menu_item_type_t,
    >,
    #[doc = "\n Returns the item type at the specified |index|.\n"]
    pub get_type_at: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::core::ffi::c_int,
        ) -> cef_menu_item_type_t,
    >,
    #[doc = "\n Returns the group id for the specified |command_id| or -1 if invalid.\n"]
    pub get_group_id: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the group id at the specified |index| or -1 if invalid.\n"]
    pub get_group_id_at: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Sets the group id for the specified |command_id|. Returns true (1) on\n success.\n"]
    pub set_group_id: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::core::ffi::c_int,
            group_id: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Sets the group id at the specified |index|. Returns true (1) on success.\n"]
    pub set_group_id_at: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::core::ffi::c_int,
            group_id: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the submenu for the specified |command_id| or NULL if invalid.\n"]
    pub get_sub_menu: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::core::ffi::c_int,
        ) -> *mut _cef_menu_model_t,
    >,
    #[doc = "\n Returns the submenu at the specified |index| or NULL if invalid.\n"]
    pub get_sub_menu_at: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::core::ffi::c_int,
        ) -> *mut _cef_menu_model_t,
    >,
    #[doc = "\n Returns true (1) if the specified |command_id| is visible.\n"]
    pub is_visible: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if the specified |index| is visible.\n"]
    pub is_visible_at: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Change the visibility of the specified |command_id|. Returns true (1) on\n success.\n"]
    pub set_visible: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::core::ffi::c_int,
            visible: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Change the visibility at the specified |index|. Returns true (1) on\n success.\n"]
    pub set_visible_at: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::core::ffi::c_int,
            visible: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if the specified |command_id| is enabled.\n"]
    pub is_enabled: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if the specified |index| is enabled.\n"]
    pub is_enabled_at: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Change the enabled status of the specified |command_id|. Returns true (1)\n on success.\n"]
    pub set_enabled: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::core::ffi::c_int,
            enabled: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Change the enabled status at the specified |index|. Returns true (1) on\n success.\n"]
    pub set_enabled_at: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::core::ffi::c_int,
            enabled: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if the specified |command_id| is checked. Only applies to\n check and radio items.\n"]
    pub is_checked: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if the specified |index| is checked. Only applies to check\n and radio items.\n"]
    pub is_checked_at: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Check the specified |command_id|. Only applies to check and radio items.\n Returns true (1) on success.\n"]
    pub set_checked: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::core::ffi::c_int,
            checked: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Check the specified |index|. Only applies to check and radio items. Returns\n true (1) on success.\n"]
    pub set_checked_at: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::core::ffi::c_int,
            checked: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if the specified |command_id| has a keyboard accelerator\n assigned.\n"]
    pub has_accelerator: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if the specified |index| has a keyboard accelerator\n assigned.\n"]
    pub has_accelerator_at: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Set the keyboard accelerator for the specified |command_id|. |key_code| can\n be any virtual key or character value. Returns true (1) on success.\n"]
    pub set_accelerator: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::core::ffi::c_int,
            key_code: ::core::ffi::c_int,
            shift_pressed: ::core::ffi::c_int,
            ctrl_pressed: ::core::ffi::c_int,
            alt_pressed: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Set the keyboard accelerator at the specified |index|. |key_code| can be\n any virtual key or character value. Returns true (1) on success.\n"]
    pub set_accelerator_at: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::core::ffi::c_int,
            key_code: ::core::ffi::c_int,
            shift_pressed: ::core::ffi::c_int,
            ctrl_pressed: ::core::ffi::c_int,
            alt_pressed: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Remove the keyboard accelerator for the specified |command_id|. Returns\n true (1) on success.\n"]
    pub remove_accelerator: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Remove the keyboard accelerator at the specified |index|. Returns true (1)\n on success.\n"]
    pub remove_accelerator_at: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Retrieves the keyboard accelerator for the specified |command_id|. Returns\n true (1) on success.\n"]
    pub get_accelerator: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::core::ffi::c_int,
            key_code: *mut ::core::ffi::c_int,
            shift_pressed: *mut ::core::ffi::c_int,
            ctrl_pressed: *mut ::core::ffi::c_int,
            alt_pressed: *mut ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Retrieves the keyboard accelerator for the specified |index|. Returns true\n (1) on success.\n"]
    pub get_accelerator_at: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::core::ffi::c_int,
            key_code: *mut ::core::ffi::c_int,
            shift_pressed: *mut ::core::ffi::c_int,
            ctrl_pressed: *mut ::core::ffi::c_int,
            alt_pressed: *mut ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Set the explicit color for |command_id| and |color_type| to |color|.\n Specify a |color| value of 0 to remove the explicit color. If no explicit\n color or default color is set for |color_type| then the system color will\n be used. Returns true (1) on success.\n"]
    pub set_color: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::core::ffi::c_int,
            color_type: cef_menu_color_type_t,
            color: cef_color_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Set the explicit color for |command_id| and |index| to |color|. Specify a\n |color| value of 0 to remove the explicit color. Specify an |index| value\n of -1 to set the default color for items that do not have an explicit color\n set. If no explicit color or default color is set for |color_type| then the\n system color will be used. Returns true (1) on success.\n"]
    pub set_color_at: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::core::ffi::c_int,
            color_type: cef_menu_color_type_t,
            color: cef_color_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns in |color| the color that was explicitly set for |command_id| and\n |color_type|. If a color was not set then 0 will be returned in |color|.\n Returns true (1) on success.\n"]
    pub get_color: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::core::ffi::c_int,
            color_type: cef_menu_color_type_t,
            color: *mut cef_color_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns in |color| the color that was explicitly set for |command_id| and\n |color_type|. Specify an |index| value of -1 to return the default color in\n |color|. If a color was not set then 0 will be returned in |color|. Returns\n true (1) on success.\n"]
    pub get_color_at: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::core::ffi::c_int,
            color_type: cef_menu_color_type_t,
            color: *mut cef_color_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Sets the font list for the specified |command_id|. If |font_list| is NULL\n the system font will be used. Returns true (1) on success. The format is\n \"<FONT_FAMILY_LIST>,[STYLES] <SIZE>\", where: - FONT_FAMILY_LIST is a comma-\n separated list of font family names, - STYLES is an optional space-\n separated list of style names (case-sensitive\n   \"Bold\" and \"Italic\" are supported), and\n - SIZE is an integer font size in pixels with the suffix \"px\".\n\n Here are examples of valid font description strings: - \"Arial, Helvetica,\n Bold Italic 14px\" - \"Arial, 14px\"\n"]
    pub set_font_list: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::core::ffi::c_int,
            font_list: *const cef_string_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Sets the font list for the specified |index|. Specify an |index| value of\n -1 to set the default font. If |font_list| is NULL the system font will be\n used. Returns true (1) on success. The format is\n \"<FONT_FAMILY_LIST>,[STYLES] <SIZE>\", where: - FONT_FAMILY_LIST is a comma-\n separated list of font family names, - STYLES is an optional space-\n separated list of style names (case-sensitive\n   \"Bold\" and \"Italic\" are supported), and\n - SIZE is an integer font size in pixels with the suffix \"px\".\n\n Here are examples of valid font description strings: - \"Arial, Helvetica,\n Bold Italic 14px\" - \"Arial, 14px\"\n"]
    pub set_font_list_at: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::core::ffi::c_int,
            font_list: *const cef_string_t,
        ) -> ::core::ffi::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_menu_model_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_menu_model_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_menu_model_t>(),
        488usize,
        concat!("Size of: ", stringify!(_cef_menu_model_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_menu_model_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_menu_model_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_sub_menu) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(is_sub_menu)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clear) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(clear)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_count) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(get_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).add_separator) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(add_separator)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).add_item) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(add_item)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).add_check_item) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(add_check_item)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).add_radio_item) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(add_radio_item)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).add_sub_menu) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(add_sub_menu)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).insert_separator_at) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(insert_separator_at)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).insert_item_at) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(insert_item_at)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).insert_check_item_at) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(insert_check_item_at)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).insert_radio_item_at) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(insert_radio_item_at)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).insert_sub_menu_at) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(insert_sub_menu_at)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).remove) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(remove)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).remove_at) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(remove_at)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_index_of) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(get_index_of)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_command_id_at) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(get_command_id_at)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_command_id_at) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(set_command_id_at)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_label) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(get_label)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_label_at) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(get_label_at)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_label) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(set_label)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_label_at) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(set_label_at)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_type) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(get_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_type_at) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(get_type_at)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_group_id) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(get_group_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_group_id_at) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(get_group_id_at)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_group_id) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(set_group_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_group_id_at) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(set_group_id_at)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_sub_menu) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(get_sub_menu)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_sub_menu_at) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(get_sub_menu_at)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_visible) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(is_visible)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_visible_at) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(is_visible_at)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_visible) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(set_visible)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_visible_at) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(set_visible_at)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_enabled) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(is_enabled)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_enabled_at) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(is_enabled_at)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_enabled) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(set_enabled)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_enabled_at) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(set_enabled_at)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_checked) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(is_checked)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_checked_at) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(is_checked_at)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_checked) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(set_checked)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_checked_at) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(set_checked_at)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_accelerator) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(has_accelerator)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_accelerator_at) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(has_accelerator_at)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_accelerator) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(set_accelerator)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_accelerator_at) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(set_accelerator_at)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).remove_accelerator) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(remove_accelerator)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).remove_accelerator_at) as usize - ptr as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(remove_accelerator_at)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_accelerator) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(get_accelerator)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_accelerator_at) as usize - ptr as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(get_accelerator_at)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_color) as usize - ptr as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(set_color)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_color_at) as usize - ptr as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(set_color_at)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_color) as usize - ptr as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(get_color)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_color_at) as usize - ptr as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(get_color_at)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_font_list) as usize - ptr as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(set_font_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_font_list_at) as usize - ptr as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_menu_model_t),
            "::",
            stringify!(set_font_list_at)
        )
    );
}
#[doc = "\n Supports creation and modification of menus. See cef_menu_id_t for the\n command ids that have default implementations. All user-defined command ids\n should be between MENU_ID_USER_FIRST and MENU_ID_USER_LAST. The functions of\n this structure can only be accessed on the browser process the UI thread.\n"]
pub type cef_menu_model_t = _cef_menu_model_t;
#[doc = "\n Callback structure used for continuation of custom context menu display.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_run_context_menu_callback_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Complete context menu display by selecting the specified |command_id| and\n |event_flags|.\n"]
    pub cont: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_run_context_menu_callback_t,
            command_id: ::core::ffi::c_int,
            event_flags: cef_event_flags_t,
        ),
    >,
    #[doc = "\n Cancel context menu display.\n"]
    pub cancel:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_run_context_menu_callback_t)>,
}
#[test]
fn bindgen_test_layout__cef_run_context_menu_callback_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_run_context_menu_callback_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_run_context_menu_callback_t>(),
        56usize,
        concat!("Size of: ", stringify!(_cef_run_context_menu_callback_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_run_context_menu_callback_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_cef_run_context_menu_callback_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_run_context_menu_callback_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cont) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_run_context_menu_callback_t),
            "::",
            stringify!(cont)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cancel) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_run_context_menu_callback_t),
            "::",
            stringify!(cancel)
        )
    );
}
#[doc = "\n Callback structure used for continuation of custom context menu display.\n"]
pub type cef_run_context_menu_callback_t = _cef_run_context_menu_callback_t;
#[doc = "\n Implement this structure to handle context menu events. The functions of this\n structure will be called on the UI thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_context_menu_handler_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Called before a context menu is displayed. |params| provides information\n about the context menu state. |model| initially contains the default\n context menu. The |model| can be cleared to show no context menu or\n modified to show a custom menu. Do not keep references to |params| or\n |model| outside of this callback.\n"]
    pub on_before_context_menu: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_context_menu_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            params: *mut _cef_context_menu_params_t,
            model: *mut _cef_menu_model_t,
        ),
    >,
    #[doc = "\n Called to allow custom display of the context menu. |params| provides\n information about the context menu state. |model| contains the context menu\n model resulting from OnBeforeContextMenu. For custom display return true\n (1) and execute |callback| either synchronously or asynchronously with the\n selected command ID. For default display return false (0). Do not keep\n references to |params| or |model| outside of this callback.\n"]
    pub run_context_menu: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_context_menu_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            params: *mut _cef_context_menu_params_t,
            model: *mut _cef_menu_model_t,
            callback: *mut _cef_run_context_menu_callback_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Called to execute a command selected from the context menu. Return true (1)\n if the command was handled or false (0) for the default implementation. See\n cef_menu_id_t for the command ids that have default implementations. All\n user-defined command ids should be between MENU_ID_USER_FIRST and\n MENU_ID_USER_LAST. |params| will have the same values as what was passed to\n on_before_context_menu(). Do not keep a reference to |params| outside of\n this callback.\n"]
    pub on_context_menu_command: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_context_menu_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            params: *mut _cef_context_menu_params_t,
            command_id: ::core::ffi::c_int,
            event_flags: cef_event_flags_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Called when the context menu is dismissed irregardless of whether the menu\n was NULL or a command was selected.\n"]
    pub on_context_menu_dismissed: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_context_menu_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_context_menu_handler_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_context_menu_handler_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_context_menu_handler_t>(),
        72usize,
        concat!("Size of: ", stringify!(_cef_context_menu_handler_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_context_menu_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_context_menu_handler_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_context_menu_handler_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_before_context_menu) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_context_menu_handler_t),
            "::",
            stringify!(on_before_context_menu)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).run_context_menu) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_context_menu_handler_t),
            "::",
            stringify!(run_context_menu)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_context_menu_command) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_context_menu_handler_t),
            "::",
            stringify!(on_context_menu_command)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_context_menu_dismissed) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_context_menu_handler_t),
            "::",
            stringify!(on_context_menu_dismissed)
        )
    );
}
#[doc = "\n Implement this structure to handle context menu events. The functions of this\n structure will be called on the UI thread.\n"]
pub type cef_context_menu_handler_t = _cef_context_menu_handler_t;
#[doc = "\n Provides information about the context menu state. The ethods of this\n structure can only be accessed on browser process the UI thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_context_menu_params_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Returns the X coordinate of the mouse where the context menu was invoked.\n Coords are relative to the associated RenderView's origin.\n"]
    pub get_xcoord: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the Y coordinate of the mouse where the context menu was invoked.\n Coords are relative to the associated RenderView's origin.\n"]
    pub get_ycoord: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns flags representing the type of node that the context menu was\n invoked on.\n"]
    pub get_type_flags: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_context_menu_params_t,
        ) -> cef_context_menu_type_flags_t,
    >,
    #[doc = "\n Returns the URL of the link, if any, that encloses the node that the\n context menu was invoked on.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_link_url: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the link URL, if any, to be used ONLY for \"copy link address\". We\n don't validate this field in the frontend process.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_unfiltered_link_url: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the source URL, if any, for the element that the context menu was\n invoked on. Example of elements with source URLs are img, audio, and video.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_source_url: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns true (1) if the context menu was invoked on an image which has non-\n NULL contents.\n"]
    pub has_image_contents: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the title text or the alt text if the context menu was invoked on\n an image.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_title_text: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the URL of the top level page that the context menu was invoked on.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_page_url: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the URL of the subframe that the context menu was invoked on.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_frame_url: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the character encoding of the subframe that the context menu was\n invoked on.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_frame_charset: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the type of context node that the context menu was invoked on.\n"]
    pub get_media_type: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_context_menu_params_t,
        ) -> cef_context_menu_media_type_t,
    >,
    #[doc = "\n Returns flags representing the actions supported by the media element, if\n any, that the context menu was invoked on.\n"]
    pub get_media_state_flags: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_context_menu_params_t,
        ) -> cef_context_menu_media_state_flags_t,
    >,
    #[doc = "\n Returns the text of the selection, if any, that the context menu was\n invoked on.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_selection_text: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the text of the misspelled word, if any, that the context menu was\n invoked on.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_misspelled_word: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns true (1) if suggestions exist, false (0) otherwise. Fills in\n |suggestions| from the spell check service for the misspelled word if there\n is one.\n"]
    pub get_dictionary_suggestions: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_context_menu_params_t,
            suggestions: cef_string_list_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if the context menu was invoked on an editable node.\n"]
    pub is_editable: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if the context menu was invoked on an editable node where\n spell-check is enabled.\n"]
    pub is_spell_check_enabled: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns flags representing the actions supported by the editable node, if\n any, that the context menu was invoked on.\n"]
    pub get_edit_state_flags: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_context_menu_params_t,
        ) -> cef_context_menu_edit_state_flags_t,
    >,
    #[doc = "\n Returns true (1) if the context menu contains items specified by the\n renderer process (for example, plugin placeholder or pepper plugin menu\n items).\n"]
    pub is_custom_menu: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> ::core::ffi::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_context_menu_params_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_context_menu_params_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_context_menu_params_t>(),
        200usize,
        concat!("Size of: ", stringify!(_cef_context_menu_params_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_context_menu_params_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_context_menu_params_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_context_menu_params_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_xcoord) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_context_menu_params_t),
            "::",
            stringify!(get_xcoord)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_ycoord) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_context_menu_params_t),
            "::",
            stringify!(get_ycoord)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_type_flags) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_context_menu_params_t),
            "::",
            stringify!(get_type_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_link_url) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_context_menu_params_t),
            "::",
            stringify!(get_link_url)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_unfiltered_link_url) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_context_menu_params_t),
            "::",
            stringify!(get_unfiltered_link_url)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_source_url) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_context_menu_params_t),
            "::",
            stringify!(get_source_url)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_image_contents) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_context_menu_params_t),
            "::",
            stringify!(has_image_contents)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_title_text) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_context_menu_params_t),
            "::",
            stringify!(get_title_text)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_page_url) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_context_menu_params_t),
            "::",
            stringify!(get_page_url)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_frame_url) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_context_menu_params_t),
            "::",
            stringify!(get_frame_url)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_frame_charset) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_context_menu_params_t),
            "::",
            stringify!(get_frame_charset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_media_type) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_context_menu_params_t),
            "::",
            stringify!(get_media_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_media_state_flags) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_context_menu_params_t),
            "::",
            stringify!(get_media_state_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_selection_text) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_context_menu_params_t),
            "::",
            stringify!(get_selection_text)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_misspelled_word) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_context_menu_params_t),
            "::",
            stringify!(get_misspelled_word)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_dictionary_suggestions) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_context_menu_params_t),
            "::",
            stringify!(get_dictionary_suggestions)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_editable) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_context_menu_params_t),
            "::",
            stringify!(is_editable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_spell_check_enabled) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_context_menu_params_t),
            "::",
            stringify!(is_spell_check_enabled)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_edit_state_flags) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_context_menu_params_t),
            "::",
            stringify!(get_edit_state_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_custom_menu) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_context_menu_params_t),
            "::",
            stringify!(is_custom_menu)
        )
    );
}
#[doc = "\n Provides information about the context menu state. The ethods of this\n structure can only be accessed on browser process the UI thread.\n"]
pub type cef_context_menu_params_t = _cef_context_menu_params_t;
#[doc = "\n Callback structure for asynchronous continuation of file dialog requests.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_file_dialog_callback_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Continue the file selection. |selected_accept_filter| should be the 0-based\n index of the value selected from the accept filters array passed to\n cef_dialog_handler_t::OnFileDialog. |file_paths| should be a single value\n or a list of values depending on the dialog mode. An NULL |file_paths|\n value is treated the same as calling cancel().\n"]
    pub cont: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_file_dialog_callback_t,
            selected_accept_filter: ::core::ffi::c_int,
            file_paths: cef_string_list_t,
        ),
    >,
    #[doc = "\n Cancel the file selection.\n"]
    pub cancel:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_file_dialog_callback_t)>,
}
#[test]
fn bindgen_test_layout__cef_file_dialog_callback_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_file_dialog_callback_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_file_dialog_callback_t>(),
        56usize,
        concat!("Size of: ", stringify!(_cef_file_dialog_callback_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_file_dialog_callback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_file_dialog_callback_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_file_dialog_callback_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cont) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_file_dialog_callback_t),
            "::",
            stringify!(cont)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cancel) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_file_dialog_callback_t),
            "::",
            stringify!(cancel)
        )
    );
}
#[doc = "\n Callback structure for asynchronous continuation of file dialog requests.\n"]
pub type cef_file_dialog_callback_t = _cef_file_dialog_callback_t;
#[doc = "\n Implement this structure to handle dialog events. The functions of this\n structure will be called on the browser process UI thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_dialog_handler_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Called to run a file chooser dialog. |mode| represents the type of dialog\n to display. |title| to the title to be used for the dialog and may be NULL\n to show the default title (\"Open\" or \"Save\" depending on the mode).\n |default_file_path| is the path with optional directory and/or file name\n component that should be initially selected in the dialog. |accept_filters|\n are used to restrict the selectable file types and may any combination of\n (a) valid lower-cased MIME types (e.g. \"text/*\" or \"image/*\"), (b)\n individual file extensions (e.g. \".txt\" or \".png\"), or (c) combined\n description and file extension delimited using \"|\" and \";\" (e.g. \"Image\n Types|.png;.gif;.jpg\"). |selected_accept_filter| is the 0-based index of\n the filter that should be selected by default. To display a custom dialog\n return true (1) and execute |callback| either inline or at a later time. To\n display the default dialog return false (0).\n"]
    pub on_file_dialog: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dialog_handler_t,
            browser: *mut _cef_browser_t,
            mode: cef_file_dialog_mode_t,
            title: *const cef_string_t,
            default_file_path: *const cef_string_t,
            accept_filters: cef_string_list_t,
            selected_accept_filter: ::core::ffi::c_int,
            callback: *mut _cef_file_dialog_callback_t,
        ) -> ::core::ffi::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_dialog_handler_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_dialog_handler_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_dialog_handler_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_dialog_handler_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_dialog_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_dialog_handler_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_dialog_handler_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_file_dialog) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_dialog_handler_t),
            "::",
            stringify!(on_file_dialog)
        )
    );
}
#[doc = "\n Implement this structure to handle dialog events. The functions of this\n structure will be called on the browser process UI thread.\n"]
pub type cef_dialog_handler_t = _cef_dialog_handler_t;
#[doc = "\n Implement this structure to handle events related to browser display state.\n The functions of this structure will be called on the UI thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_display_handler_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Called when a frame's address has changed.\n"]
    pub on_address_change: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_display_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            url: *const cef_string_t,
        ),
    >,
    #[doc = "\n Called when the page title changes.\n"]
    pub on_title_change: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_display_handler_t,
            browser: *mut _cef_browser_t,
            title: *const cef_string_t,
        ),
    >,
    #[doc = "\n Called when the page icon changes.\n"]
    pub on_favicon_urlchange: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_display_handler_t,
            browser: *mut _cef_browser_t,
            icon_urls: cef_string_list_t,
        ),
    >,
    #[doc = "\n Called when web content in the page has toggled fullscreen mode. If\n |fullscreen| is true (1) the content will automatically be sized to fill\n the browser content area. If |fullscreen| is false (0) the content will\n automatically return to its original size and position. The client is\n responsible for resizing the browser if desired.\n"]
    pub on_fullscreen_mode_change: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_display_handler_t,
            browser: *mut _cef_browser_t,
            fullscreen: ::core::ffi::c_int,
        ),
    >,
    #[doc = "\n Called when the browser is about to display a tooltip. |text| contains the\n text that will be displayed in the tooltip. To handle the display of the\n tooltip yourself return true (1). Otherwise, you can optionally modify\n |text| and then return false (0) to allow the browser to display the\n tooltip. When window rendering is disabled the application is responsible\n for drawing tooltips and the return value is ignored.\n"]
    pub on_tooltip: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_display_handler_t,
            browser: *mut _cef_browser_t,
            text: *mut cef_string_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Called when the browser receives a status message. |value| contains the\n text that will be displayed in the status message.\n"]
    pub on_status_message: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_display_handler_t,
            browser: *mut _cef_browser_t,
            value: *const cef_string_t,
        ),
    >,
    #[doc = "\n Called to display a console message. Return true (1) to stop the message\n from being output to the console.\n"]
    pub on_console_message: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_display_handler_t,
            browser: *mut _cef_browser_t,
            level: cef_log_severity_t,
            message: *const cef_string_t,
            source: *const cef_string_t,
            line: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Called when auto-resize is enabled via\n cef_browser_host_t::SetAutoResizeEnabled and the contents have auto-\n resized. |new_size| will be the desired size in view coordinates. Return\n true (1) if the resize was handled or false (0) for default handling.\n"]
    pub on_auto_resize: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_display_handler_t,
            browser: *mut _cef_browser_t,
            new_size: *const cef_size_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Called when the overall page loading progress has changed. |progress|\n ranges from 0.0 to 1.0.\n"]
    pub on_loading_progress_change: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_display_handler_t,
            browser: *mut _cef_browser_t,
            progress: f64,
        ),
    >,
    #[doc = "\n Called when the browser's cursor has changed. If |type| is CT_CUSTOM then\n |custom_cursor_info| will be populated with the custom cursor information.\n Return true (1) if the cursor change was handled or false (0) for default\n handling.\n"]
    pub on_cursor_change: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_display_handler_t,
            browser: *mut _cef_browser_t,
            cursor: HCURSOR,
            type_: cef_cursor_type_t,
            custom_cursor_info: *const _cef_cursor_info_t,
        ) -> ::core::ffi::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_display_handler_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_display_handler_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_display_handler_t>(),
        120usize,
        concat!("Size of: ", stringify!(_cef_display_handler_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_display_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_display_handler_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_display_handler_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_address_change) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_display_handler_t),
            "::",
            stringify!(on_address_change)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_title_change) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_display_handler_t),
            "::",
            stringify!(on_title_change)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_favicon_urlchange) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_display_handler_t),
            "::",
            stringify!(on_favicon_urlchange)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_fullscreen_mode_change) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_display_handler_t),
            "::",
            stringify!(on_fullscreen_mode_change)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_tooltip) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_display_handler_t),
            "::",
            stringify!(on_tooltip)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_status_message) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_display_handler_t),
            "::",
            stringify!(on_status_message)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_console_message) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_display_handler_t),
            "::",
            stringify!(on_console_message)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_auto_resize) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_display_handler_t),
            "::",
            stringify!(on_auto_resize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_loading_progress_change) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_display_handler_t),
            "::",
            stringify!(on_loading_progress_change)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_cursor_change) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_display_handler_t),
            "::",
            stringify!(on_cursor_change)
        )
    );
}
#[doc = "\n Implement this structure to handle events related to browser display state.\n The functions of this structure will be called on the UI thread.\n"]
pub type cef_display_handler_t = _cef_display_handler_t;
#[doc = "\n Structure used to represent a download item.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_download_item_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Returns true (1) if this object is valid. Do not call any other functions\n if this function returns false (0).\n"]
    pub is_valid: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if the download is in progress.\n"]
    pub is_in_progress: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if the download is complete.\n"]
    pub is_complete: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if the download has been canceled or interrupted.\n"]
    pub is_canceled: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns a simple speed estimate in bytes/s.\n"]
    pub get_current_speed:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> int64>,
    #[doc = "\n Returns the rough percent complete or -1 if the receive total size is\n unknown.\n"]
    pub get_percent_complete: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the total number of bytes.\n"]
    pub get_total_bytes:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> int64>,
    #[doc = "\n Returns the number of received bytes.\n"]
    pub get_received_bytes:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> int64>,
    #[doc = "\n Returns the time that the download started.\n"]
    pub get_start_time: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> cef_time_t,
    >,
    #[doc = "\n Returns the time that the download ended.\n"]
    pub get_end_time: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> cef_time_t,
    >,
    #[doc = "\n Returns the full path to the downloaded or downloading file.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_full_path: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the unique identifier for this download.\n"]
    pub get_id:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> uint32>,
    #[doc = "\n Returns the URL.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_url: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the original URL before any redirections.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_original_url: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the suggested file name.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_suggested_file_name: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the content disposition.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_content_disposition: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the mime type.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_mime_type: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> cef_string_userfree_t,
    >,
}
#[test]
fn bindgen_test_layout__cef_download_item_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_download_item_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_download_item_t>(),
        176usize,
        concat!("Size of: ", stringify!(_cef_download_item_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_download_item_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_download_item_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_download_item_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_valid) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_download_item_t),
            "::",
            stringify!(is_valid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_in_progress) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_download_item_t),
            "::",
            stringify!(is_in_progress)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_complete) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_download_item_t),
            "::",
            stringify!(is_complete)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_canceled) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_download_item_t),
            "::",
            stringify!(is_canceled)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_current_speed) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_download_item_t),
            "::",
            stringify!(get_current_speed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_percent_complete) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_download_item_t),
            "::",
            stringify!(get_percent_complete)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_total_bytes) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_download_item_t),
            "::",
            stringify!(get_total_bytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_received_bytes) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_download_item_t),
            "::",
            stringify!(get_received_bytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_start_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_download_item_t),
            "::",
            stringify!(get_start_time)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_end_time) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_download_item_t),
            "::",
            stringify!(get_end_time)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_full_path) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_download_item_t),
            "::",
            stringify!(get_full_path)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_id) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_download_item_t),
            "::",
            stringify!(get_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_url) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_download_item_t),
            "::",
            stringify!(get_url)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_original_url) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_download_item_t),
            "::",
            stringify!(get_original_url)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_suggested_file_name) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_download_item_t),
            "::",
            stringify!(get_suggested_file_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_content_disposition) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_download_item_t),
            "::",
            stringify!(get_content_disposition)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_mime_type) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_download_item_t),
            "::",
            stringify!(get_mime_type)
        )
    );
}
#[doc = "\n Structure used to represent a download item.\n"]
pub type cef_download_item_t = _cef_download_item_t;
#[doc = "\n Callback structure used to asynchronously continue a download.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_before_download_callback_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Call to continue the download. Set |download_path| to the full file path\n for the download including the file name or leave blank to use the\n suggested name and the default temp directory. Set |show_dialog| to true\n (1) if you do wish to show the default \"Save As\" dialog.\n"]
    pub cont: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_before_download_callback_t,
            download_path: *const cef_string_t,
            show_dialog: ::core::ffi::c_int,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_before_download_callback_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_before_download_callback_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_before_download_callback_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_before_download_callback_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_before_download_callback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_before_download_callback_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_before_download_callback_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cont) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_before_download_callback_t),
            "::",
            stringify!(cont)
        )
    );
}
#[doc = "\n Callback structure used to asynchronously continue a download.\n"]
pub type cef_before_download_callback_t = _cef_before_download_callback_t;
#[doc = "\n Callback structure used to asynchronously cancel a download.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_download_item_callback_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Call to cancel the download.\n"]
    pub cancel:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_download_item_callback_t)>,
    #[doc = "\n Call to pause the download.\n"]
    pub pause:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_download_item_callback_t)>,
    #[doc = "\n Call to resume the download.\n"]
    pub resume:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_download_item_callback_t)>,
}
#[test]
fn bindgen_test_layout__cef_download_item_callback_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_download_item_callback_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_download_item_callback_t>(),
        64usize,
        concat!("Size of: ", stringify!(_cef_download_item_callback_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_download_item_callback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_download_item_callback_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_download_item_callback_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cancel) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_download_item_callback_t),
            "::",
            stringify!(cancel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pause) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_download_item_callback_t),
            "::",
            stringify!(pause)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).resume) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_download_item_callback_t),
            "::",
            stringify!(resume)
        )
    );
}
#[doc = "\n Callback structure used to asynchronously cancel a download.\n"]
pub type cef_download_item_callback_t = _cef_download_item_callback_t;
#[doc = "\n Structure used to handle file downloads. The functions of this structure will\n called on the browser process UI thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_download_handler_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Called before a download begins. |suggested_name| is the suggested name for\n the download file. By default the download will be canceled. Execute\n |callback| either asynchronously or in this function to continue the\n download if desired. Do not keep a reference to |download_item| outside of\n this function.\n"]
    pub on_before_download: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_download_handler_t,
            browser: *mut _cef_browser_t,
            download_item: *mut _cef_download_item_t,
            suggested_name: *const cef_string_t,
            callback: *mut _cef_before_download_callback_t,
        ),
    >,
    #[doc = "\n Called when a download's status or progress information has been updated.\n This may be called multiple times before and after on_before_download().\n Execute |callback| either asynchronously or in this function to cancel the\n download if desired. Do not keep a reference to |download_item| outside of\n this function.\n"]
    pub on_download_updated: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_download_handler_t,
            browser: *mut _cef_browser_t,
            download_item: *mut _cef_download_item_t,
            callback: *mut _cef_download_item_callback_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_download_handler_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_download_handler_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_download_handler_t>(),
        56usize,
        concat!("Size of: ", stringify!(_cef_download_handler_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_download_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_download_handler_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_download_handler_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_before_download) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_download_handler_t),
            "::",
            stringify!(on_before_download)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_download_updated) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_download_handler_t),
            "::",
            stringify!(on_download_updated)
        )
    );
}
#[doc = "\n Structure used to handle file downloads. The functions of this structure will\n called on the browser process UI thread.\n"]
pub type cef_download_handler_t = _cef_download_handler_t;
#[doc = "\n Implement this structure to handle events related to dragging. The functions\n of this structure will be called on the UI thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_drag_handler_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Called when an external drag event enters the browser window. |dragData|\n contains the drag event data and |mask| represents the type of drag\n operation. Return false (0) for default drag handling behavior or true (1)\n to cancel the drag event.\n"]
    pub on_drag_enter: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_drag_handler_t,
            browser: *mut _cef_browser_t,
            dragData: *mut _cef_drag_data_t,
            mask: cef_drag_operations_mask_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Called whenever draggable regions for the browser window change. These can\n be specified using the '-webkit-app-region: drag/no-drag' CSS-property. If\n draggable regions are never defined in a document this function will also\n never be called. If the last draggable region is removed from a document\n this function will be called with an NULL vector.\n"]
    pub on_draggable_regions_changed: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_drag_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            regionsCount: usize,
            regions: *const cef_draggable_region_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_drag_handler_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_drag_handler_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_drag_handler_t>(),
        56usize,
        concat!("Size of: ", stringify!(_cef_drag_handler_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_drag_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_drag_handler_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_drag_handler_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_drag_enter) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_drag_handler_t),
            "::",
            stringify!(on_drag_enter)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).on_draggable_regions_changed) as usize - ptr as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_drag_handler_t),
            "::",
            stringify!(on_draggable_regions_changed)
        )
    );
}
#[doc = "\n Implement this structure to handle events related to dragging. The functions\n of this structure will be called on the UI thread.\n"]
pub type cef_drag_handler_t = _cef_drag_handler_t;
#[doc = "\n Implement this structure to handle events related to find results. The\n functions of this structure will be called on the UI thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_find_handler_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Called to report find results returned by cef_browser_host_t::find().\n |identifer| is the identifier passed to find(), |count| is the number of\n matches currently identified, |selectionRect| is the location of where the\n match was found (in window coordinates), |activeMatchOrdinal| is the\n current position in the search results, and |finalUpdate| is true (1) if\n this is the last find notification.\n"]
    pub on_find_result: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_find_handler_t,
            browser: *mut _cef_browser_t,
            identifier: ::core::ffi::c_int,
            count: ::core::ffi::c_int,
            selectionRect: *const cef_rect_t,
            activeMatchOrdinal: ::core::ffi::c_int,
            finalUpdate: ::core::ffi::c_int,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_find_handler_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_find_handler_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_find_handler_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_find_handler_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_find_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_find_handler_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_find_handler_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_find_result) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_find_handler_t),
            "::",
            stringify!(on_find_result)
        )
    );
}
#[doc = "\n Implement this structure to handle events related to find results. The\n functions of this structure will be called on the UI thread.\n"]
pub type cef_find_handler_t = _cef_find_handler_t;
#[doc = "\n Implement this structure to handle events related to focus. The functions of\n this structure will be called on the UI thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_focus_handler_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Called when the browser component is about to loose focus. For instance, if\n focus was on the last HTML element and the user pressed the TAB key. |next|\n will be true (1) if the browser is giving focus to the next component and\n false (0) if the browser is giving focus to the previous component.\n"]
    pub on_take_focus: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_focus_handler_t,
            browser: *mut _cef_browser_t,
            next: ::core::ffi::c_int,
        ),
    >,
    #[doc = "\n Called when the browser component is requesting focus. |source| indicates\n where the focus request is originating from. Return false (0) to allow the\n focus to be set or true (1) to cancel setting the focus.\n"]
    pub on_set_focus: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_focus_handler_t,
            browser: *mut _cef_browser_t,
            source: cef_focus_source_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Called when the browser component has received focus.\n"]
    pub on_got_focus: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_focus_handler_t, browser: *mut _cef_browser_t),
    >,
}
#[test]
fn bindgen_test_layout__cef_focus_handler_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_focus_handler_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_focus_handler_t>(),
        64usize,
        concat!("Size of: ", stringify!(_cef_focus_handler_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_focus_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_focus_handler_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_focus_handler_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_take_focus) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_focus_handler_t),
            "::",
            stringify!(on_take_focus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_set_focus) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_focus_handler_t),
            "::",
            stringify!(on_set_focus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_got_focus) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_focus_handler_t),
            "::",
            stringify!(on_got_focus)
        )
    );
}
#[doc = "\n Implement this structure to handle events related to focus. The functions of\n this structure will be called on the UI thread.\n"]
pub type cef_focus_handler_t = _cef_focus_handler_t;
#[doc = "\n Callback structure used for asynchronous continuation of JavaScript dialog\n requests.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_jsdialog_callback_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Continue the JS dialog request. Set |success| to true (1) if the OK button\n was pressed. The |user_input| value should be specified for prompt dialogs.\n"]
    pub cont: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_jsdialog_callback_t,
            success: ::core::ffi::c_int,
            user_input: *const cef_string_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_jsdialog_callback_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_jsdialog_callback_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_jsdialog_callback_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_jsdialog_callback_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_jsdialog_callback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_jsdialog_callback_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_jsdialog_callback_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cont) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_jsdialog_callback_t),
            "::",
            stringify!(cont)
        )
    );
}
#[doc = "\n Callback structure used for asynchronous continuation of JavaScript dialog\n requests.\n"]
pub type cef_jsdialog_callback_t = _cef_jsdialog_callback_t;
#[doc = "\n Implement this structure to handle events related to JavaScript dialogs. The\n functions of this structure will be called on the UI thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_jsdialog_handler_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Called to run a JavaScript dialog. If |origin_url| is non-NULL it can be\n passed to the CefFormatUrlForSecurityDisplay function to retrieve a secure\n and user-friendly display string. The |default_prompt_text| value will be\n specified for prompt dialogs only. Set |suppress_message| to true (1) and\n return false (0) to suppress the message (suppressing messages is\n preferable to immediately executing the callback as this is used to detect\n presumably malicious behavior like spamming alert messages in\n onbeforeunload). Set |suppress_message| to false (0) and return false (0)\n to use the default implementation (the default implementation will show one\n modal dialog at a time and suppress any additional dialog requests until\n the displayed dialog is dismissed). Return true (1) if the application will\n use a custom dialog or if the callback has been executed immediately.\n Custom dialogs may be either modal or modeless. If a custom dialog is used\n the application must execute |callback| once the custom dialog is\n dismissed.\n"]
    pub on_jsdialog: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_jsdialog_handler_t,
            browser: *mut _cef_browser_t,
            origin_url: *const cef_string_t,
            dialog_type: cef_jsdialog_type_t,
            message_text: *const cef_string_t,
            default_prompt_text: *const cef_string_t,
            callback: *mut _cef_jsdialog_callback_t,
            suppress_message: *mut ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Called to run a dialog asking the user if they want to leave a page. Return\n false (0) to use the default dialog implementation. Return true (1) if the\n application will use a custom dialog or if the callback has been executed\n immediately. Custom dialogs may be either modal or modeless. If a custom\n dialog is used the application must execute |callback| once the custom\n dialog is dismissed.\n"]
    pub on_before_unload_dialog: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_jsdialog_handler_t,
            browser: *mut _cef_browser_t,
            message_text: *const cef_string_t,
            is_reload: ::core::ffi::c_int,
            callback: *mut _cef_jsdialog_callback_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Called to cancel any pending dialogs and reset any saved dialog state. Will\n be called due to events like page navigation irregardless of whether any\n dialogs are currently pending.\n"]
    pub on_reset_dialog_state: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_jsdialog_handler_t, browser: *mut _cef_browser_t),
    >,
    #[doc = "\n Called when the default implementation dialog is closed.\n"]
    pub on_dialog_closed: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_jsdialog_handler_t, browser: *mut _cef_browser_t),
    >,
}
#[test]
fn bindgen_test_layout__cef_jsdialog_handler_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_jsdialog_handler_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_jsdialog_handler_t>(),
        72usize,
        concat!("Size of: ", stringify!(_cef_jsdialog_handler_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_jsdialog_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_jsdialog_handler_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_jsdialog_handler_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_jsdialog) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_jsdialog_handler_t),
            "::",
            stringify!(on_jsdialog)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_before_unload_dialog) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_jsdialog_handler_t),
            "::",
            stringify!(on_before_unload_dialog)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_reset_dialog_state) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_jsdialog_handler_t),
            "::",
            stringify!(on_reset_dialog_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_dialog_closed) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_jsdialog_handler_t),
            "::",
            stringify!(on_dialog_closed)
        )
    );
}
#[doc = "\n Implement this structure to handle events related to JavaScript dialogs. The\n functions of this structure will be called on the UI thread.\n"]
pub type cef_jsdialog_handler_t = _cef_jsdialog_handler_t;
#[doc = "\n Implement this structure to handle events related to keyboard input. The\n functions of this structure will be called on the UI thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_keyboard_handler_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Called before a keyboard event is sent to the renderer. |event| contains\n information about the keyboard event. |os_event| is the operating system\n event message, if any. Return true (1) if the event was handled or false\n (0) otherwise. If the event will be handled in on_key_event() as a keyboard\n shortcut set |is_keyboard_shortcut| to true (1) and return false (0).\n"]
    pub on_pre_key_event: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_keyboard_handler_t,
            browser: *mut _cef_browser_t,
            event: *const _cef_key_event_t,
            os_event: *mut MSG,
            is_keyboard_shortcut: *mut ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Called after the renderer and JavaScript in the page has had a chance to\n handle the event. |event| contains information about the keyboard event.\n |os_event| is the operating system event message, if any. Return true (1)\n if the keyboard event was handled or false (0) otherwise.\n"]
    pub on_key_event: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_keyboard_handler_t,
            browser: *mut _cef_browser_t,
            event: *const _cef_key_event_t,
            os_event: *mut MSG,
        ) -> ::core::ffi::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_keyboard_handler_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_keyboard_handler_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_keyboard_handler_t>(),
        56usize,
        concat!("Size of: ", stringify!(_cef_keyboard_handler_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_keyboard_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_keyboard_handler_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_keyboard_handler_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_pre_key_event) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_keyboard_handler_t),
            "::",
            stringify!(on_pre_key_event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_key_event) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_keyboard_handler_t),
            "::",
            stringify!(on_key_event)
        )
    );
}
#[doc = "\n Implement this structure to handle events related to keyboard input. The\n functions of this structure will be called on the UI thread.\n"]
pub type cef_keyboard_handler_t = _cef_keyboard_handler_t;
#[doc = "\n Implement this structure to handle events related to browser life span. The\n functions of this structure will be called on the UI thread unless otherwise\n indicated.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _cef_life_span_handler_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Called on the UI thread before a new popup browser is created. The\n |browser| and |frame| values represent the source of the popup request. The\n |target_url| and |target_frame_name| values indicate where the popup\n browser should navigate and may be NULL if not specified with the request.\n The |target_disposition| value indicates where the user intended to open\n the popup (e.g. current tab, new tab, etc). The |user_gesture| value will\n be true (1) if the popup was opened via explicit user gesture (e.g.\n clicking a link) or false (0) if the popup opened automatically (e.g. via\n the DomContentLoaded event). The |popupFeatures| structure contains\n additional information about the requested popup window. To allow creation\n of the popup browser optionally modify |windowInfo|, |client|, |settings|\n and |no_javascript_access| and return false (0). To cancel creation of the\n popup browser return true (1). The |client| and |settings| values will\n default to the source browser's values. If the |no_javascript_access| value\n is set to false (0) the new browser will not be scriptable and may not be\n hosted in the same renderer process as the source browser. Any\n modifications to |windowInfo| will be ignored if the parent browser is\n wrapped in a cef_browser_view_t. Popup browser creation will be canceled if\n the parent browser is destroyed before the popup browser creation completes\n (indicated by a call to OnAfterCreated for the popup browser). The\n |extra_info| parameter provides an opportunity to specify extra information\n specific to the created popup browser that will be passed to\n cef_render_process_handler_t::on_browser_created() in the render process.\n"]
    pub on_before_popup: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_life_span_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            target_url: *const cef_string_t,
            target_frame_name: *const cef_string_t,
            target_disposition: cef_window_open_disposition_t,
            user_gesture: ::core::ffi::c_int,
            popupFeatures: *const _cef_popup_features_t,
            windowInfo: *mut _cef_window_info_t,
            client: *mut *mut _cef_client_t,
            settings: *mut _cef_browser_settings_t,
            extra_info: *mut *mut _cef_dictionary_value_t,
            no_javascript_access: *mut ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Called after a new browser is created. This callback will be the first\n notification that references |browser|.\n"]
    pub on_after_created: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_life_span_handler_t, browser: *mut _cef_browser_t),
    >,
    #[doc = "\n Called when a browser has recieved a request to close. This may result\n directly from a call to cef_browser_host_t::*close_browser() or indirectly\n if the browser is parented to a top-level window created by CEF and the\n user attempts to close that window (by clicking the 'X', for example). The\n do_close() function will be called after the JavaScript 'onunload' event\n has been fired.\n\n An application should handle top-level owner window close notifications by\n calling cef_browser_host_t::try_close_browser() or\n cef_browser_host_t::CloseBrowser(false (0)) instead of allowing the window\n to close immediately (see the examples below). This gives CEF an\n opportunity to process the 'onbeforeunload' event and optionally cancel the\n close before do_close() is called.\n\n When windowed rendering is enabled CEF will internally create a window or\n view to host the browser. In that case returning false (0) from do_close()\n will send the standard close notification to the browser's top-level owner\n window (e.g. WM_CLOSE on Windows, performClose: on OS X, \"delete_event\" on\n Linux or cef_window_delegate_t::can_close() callback from Views). If the\n browser's host window/view has already been destroyed (via view hierarchy\n tear-down, for example) then do_close() will not be called for that browser\n since is no longer possible to cancel the close.\n\n When windowed rendering is disabled returning false (0) from do_close()\n will cause the browser object to be destroyed immediately.\n\n If the browser's top-level owner window requires a non-standard close\n notification then send that notification from do_close() and return true\n (1).\n\n The cef_life_span_handler_t::on_before_close() function will be called\n after do_close() (if do_close() is called) and immediately before the\n browser object is destroyed. The application should only exit after\n on_before_close() has been called for all existing browsers.\n\n The below examples describe what should happen during window close when the\n browser is parented to an application-provided top-level window.\n\n Example 1: Using cef_browser_host_t::try_close_browser(). This is\n recommended for clients using standard close handling and windows created\n on the browser process UI thread. 1.  User clicks the window close button\n which sends a close notification to\n     the application's top-level window.\n 2.  Application's top-level window receives the close notification and\n     calls TryCloseBrowser() (which internally calls CloseBrowser(false)).\n     TryCloseBrowser() returns false so the client cancels the window close.\n 3.  JavaScript 'onbeforeunload' handler executes and shows the close\n     confirmation dialog (which can be overridden via\n     CefJSDialogHandler::OnBeforeUnloadDialog()).\n 4.  User approves the close. 5.  JavaScript 'onunload' handler executes. 6.\n CEF sends a close notification to the application's top-level window\n     (because DoClose() returned false by default).\n 7.  Application's top-level window receives the close notification and\n     calls TryCloseBrowser(). TryCloseBrowser() returns true so the client\n     allows the window close.\n 8.  Application's top-level window is destroyed. 9.  Application's\n on_before_close() handler is called and the browser object\n     is destroyed.\n 10. Application exits by calling cef_quit_message_loop() if no other\n browsers\n     exist.\n\n Example 2: Using cef_browser_host_t::CloseBrowser(false (0)) and\n implementing the do_close() callback. This is recommended for clients using\n non-standard close handling or windows that were not created on the browser\n process UI thread. 1.  User clicks the window close button which sends a\n close notification to\n     the application's top-level window.\n 2.  Application's top-level window receives the close notification and:\n     A. Calls CefBrowserHost::CloseBrowser(false).\n     B. Cancels the window close.\n 3.  JavaScript 'onbeforeunload' handler executes and shows the close\n     confirmation dialog (which can be overridden via\n     CefJSDialogHandler::OnBeforeUnloadDialog()).\n 4.  User approves the close. 5.  JavaScript 'onunload' handler executes. 6.\n Application's do_close() handler is called. Application will:\n     A. Set a flag to indicate that the next close attempt will be allowed.\n     B. Return false.\n 7.  CEF sends an close notification to the application's top-level window.\n 8.  Application's top-level window receives the close notification and\n     allows the window to close based on the flag from #6B.\n 9.  Application's top-level window is destroyed. 10. Application's\n on_before_close() handler is called and the browser object\n     is destroyed.\n 11. Application exits by calling cef_quit_message_loop() if no other\n browsers\n     exist.\n"]
    pub do_close: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_life_span_handler_t,
            browser: *mut _cef_browser_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Called just before a browser is destroyed. Release all references to the\n browser object and do not attempt to execute any functions on the browser\n object (other than GetIdentifier or IsSame) after this callback returns.\n This callback will be the last notification that references |browser| on\n the UI thread. Any in-progress network requests associated with |browser|\n will be aborted when the browser is destroyed, and\n cef_resource_request_handler_t callbacks related to those requests may\n still arrive on the IO thread after this function is called. See do_close()\n documentation for additional usage information.\n"]
    pub on_before_close: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_life_span_handler_t, browser: *mut _cef_browser_t),
    >,
}
#[test]
fn bindgen_test_layout__cef_life_span_handler_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_life_span_handler_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_life_span_handler_t>(),
        72usize,
        concat!("Size of: ", stringify!(_cef_life_span_handler_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_life_span_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_life_span_handler_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_life_span_handler_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_before_popup) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_life_span_handler_t),
            "::",
            stringify!(on_before_popup)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_after_created) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_life_span_handler_t),
            "::",
            stringify!(on_after_created)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).do_close) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_life_span_handler_t),
            "::",
            stringify!(do_close)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_before_close) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_life_span_handler_t),
            "::",
            stringify!(on_before_close)
        )
    );
}
#[doc = "\n Implement this structure to handle events related to browser life span. The\n functions of this structure will be called on the UI thread unless otherwise\n indicated.\n"]
pub type cef_life_span_handler_t = _cef_life_span_handler_t;
#[doc = "\n Implement this structure to handle events related to browser load status. The\n functions of this structure will be called on the browser process UI thread\n or render process main thread (TID_RENDERER).\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_load_handler_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Called when the loading state has changed. This callback will be executed\n twice -- once when loading is initiated either programmatically or by user\n action, and once when loading is terminated due to completion, cancellation\n of failure. It will be called before any calls to OnLoadStart and after all\n calls to OnLoadError and/or OnLoadEnd.\n"]
    pub on_loading_state_change: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_load_handler_t,
            browser: *mut _cef_browser_t,
            isLoading: ::core::ffi::c_int,
            canGoBack: ::core::ffi::c_int,
            canGoForward: ::core::ffi::c_int,
        ),
    >,
    #[doc = "\n Called after a navigation has been committed and before the browser begins\n loading contents in the frame. The |frame| value will never be NULL -- call\n the is_main() function to check if this frame is the main frame.\n |transition_type| provides information about the source of the navigation\n and an accurate value is only available in the browser process. Multiple\n frames may be loading at the same time. Sub-frames may start or continue\n loading after the main frame load has ended. This function will not be\n called for same page navigations (fragments, history state, etc.) or for\n navigations that fail or are canceled before commit. For notification of\n overall browser load status use OnLoadingStateChange instead.\n"]
    pub on_load_start: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_load_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            transition_type: cef_transition_type_t,
        ),
    >,
    #[doc = "\n Called when the browser is done loading a frame. The |frame| value will\n never be NULL -- call the is_main() function to check if this frame is the\n main frame. Multiple frames may be loading at the same time. Sub-frames may\n start or continue loading after the main frame load has ended. This\n function will not be called for same page navigations (fragments, history\n state, etc.) or for navigations that fail or are canceled before commit.\n For notification of overall browser load status use OnLoadingStateChange\n instead.\n"]
    pub on_load_end: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_load_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            httpStatusCode: ::core::ffi::c_int,
        ),
    >,
    #[doc = "\n Called when a navigation fails or is canceled. This function may be called\n by itself if before commit or in combination with OnLoadStart/OnLoadEnd if\n after commit. |errorCode| is the error code number, |errorText| is the\n error text and |failedUrl| is the URL that failed to load. See\n net\\base\\net_error_list.h for complete descriptions of the error codes.\n"]
    pub on_load_error: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_load_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            errorCode: cef_errorcode_t,
            errorText: *const cef_string_t,
            failedUrl: *const cef_string_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_load_handler_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_load_handler_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_load_handler_t>(),
        72usize,
        concat!("Size of: ", stringify!(_cef_load_handler_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_load_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_load_handler_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_load_handler_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_loading_state_change) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_load_handler_t),
            "::",
            stringify!(on_loading_state_change)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_load_start) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_load_handler_t),
            "::",
            stringify!(on_load_start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_load_end) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_load_handler_t),
            "::",
            stringify!(on_load_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_load_error) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_load_handler_t),
            "::",
            stringify!(on_load_error)
        )
    );
}
#[doc = "\n Implement this structure to handle events related to browser load status. The\n functions of this structure will be called on the browser process UI thread\n or render process main thread (TID_RENDERER).\n"]
pub type cef_load_handler_t = _cef_load_handler_t;
#[doc = "\n Structure representing print settings.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_print_settings_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Returns true (1) if this object is valid. Do not call any other functions\n if this function returns false (0).\n"]
    pub is_valid: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if the values of this object are read-only. Some APIs may\n expose read-only objects.\n"]
    pub is_read_only: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Set the page orientation.\n"]
    pub set_orientation: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t, landscape: ::core::ffi::c_int),
    >,
    #[doc = "\n Returns true (1) if the orientation is landscape.\n"]
    pub is_landscape: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Set the printer printable area in device units. Some platforms already\n provide flipped area. Set |landscape_needs_flip| to false (0) on those\n platforms to avoid double flipping.\n"]
    pub set_printer_printable_area: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_print_settings_t,
            physical_size_device_units: *const cef_size_t,
            printable_area_device_units: *const cef_rect_t,
            landscape_needs_flip: ::core::ffi::c_int,
        ),
    >,
    #[doc = "\n Set the device name.\n"]
    pub set_device_name: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t, name: *const cef_string_t),
    >,
    #[doc = "\n Get the device name.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_device_name: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Set the DPI (dots per inch).\n"]
    pub set_dpi: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t, dpi: ::core::ffi::c_int),
    >,
    #[doc = "\n Get the DPI (dots per inch).\n"]
    pub get_dpi: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Set the page ranges.\n"]
    pub set_page_ranges: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_print_settings_t,
            rangesCount: usize,
            ranges: *const cef_range_t,
        ),
    >,
    #[doc = "\n Returns the number of page ranges that currently exist.\n"]
    pub get_page_ranges_count:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_print_settings_t) -> usize>,
    #[doc = "\n Retrieve the page ranges.\n"]
    pub get_page_ranges: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_print_settings_t,
            rangesCount: *mut usize,
            ranges: *mut cef_range_t,
        ),
    >,
    #[doc = "\n Set whether only the selection will be printed.\n"]
    pub set_selection_only: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t, selection_only: ::core::ffi::c_int),
    >,
    #[doc = "\n Returns true (1) if only the selection will be printed.\n"]
    pub is_selection_only: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Set whether pages will be collated.\n"]
    pub set_collate: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t, collate: ::core::ffi::c_int),
    >,
    #[doc = "\n Returns true (1) if pages will be collated.\n"]
    pub will_collate: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Set the color model.\n"]
    pub set_color_model: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t, model: cef_color_model_t),
    >,
    #[doc = "\n Get the color model.\n"]
    pub get_color_model: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t) -> cef_color_model_t,
    >,
    #[doc = "\n Set the number of copies.\n"]
    pub set_copies: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t, copies: ::core::ffi::c_int),
    >,
    #[doc = "\n Get the number of copies.\n"]
    pub get_copies: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Set the duplex mode.\n"]
    pub set_duplex_mode: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t, mode: cef_duplex_mode_t),
    >,
    #[doc = "\n Get the duplex mode.\n"]
    pub get_duplex_mode: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t) -> cef_duplex_mode_t,
    >,
}
#[test]
fn bindgen_test_layout__cef_print_settings_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_print_settings_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_print_settings_t>(),
        216usize,
        concat!("Size of: ", stringify!(_cef_print_settings_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_print_settings_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_print_settings_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_print_settings_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_valid) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_print_settings_t),
            "::",
            stringify!(is_valid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_read_only) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_print_settings_t),
            "::",
            stringify!(is_read_only)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_orientation) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_print_settings_t),
            "::",
            stringify!(set_orientation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_landscape) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_print_settings_t),
            "::",
            stringify!(is_landscape)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_printer_printable_area) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_print_settings_t),
            "::",
            stringify!(set_printer_printable_area)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_device_name) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_print_settings_t),
            "::",
            stringify!(set_device_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_device_name) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_print_settings_t),
            "::",
            stringify!(get_device_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_dpi) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_print_settings_t),
            "::",
            stringify!(set_dpi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_dpi) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_print_settings_t),
            "::",
            stringify!(get_dpi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_page_ranges) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_print_settings_t),
            "::",
            stringify!(set_page_ranges)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_page_ranges_count) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_print_settings_t),
            "::",
            stringify!(get_page_ranges_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_page_ranges) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_print_settings_t),
            "::",
            stringify!(get_page_ranges)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_selection_only) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_print_settings_t),
            "::",
            stringify!(set_selection_only)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_selection_only) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_print_settings_t),
            "::",
            stringify!(is_selection_only)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_collate) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_print_settings_t),
            "::",
            stringify!(set_collate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).will_collate) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_print_settings_t),
            "::",
            stringify!(will_collate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_color_model) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_print_settings_t),
            "::",
            stringify!(set_color_model)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_color_model) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_print_settings_t),
            "::",
            stringify!(get_color_model)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_copies) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_print_settings_t),
            "::",
            stringify!(set_copies)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_copies) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_print_settings_t),
            "::",
            stringify!(get_copies)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_duplex_mode) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_print_settings_t),
            "::",
            stringify!(set_duplex_mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_duplex_mode) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_print_settings_t),
            "::",
            stringify!(get_duplex_mode)
        )
    );
}
#[doc = "\n Structure representing print settings.\n"]
pub type cef_print_settings_t = _cef_print_settings_t;
#[doc = "\n Callback structure for asynchronous continuation of print dialog requests.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_print_dialog_callback_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Continue printing with the specified |settings|.\n"]
    pub cont: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_print_dialog_callback_t,
            settings: *mut _cef_print_settings_t,
        ),
    >,
    #[doc = "\n Cancel the printing.\n"]
    pub cancel:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_print_dialog_callback_t)>,
}
#[test]
fn bindgen_test_layout__cef_print_dialog_callback_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_print_dialog_callback_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_print_dialog_callback_t>(),
        56usize,
        concat!("Size of: ", stringify!(_cef_print_dialog_callback_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_print_dialog_callback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_print_dialog_callback_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_print_dialog_callback_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cont) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_print_dialog_callback_t),
            "::",
            stringify!(cont)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cancel) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_print_dialog_callback_t),
            "::",
            stringify!(cancel)
        )
    );
}
#[doc = "\n Callback structure for asynchronous continuation of print dialog requests.\n"]
pub type cef_print_dialog_callback_t = _cef_print_dialog_callback_t;
#[doc = "\n Callback structure for asynchronous continuation of print job requests.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_print_job_callback_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Indicate completion of the print job.\n"]
    pub cont: ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_print_job_callback_t)>,
}
#[test]
fn bindgen_test_layout__cef_print_job_callback_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_print_job_callback_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_print_job_callback_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_print_job_callback_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_print_job_callback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_print_job_callback_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_print_job_callback_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cont) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_print_job_callback_t),
            "::",
            stringify!(cont)
        )
    );
}
#[doc = "\n Callback structure for asynchronous continuation of print job requests.\n"]
pub type cef_print_job_callback_t = _cef_print_job_callback_t;
#[doc = "\n Implement this structure to handle printing on Linux. Each browser will have\n only one print job in progress at a time. The functions of this structure\n will be called on the browser process UI thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_print_handler_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Called when printing has started for the specified |browser|. This function\n will be called before the other OnPrint*() functions and irrespective of\n how printing was initiated (e.g. cef_browser_host_t::print(), JavaScript\n window.print() or PDF extension print button).\n"]
    pub on_print_start: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_handler_t, browser: *mut _cef_browser_t),
    >,
    #[doc = "\n Synchronize |settings| with client state. If |get_defaults| is true (1)\n then populate |settings| with the default print settings. Do not keep a\n reference to |settings| outside of this callback.\n"]
    pub on_print_settings: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_print_handler_t,
            browser: *mut _cef_browser_t,
            settings: *mut _cef_print_settings_t,
            get_defaults: ::core::ffi::c_int,
        ),
    >,
    #[doc = "\n Show the print dialog. Execute |callback| once the dialog is dismissed.\n Return true (1) if the dialog will be displayed or false (0) to cancel the\n printing immediately.\n"]
    pub on_print_dialog: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_print_handler_t,
            browser: *mut _cef_browser_t,
            has_selection: ::core::ffi::c_int,
            callback: *mut _cef_print_dialog_callback_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Send the print job to the printer. Execute |callback| once the job is\n completed. Return true (1) if the job will proceed or false (0) to cancel\n the job immediately.\n"]
    pub on_print_job: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_print_handler_t,
            browser: *mut _cef_browser_t,
            document_name: *const cef_string_t,
            pdf_file_path: *const cef_string_t,
            callback: *mut _cef_print_job_callback_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Reset client state related to printing.\n"]
    pub on_print_reset: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_handler_t, browser: *mut _cef_browser_t),
    >,
    #[doc = "\n Return the PDF paper size in device units. Used in combination with\n cef_browser_host_t::print_to_pdf().\n"]
    pub get_pdf_paper_size: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_print_handler_t,
            browser: *mut _cef_browser_t,
            device_units_per_inch: ::core::ffi::c_int,
        ) -> cef_size_t,
    >,
}
#[test]
fn bindgen_test_layout__cef_print_handler_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_print_handler_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_print_handler_t>(),
        88usize,
        concat!("Size of: ", stringify!(_cef_print_handler_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_print_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_print_handler_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_print_handler_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_print_start) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_print_handler_t),
            "::",
            stringify!(on_print_start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_print_settings) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_print_handler_t),
            "::",
            stringify!(on_print_settings)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_print_dialog) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_print_handler_t),
            "::",
            stringify!(on_print_dialog)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_print_job) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_print_handler_t),
            "::",
            stringify!(on_print_job)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_print_reset) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_print_handler_t),
            "::",
            stringify!(on_print_reset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_pdf_paper_size) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_print_handler_t),
            "::",
            stringify!(get_pdf_paper_size)
        )
    );
}
#[doc = "\n Implement this structure to handle printing on Linux. Each browser will have\n only one print job in progress at a time. The functions of this structure\n will be called on the browser process UI thread.\n"]
pub type cef_print_handler_t = _cef_print_handler_t;
#[doc = "\n Implement this structure to handle events when window rendering is disabled.\n The functions of this structure will be called on the UI thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_render_handler_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Return the handler for accessibility notifications. If no handler is\n provided the default implementation will be used.\n"]
    pub get_accessibility_handler: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
        ) -> *mut _cef_accessibility_handler_t,
    >,
    #[doc = "\n Called to retrieve the root window rectangle in screen coordinates. Return\n true (1) if the rectangle was provided. If this function returns false (0)\n the rectangle from GetViewRect will be used.\n"]
    pub get_root_screen_rect: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
            browser: *mut _cef_browser_t,
            rect: *mut cef_rect_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Called to retrieve the view rectangle which is relative to screen\n coordinates. This function must always provide a non-NULL rectangle.\n"]
    pub get_view_rect: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
            browser: *mut _cef_browser_t,
            rect: *mut cef_rect_t,
        ),
    >,
    #[doc = "\n Called to retrieve the translation from view coordinates to actual screen\n coordinates. Return true (1) if the screen coordinates were provided.\n"]
    pub get_screen_point: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
            browser: *mut _cef_browser_t,
            viewX: ::core::ffi::c_int,
            viewY: ::core::ffi::c_int,
            screenX: *mut ::core::ffi::c_int,
            screenY: *mut ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Called to allow the client to fill in the CefScreenInfo object with\n appropriate values. Return true (1) if the |screen_info| structure has been\n modified.\n\n If the screen info rectangle is left NULL the rectangle from GetViewRect\n will be used. If the rectangle is still NULL or invalid popups may not be\n drawn correctly.\n"]
    pub get_screen_info: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
            browser: *mut _cef_browser_t,
            screen_info: *mut _cef_screen_info_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Called when the browser wants to show or hide the popup widget. The popup\n should be shown if |show| is true (1) and hidden if |show| is false (0).\n"]
    pub on_popup_show: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
            browser: *mut _cef_browser_t,
            show: ::core::ffi::c_int,
        ),
    >,
    #[doc = "\n Called when the browser wants to move or resize the popup widget. |rect|\n contains the new location and size in view coordinates.\n"]
    pub on_popup_size: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
            browser: *mut _cef_browser_t,
            rect: *const cef_rect_t,
        ),
    >,
    #[doc = "\n Called when an element should be painted. Pixel values passed to this\n function are scaled relative to view coordinates based on the value of\n CefScreenInfo.device_scale_factor returned from GetScreenInfo. |type|\n indicates whether the element is the view or the popup widget. |buffer|\n contains the pixel data for the whole image. |dirtyRects| contains the set\n of rectangles in pixel coordinates that need to be repainted. |buffer| will\n be |width|*|height|*4 bytes in size and represents a BGRA image with an\n upper-left origin. This function is only called when\n cef_window_tInfo::shared_texture_enabled is set to false (0).\n"]
    pub on_paint: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
            browser: *mut _cef_browser_t,
            type_: cef_paint_element_type_t,
            dirtyRectsCount: usize,
            dirtyRects: *const cef_rect_t,
            buffer: *const ::core::ffi::c_void,
            width: ::core::ffi::c_int,
            height: ::core::ffi::c_int,
        ),
    >,
    #[doc = "\n Called when an element has been rendered to the shared texture handle.\n |type| indicates whether the element is the view or the popup widget.\n |dirtyRects| contains the set of rectangles in pixel coordinates that need\n to be repainted. |shared_handle| is the handle for a D3D11 Texture2D that\n can be accessed via ID3D11Device using the OpenSharedResource function.\n This function is only called when cef_window_tInfo::shared_texture_enabled\n is set to true (1), and is currently only supported on Windows.\n"]
    pub on_accelerated_paint: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
            browser: *mut _cef_browser_t,
            type_: cef_paint_element_type_t,
            dirtyRectsCount: usize,
            dirtyRects: *const cef_rect_t,
            shared_handle: *mut ::core::ffi::c_void,
        ),
    >,
    #[doc = "\n Called when the user starts dragging content in the web view. Contextual\n information about the dragged content is supplied by |drag_data|. (|x|,\n |y|) is the drag start location in screen coordinates. OS APIs that run a\n system message loop may be used within the StartDragging call.\n\n Return false (0) to abort the drag operation. Don't call any of\n cef_browser_host_t::DragSource*Ended* functions after returning false (0).\n\n Return true (1) to handle the drag operation. Call\n cef_browser_host_t::DragSourceEndedAt and DragSourceSystemDragEnded either\n synchronously or asynchronously to inform the web view that the drag\n operation has ended.\n"]
    pub start_dragging: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
            browser: *mut _cef_browser_t,
            drag_data: *mut _cef_drag_data_t,
            allowed_ops: cef_drag_operations_mask_t,
            x: ::core::ffi::c_int,
            y: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Called when the web view wants to update the mouse cursor during a drag &\n drop operation. |operation| describes the allowed operation (none, move,\n copy, link).\n"]
    pub update_drag_cursor: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
            browser: *mut _cef_browser_t,
            operation: cef_drag_operations_mask_t,
        ),
    >,
    #[doc = "\n Called when the scroll offset has changed.\n"]
    pub on_scroll_offset_changed: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
            browser: *mut _cef_browser_t,
            x: f64,
            y: f64,
        ),
    >,
    #[doc = "\n Called when the IME composition range has changed. |selected_range| is the\n range of characters that have been selected. |character_bounds| is the\n bounds of each character in view coordinates.\n"]
    pub on_ime_composition_range_changed: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
            browser: *mut _cef_browser_t,
            selected_range: *const cef_range_t,
            character_boundsCount: usize,
            character_bounds: *const cef_rect_t,
        ),
    >,
    #[doc = "\n Called when text selection has changed for the specified |browser|.\n |selected_text| is the currently selected text and |selected_range| is the\n character range.\n"]
    pub on_text_selection_changed: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
            browser: *mut _cef_browser_t,
            selected_text: *const cef_string_t,
            selected_range: *const cef_range_t,
        ),
    >,
    #[doc = "\n Called when an on-screen keyboard should be shown or hidden for the\n specified |browser|. |input_mode| specifies what kind of keyboard should be\n opened. If |input_mode| is CEF_TEXT_INPUT_MODE_NONE, any existing keyboard\n for this browser should be hidden.\n"]
    pub on_virtual_keyboard_requested: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
            browser: *mut _cef_browser_t,
            input_mode: cef_text_input_mode_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_render_handler_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_render_handler_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_render_handler_t>(),
        160usize,
        concat!("Size of: ", stringify!(_cef_render_handler_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_render_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_render_handler_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_render_handler_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_accessibility_handler) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_render_handler_t),
            "::",
            stringify!(get_accessibility_handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_root_screen_rect) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_render_handler_t),
            "::",
            stringify!(get_root_screen_rect)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_view_rect) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_render_handler_t),
            "::",
            stringify!(get_view_rect)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_screen_point) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_render_handler_t),
            "::",
            stringify!(get_screen_point)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_screen_info) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_render_handler_t),
            "::",
            stringify!(get_screen_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_popup_show) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_render_handler_t),
            "::",
            stringify!(on_popup_show)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_popup_size) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_render_handler_t),
            "::",
            stringify!(on_popup_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_paint) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_render_handler_t),
            "::",
            stringify!(on_paint)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_accelerated_paint) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_render_handler_t),
            "::",
            stringify!(on_accelerated_paint)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start_dragging) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_render_handler_t),
            "::",
            stringify!(start_dragging)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).update_drag_cursor) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_render_handler_t),
            "::",
            stringify!(update_drag_cursor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_scroll_offset_changed) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_render_handler_t),
            "::",
            stringify!(on_scroll_offset_changed)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).on_ime_composition_range_changed) as usize - ptr as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_render_handler_t),
            "::",
            stringify!(on_ime_composition_range_changed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_text_selection_changed) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_render_handler_t),
            "::",
            stringify!(on_text_selection_changed)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).on_virtual_keyboard_requested) as usize - ptr as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_render_handler_t),
            "::",
            stringify!(on_virtual_keyboard_requested)
        )
    );
}
#[doc = "\n Implement this structure to handle events when window rendering is disabled.\n The functions of this structure will be called on the UI thread.\n"]
pub type cef_render_handler_t = _cef_render_handler_t;
#[doc = "\n Callback structure used for asynchronous continuation of authentication\n requests.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_auth_callback_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Continue the authentication request.\n"]
    pub cont: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_auth_callback_t,
            username: *const cef_string_t,
            password: *const cef_string_t,
        ),
    >,
    #[doc = "\n Cancel the authentication request.\n"]
    pub cancel: ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_auth_callback_t)>,
}
#[test]
fn bindgen_test_layout__cef_auth_callback_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_auth_callback_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_auth_callback_t>(),
        56usize,
        concat!("Size of: ", stringify!(_cef_auth_callback_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_auth_callback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_auth_callback_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_auth_callback_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cont) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_auth_callback_t),
            "::",
            stringify!(cont)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cancel) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_auth_callback_t),
            "::",
            stringify!(cancel)
        )
    );
}
#[doc = "\n Callback structure used for asynchronous continuation of authentication\n requests.\n"]
pub type cef_auth_callback_t = _cef_auth_callback_t;
#[doc = "\n Callback structure used for asynchronous continuation of url requests.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_request_callback_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Continue the url request. If |allow| is true (1) the request will be\n continued. Otherwise, the request will be canceled.\n"]
    pub cont: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_callback_t, allow: ::core::ffi::c_int),
    >,
    #[doc = "\n Cancel the url request.\n"]
    pub cancel: ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_request_callback_t)>,
}
#[test]
fn bindgen_test_layout__cef_request_callback_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_request_callback_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_request_callback_t>(),
        56usize,
        concat!("Size of: ", stringify!(_cef_request_callback_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_request_callback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_request_callback_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_callback_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cont) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_callback_t),
            "::",
            stringify!(cont)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cancel) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_callback_t),
            "::",
            stringify!(cancel)
        )
    );
}
#[doc = "\n Callback structure used for asynchronous continuation of url requests.\n"]
pub type cef_request_callback_t = _cef_request_callback_t;
#[doc = "\n Structure used to represent a web response. The functions of this structure\n may be called on any thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_response_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Returns true (1) if this object is read-only.\n"]
    pub is_read_only: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_response_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Get the response error code. Returns ERR_NONE if there was no error.\n"]
    pub get_error: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_response_t) -> cef_errorcode_t,
    >,
    #[doc = "\n Set the response error code. This can be used by custom scheme handlers to\n return errors during initial request processing.\n"]
    pub set_error: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_response_t, error: cef_errorcode_t),
    >,
    #[doc = "\n Get the response status code.\n"]
    pub get_status: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_response_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Set the response status code.\n"]
    pub set_status: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_response_t, status: ::core::ffi::c_int),
    >,
    #[doc = "\n Get the response status text.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_status_text: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_response_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Set the response status text.\n"]
    pub set_status_text: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_response_t, statusText: *const cef_string_t),
    >,
    #[doc = "\n Get the response mime type.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_mime_type: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_response_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Set the response mime type.\n"]
    pub set_mime_type: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_response_t, mimeType: *const cef_string_t),
    >,
    #[doc = "\n Get the response charset.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_charset: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_response_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Set the response charset.\n"]
    pub set_charset: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_response_t, charset: *const cef_string_t),
    >,
    #[doc = "\n Get the value for the specified response header field.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_header_by_name: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_response_t,
            name: *const cef_string_t,
        ) -> cef_string_userfree_t,
    >,
    #[doc = "\n Set the header |name| to |value|. If |overwrite| is true (1) any existing\n values will be replaced with the new value. If |overwrite| is false (0) any\n existing values will not be overwritten.\n"]
    pub set_header_by_name: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_response_t,
            name: *const cef_string_t,
            value: *const cef_string_t,
            overwrite: ::core::ffi::c_int,
        ),
    >,
    #[doc = "\n Get all response header fields.\n"]
    pub get_header_map: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_response_t, headerMap: cef_string_multimap_t),
    >,
    #[doc = "\n Set all response header fields.\n"]
    pub set_header_map: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_response_t, headerMap: cef_string_multimap_t),
    >,
    #[doc = "\n Get the resolved URL after redirects or changed as a result of HSTS.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_url: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_response_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Set the resolved URL after redirects or changed as a result of HSTS.\n"]
    pub set_url: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_response_t, url: *const cef_string_t),
    >,
}
#[test]
fn bindgen_test_layout__cef_response_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_response_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_response_t>(),
        176usize,
        concat!("Size of: ", stringify!(_cef_response_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_response_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_response_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_response_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_read_only) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_response_t),
            "::",
            stringify!(is_read_only)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_error) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_response_t),
            "::",
            stringify!(get_error)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_error) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_response_t),
            "::",
            stringify!(set_error)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_status) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_response_t),
            "::",
            stringify!(get_status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_status) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_response_t),
            "::",
            stringify!(set_status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_status_text) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_response_t),
            "::",
            stringify!(get_status_text)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_status_text) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_response_t),
            "::",
            stringify!(set_status_text)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_mime_type) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_response_t),
            "::",
            stringify!(get_mime_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_mime_type) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_response_t),
            "::",
            stringify!(set_mime_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_charset) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_response_t),
            "::",
            stringify!(get_charset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_charset) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_response_t),
            "::",
            stringify!(set_charset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_header_by_name) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_response_t),
            "::",
            stringify!(get_header_by_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_header_by_name) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_response_t),
            "::",
            stringify!(set_header_by_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_header_map) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_response_t),
            "::",
            stringify!(get_header_map)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_header_map) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_response_t),
            "::",
            stringify!(set_header_map)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_url) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_response_t),
            "::",
            stringify!(get_url)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_url) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_response_t),
            "::",
            stringify!(set_url)
        )
    );
}
#[doc = "\n Structure used to represent a web response. The functions of this structure\n may be called on any thread.\n"]
pub type cef_response_t = _cef_response_t;
#[doc = "\n Callback for asynchronous continuation of cef_resource_handler_t::skip().\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_resource_skip_callback_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Callback for asynchronous continuation of skip(). If |bytes_skipped| > 0\n then either skip() will be called again until the requested number of bytes\n have been skipped or the request will proceed. If |bytes_skipped| <= 0 the\n request will fail with ERR_REQUEST_RANGE_NOT_SATISFIABLE.\n"]
    pub cont: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_resource_skip_callback_t, bytes_skipped: int64),
    >,
}
#[test]
fn bindgen_test_layout__cef_resource_skip_callback_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_resource_skip_callback_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_resource_skip_callback_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_resource_skip_callback_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_resource_skip_callback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_resource_skip_callback_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_resource_skip_callback_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cont) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_resource_skip_callback_t),
            "::",
            stringify!(cont)
        )
    );
}
#[doc = "\n Callback for asynchronous continuation of cef_resource_handler_t::skip().\n"]
pub type cef_resource_skip_callback_t = _cef_resource_skip_callback_t;
#[doc = "\n Callback for asynchronous continuation of cef_resource_handler_t::read().\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_resource_read_callback_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Callback for asynchronous continuation of read(). If |bytes_read| == 0 the\n response will be considered complete. If |bytes_read| > 0 then read() will\n be called again until the request is complete (based on either the result\n or the expected content length). If |bytes_read| < 0 then the request will\n fail and the |bytes_read| value will be treated as the error code.\n"]
    pub cont: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_read_callback_t,
            bytes_read: ::core::ffi::c_int,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_resource_read_callback_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_resource_read_callback_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_resource_read_callback_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_resource_read_callback_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_resource_read_callback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_resource_read_callback_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_resource_read_callback_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cont) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_resource_read_callback_t),
            "::",
            stringify!(cont)
        )
    );
}
#[doc = "\n Callback for asynchronous continuation of cef_resource_handler_t::read().\n"]
pub type cef_resource_read_callback_t = _cef_resource_read_callback_t;
#[doc = "\n Structure used to implement a custom request handler structure. The functions\n of this structure will be called on the IO thread unless otherwise indicated.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_resource_handler_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Open the response stream. To handle the request immediately set\n |handle_request| to true (1) and return true (1). To decide at a later time\n set |handle_request| to false (0), return true (1), and execute |callback|\n to continue or cancel the request. To cancel the request immediately set\n |handle_request| to true (1) and return false (0). This function will be\n called in sequence but not from a dedicated thread. For backwards\n compatibility set |handle_request| to false (0) and return false (0) and\n the ProcessRequest function will be called.\n"]
    pub open: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_handler_t,
            request: *mut _cef_request_t,
            handle_request: *mut ::core::ffi::c_int,
            callback: *mut _cef_callback_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Begin processing the request. To handle the request return true (1) and\n call cef_callback_t::cont() once the response header information is\n available (cef_callback_t::cont() can also be called from inside this\n function if header information is available immediately). To cancel the\n request return false (0).\n\n WARNING: This function is deprecated. Use Open instead.\n"]
    pub process_request: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_handler_t,
            request: *mut _cef_request_t,
            callback: *mut _cef_callback_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Retrieve response header information. If the response length is not known\n set |response_length| to -1 and read_response() will be called until it\n returns false (0). If the response length is known set |response_length| to\n a positive value and read_response() will be called until it returns false\n (0) or the specified number of bytes have been read. Use the |response|\n object to set the mime type, http status code and other optional header\n values. To redirect the request to a new URL set |redirectUrl| to the new\n URL. |redirectUrl| can be either a relative or fully qualified URL. It is\n also possible to set |response| to a redirect http status code and pass the\n new URL via a Location header. Likewise with |redirectUrl| it is valid to\n set a relative or fully qualified URL as the Location header value. If an\n error occured while setting up the request you can call set_error() on\n |response| to indicate the error condition.\n"]
    pub get_response_headers: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_handler_t,
            response: *mut _cef_response_t,
            response_length: *mut int64,
            redirectUrl: *mut cef_string_t,
        ),
    >,
    #[doc = "\n Skip response data when requested by a Range header. Skip over and discard\n |bytes_to_skip| bytes of response data. If data is available immediately\n set |bytes_skipped| to the number of bytes skipped and return true (1). To\n read the data at a later time set |bytes_skipped| to 0, return true (1) and\n execute |callback| when the data is available. To indicate failure set\n |bytes_skipped| to < 0 (e.g. -2 for ERR_FAILED) and return false (0). This\n function will be called in sequence but not from a dedicated thread.\n"]
    pub skip: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_handler_t,
            bytes_to_skip: int64,
            bytes_skipped: *mut int64,
            callback: *mut _cef_resource_skip_callback_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Read response data. If data is available immediately copy up to\n |bytes_to_read| bytes into |data_out|, set |bytes_read| to the number of\n bytes copied, and return true (1). To read the data at a later time keep a\n pointer to |data_out|, set |bytes_read| to 0, return true (1) and execute\n |callback| when the data is available (|data_out| will remain valid until\n the callback is executed). To indicate response completion set |bytes_read|\n to 0 and return false (0). To indicate failure set |bytes_read| to < 0\n (e.g. -2 for ERR_FAILED) and return false (0). This function will be called\n in sequence but not from a dedicated thread. For backwards compatibility\n set |bytes_read| to -1 and return false (0) and the ReadResponse function\n will be called.\n"]
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_handler_t,
            data_out: *mut ::core::ffi::c_void,
            bytes_to_read: ::core::ffi::c_int,
            bytes_read: *mut ::core::ffi::c_int,
            callback: *mut _cef_resource_read_callback_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Read response data. If data is available immediately copy up to\n |bytes_to_read| bytes into |data_out|, set |bytes_read| to the number of\n bytes copied, and return true (1). To read the data at a later time set\n |bytes_read| to 0, return true (1) and call cef_callback_t::cont() when the\n data is available. To indicate response completion return false (0).\n\n WARNING: This function is deprecated. Use Skip and Read instead.\n"]
    pub read_response: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_handler_t,
            data_out: *mut ::core::ffi::c_void,
            bytes_to_read: ::core::ffi::c_int,
            bytes_read: *mut ::core::ffi::c_int,
            callback: *mut _cef_callback_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Request processing has been canceled.\n"]
    pub cancel: ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_resource_handler_t)>,
}
#[test]
fn bindgen_test_layout__cef_resource_handler_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_resource_handler_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_resource_handler_t>(),
        96usize,
        concat!("Size of: ", stringify!(_cef_resource_handler_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_resource_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_resource_handler_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_resource_handler_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).open) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_resource_handler_t),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).process_request) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_resource_handler_t),
            "::",
            stringify!(process_request)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_response_headers) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_resource_handler_t),
            "::",
            stringify!(get_response_headers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).skip) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_resource_handler_t),
            "::",
            stringify!(skip)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_resource_handler_t),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).read_response) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_resource_handler_t),
            "::",
            stringify!(read_response)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cancel) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_resource_handler_t),
            "::",
            stringify!(cancel)
        )
    );
}
#[doc = "\n Structure used to implement a custom request handler structure. The functions\n of this structure will be called on the IO thread unless otherwise indicated.\n"]
pub type cef_resource_handler_t = _cef_resource_handler_t;
#[doc = "\n Implement this structure to filter resource response content. The functions\n of this structure will be called on the browser process IO thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_response_filter_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Initialize the response filter. Will only be called a single time. The\n filter will not be installed if this function returns false (0).\n"]
    pub init_filter: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_response_filter_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Called to filter a chunk of data. Expected usage is as follows:\n\n  A. Read input data from |data_in| and set |data_in_read| to the number of\n     bytes that were read up to a maximum of |data_in_size|. |data_in| will\n     be NULL if |data_in_size| is zero.\n  B. Write filtered output data to |data_out| and set |data_out_written| to\n     the number of bytes that were written up to a maximum of\n     |data_out_size|. If no output data was written then all data must be\n     read from |data_in| (user must set |data_in_read| = |data_in_size|).\n  C. Return RESPONSE_FILTER_DONE if all output data was written or\n     RESPONSE_FILTER_NEED_MORE_DATA if output data is still pending.\n\n This function will be called repeatedly until the input buffer has been\n fully read (user sets |data_in_read| = |data_in_size|) and there is no more\n input data to filter (the resource response is complete). This function may\n then be called an additional time with an NULL input buffer if the user\n filled the output buffer (set |data_out_written| = |data_out_size|) and\n returned RESPONSE_FILTER_NEED_MORE_DATA to indicate that output data is\n still pending.\n\n Calls to this function will stop when one of the following conditions is\n met:\n\n  A. There is no more input data to filter (the resource response is\n     complete) and the user sets |data_out_written| = 0 or returns\n     RESPONSE_FILTER_DONE to indicate that all data has been written, or;\n  B. The user returns RESPONSE_FILTER_ERROR to indicate an error.\n\n Do not keep a reference to the buffers passed to this function.\n"]
    pub filter: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_response_filter_t,
            data_in: *mut ::core::ffi::c_void,
            data_in_size: usize,
            data_in_read: *mut usize,
            data_out: *mut ::core::ffi::c_void,
            data_out_size: usize,
            data_out_written: *mut usize,
        ) -> cef_response_filter_status_t,
    >,
}
#[test]
fn bindgen_test_layout__cef_response_filter_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_response_filter_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_response_filter_t>(),
        56usize,
        concat!("Size of: ", stringify!(_cef_response_filter_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_response_filter_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_response_filter_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_response_filter_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init_filter) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_response_filter_t),
            "::",
            stringify!(init_filter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).filter) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_response_filter_t),
            "::",
            stringify!(filter)
        )
    );
}
#[doc = "\n Implement this structure to filter resource response content. The functions\n of this structure will be called on the browser process IO thread.\n"]
pub type cef_response_filter_t = _cef_response_filter_t;
#[doc = "\n Implement this structure to handle events related to browser requests. The\n functions of this structure will be called on the IO thread unless otherwise\n indicated.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_resource_request_handler_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Called on the IO thread before a resource request is loaded. The |browser|\n and |frame| values represent the source of the request, and may be NULL for\n requests originating from service workers or cef_urlrequest_t. To\n optionally filter cookies for the request return a\n cef_cookie_access_filter_t object. The |request| object cannot not be\n modified in this callback.\n"]
    pub get_cookie_access_filter: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_request_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            request: *mut _cef_request_t,
        ) -> *mut _cef_cookie_access_filter_t,
    >,
    #[doc = "\n Called on the IO thread before a resource request is loaded. The |browser|\n and |frame| values represent the source of the request, and may be NULL for\n requests originating from service workers or cef_urlrequest_t. To redirect\n or change the resource load optionally modify |request|. Modification of\n the request URL will be treated as a redirect. Return RV_CONTINUE to\n continue the request immediately. Return RV_CONTINUE_ASYNC and call\n cef_request_callback_t:: cont() at a later time to continue or cancel the\n request asynchronously. Return RV_CANCEL to cancel the request immediately.\n\n"]
    pub on_before_resource_load: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_request_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            request: *mut _cef_request_t,
            callback: *mut _cef_request_callback_t,
        ) -> cef_return_value_t,
    >,
    #[doc = "\n Called on the IO thread before a resource is loaded. The |browser| and\n |frame| values represent the source of the request, and may be NULL for\n requests originating from service workers or cef_urlrequest_t. To allow the\n resource to load using the default network loader return NULL. To specify a\n handler for the resource return a cef_resource_handler_t object. The\n |request| object cannot not be modified in this callback.\n"]
    pub get_resource_handler: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_request_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            request: *mut _cef_request_t,
        ) -> *mut _cef_resource_handler_t,
    >,
    #[doc = "\n Called on the IO thread when a resource load is redirected. The |browser|\n and |frame| values represent the source of the request, and may be NULL for\n requests originating from service workers or cef_urlrequest_t. The\n |request| parameter will contain the old URL and other request-related\n information. The |response| parameter will contain the response that\n resulted in the redirect. The |new_url| parameter will contain the new URL\n and can be changed if desired. The |request| and |response| objects cannot\n be modified in this callback.\n"]
    pub on_resource_redirect: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_request_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            request: *mut _cef_request_t,
            response: *mut _cef_response_t,
            new_url: *mut cef_string_t,
        ),
    >,
    #[doc = "\n Called on the IO thread when a resource response is received. The |browser|\n and |frame| values represent the source of the request, and may be NULL for\n requests originating from service workers or cef_urlrequest_t. To allow the\n resource load to proceed without modification return false (0). To redirect\n or retry the resource load optionally modify |request| and return true (1).\n Modification of the request URL will be treated as a redirect. Requests\n handled using the default network loader cannot be redirected in this\n callback. The |response| object cannot be modified in this callback.\n\n WARNING: Redirecting using this function is deprecated. Use\n OnBeforeResourceLoad or GetResourceHandler to perform redirects.\n"]
    pub on_resource_response: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_request_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            request: *mut _cef_request_t,
            response: *mut _cef_response_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Called on the IO thread to optionally filter resource response content. The\n |browser| and |frame| values represent the source of the request, and may\n be NULL for requests originating from service workers or cef_urlrequest_t.\n |request| and |response| represent the request and response respectively\n and cannot be modified in this callback.\n"]
    pub get_resource_response_filter: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_request_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            request: *mut _cef_request_t,
            response: *mut _cef_response_t,
        ) -> *mut _cef_response_filter_t,
    >,
    #[doc = "\n Called on the IO thread when a resource load has completed. The |browser|\n and |frame| values represent the source of the request, and may be NULL for\n requests originating from service workers or cef_urlrequest_t. |request|\n and |response| represent the request and response respectively and cannot\n be modified in this callback. |status| indicates the load completion\n status. |received_content_length| is the number of response bytes actually\n read. This function will be called for all requests, including requests\n that are aborted due to CEF shutdown or destruction of the associated\n browser. In cases where the associated browser is destroyed this callback\n may arrive after the cef_life_span_handler_t::OnBeforeClose callback for\n that browser. The cef_frame_t::IsValid function can be used to test for\n this situation, and care should be taken not to call |browser| or |frame|\n functions that modify state (like LoadURL, SendProcessMessage, etc.) if the\n frame is invalid.\n"]
    pub on_resource_load_complete: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_request_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            request: *mut _cef_request_t,
            response: *mut _cef_response_t,
            status: cef_urlrequest_status_t,
            received_content_length: int64,
        ),
    >,
    #[doc = "\n Called on the IO thread to handle requests for URLs with an unknown\n protocol component. The |browser| and |frame| values represent the source\n of the request, and may be NULL for requests originating from service\n workers or cef_urlrequest_t. |request| cannot be modified in this callback.\n Set |allow_os_execution| to true (1) to attempt execution via the\n registered OS protocol handler, if any. SECURITY WARNING: YOU SHOULD USE\n THIS METHOD TO ENFORCE RESTRICTIONS BASED ON SCHEME, HOST OR OTHER URL\n ANALYSIS BEFORE ALLOWING OS EXECUTION.\n"]
    pub on_protocol_execution: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_request_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            request: *mut _cef_request_t,
            allow_os_execution: *mut ::core::ffi::c_int,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_resource_request_handler_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_resource_request_handler_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_resource_request_handler_t>(),
        104usize,
        concat!("Size of: ", stringify!(_cef_resource_request_handler_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_resource_request_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_resource_request_handler_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_resource_request_handler_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_cookie_access_filter) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_resource_request_handler_t),
            "::",
            stringify!(get_cookie_access_filter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_before_resource_load) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_resource_request_handler_t),
            "::",
            stringify!(on_before_resource_load)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_resource_handler) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_resource_request_handler_t),
            "::",
            stringify!(get_resource_handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_resource_redirect) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_resource_request_handler_t),
            "::",
            stringify!(on_resource_redirect)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_resource_response) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_resource_request_handler_t),
            "::",
            stringify!(on_resource_response)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).get_resource_response_filter) as usize - ptr as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_resource_request_handler_t),
            "::",
            stringify!(get_resource_response_filter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_resource_load_complete) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_resource_request_handler_t),
            "::",
            stringify!(on_resource_load_complete)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_protocol_execution) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_resource_request_handler_t),
            "::",
            stringify!(on_protocol_execution)
        )
    );
}
#[doc = "\n Implement this structure to handle events related to browser requests. The\n functions of this structure will be called on the IO thread unless otherwise\n indicated.\n"]
pub type cef_resource_request_handler_t = _cef_resource_request_handler_t;
#[doc = "\n Implement this structure to filter cookies that may be sent or received from\n resource requests. The functions of this structure will be called on the IO\n thread unless otherwise indicated.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_cookie_access_filter_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Called on the IO thread before a resource request is sent. The |browser|\n and |frame| values represent the source of the request, and may be NULL for\n requests originating from service workers or cef_urlrequest_t. |request|\n cannot be modified in this callback. Return true (1) if the specified\n cookie can be sent with the request or false (0) otherwise.\n"]
    pub can_send_cookie: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_cookie_access_filter_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            request: *mut _cef_request_t,
            cookie: *const _cef_cookie_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Called on the IO thread after a resource response is received. The\n |browser| and |frame| values represent the source of the request, and may\n be NULL for requests originating from service workers or cef_urlrequest_t.\n |request| cannot be modified in this callback. Return true (1) if the\n specified cookie returned with the response can be saved or false (0)\n otherwise.\n"]
    pub can_save_cookie: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_cookie_access_filter_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            request: *mut _cef_request_t,
            response: *mut _cef_response_t,
            cookie: *const _cef_cookie_t,
        ) -> ::core::ffi::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_cookie_access_filter_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_cookie_access_filter_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_cookie_access_filter_t>(),
        56usize,
        concat!("Size of: ", stringify!(_cef_cookie_access_filter_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_cookie_access_filter_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_cookie_access_filter_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_cookie_access_filter_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).can_send_cookie) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_cookie_access_filter_t),
            "::",
            stringify!(can_send_cookie)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).can_save_cookie) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_cookie_access_filter_t),
            "::",
            stringify!(can_save_cookie)
        )
    );
}
#[doc = "\n Implement this structure to filter cookies that may be sent or received from\n resource requests. The functions of this structure will be called on the IO\n thread unless otherwise indicated.\n"]
pub type cef_cookie_access_filter_t = _cef_cookie_access_filter_t;
#[doc = "\n Structure representing SSL information.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_sslinfo_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Returns a bitmask containing any and all problems verifying the server\n certificate.\n"]
    pub get_cert_status: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_sslinfo_t) -> cef_cert_status_t,
    >,
    #[doc = "\n Returns the X.509 certificate.\n"]
    pub get_x509certificate: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_sslinfo_t) -> *mut _cef_x509certificate_t,
    >,
}
#[test]
fn bindgen_test_layout__cef_sslinfo_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_sslinfo_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_sslinfo_t>(),
        56usize,
        concat!("Size of: ", stringify!(_cef_sslinfo_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_sslinfo_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_sslinfo_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_sslinfo_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_cert_status) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_sslinfo_t),
            "::",
            stringify!(get_cert_status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_x509certificate) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_sslinfo_t),
            "::",
            stringify!(get_x509certificate)
        )
    );
}
#[doc = "\n Structure representing SSL information.\n"]
pub type cef_sslinfo_t = _cef_sslinfo_t;
#[doc = "\n Callback structure used to select a client certificate for authentication.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_select_client_certificate_callback_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Chooses the specified certificate for client certificate authentication.\n NULL value means that no client certificate should be used.\n"]
    pub select: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_select_client_certificate_callback_t,
            cert: *mut _cef_x509certificate_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_select_client_certificate_callback_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_select_client_certificate_callback_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_select_client_certificate_callback_t>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_cef_select_client_certificate_callback_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_select_client_certificate_callback_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_cef_select_client_certificate_callback_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_select_client_certificate_callback_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).select) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_select_client_certificate_callback_t),
            "::",
            stringify!(select)
        )
    );
}
#[doc = "\n Callback structure used to select a client certificate for authentication.\n"]
pub type cef_select_client_certificate_callback_t = _cef_select_client_certificate_callback_t;
#[doc = "\n Implement this structure to handle events related to browser requests. The\n functions of this structure will be called on the thread indicated.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_request_handler_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Called on the UI thread before browser navigation. Return true (1) to\n cancel the navigation or false (0) to allow the navigation to proceed. The\n |request| object cannot be modified in this callback.\n cef_load_handler_t::OnLoadingStateChange will be called twice in all cases.\n If the navigation is allowed cef_load_handler_t::OnLoadStart and\n cef_load_handler_t::OnLoadEnd will be called. If the navigation is canceled\n cef_load_handler_t::OnLoadError will be called with an |errorCode| value of\n ERR_ABORTED. The |user_gesture| value will be true (1) if the browser\n navigated via explicit user gesture (e.g. clicking a link) or false (0) if\n it navigated automatically (e.g. via the DomContentLoaded event).\n"]
    pub on_before_browse: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            request: *mut _cef_request_t,
            user_gesture: ::core::ffi::c_int,
            is_redirect: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Called on the UI thread before OnBeforeBrowse in certain limited cases\n where navigating a new or different browser might be desirable. This\n includes user-initiated navigation that might open in a special way (e.g.\n links clicked via middle-click or ctrl + left-click) and certain types of\n cross-origin navigation initiated from the renderer process (e.g.\n navigating the top-level frame to/from a file URL). The |browser| and\n |frame| values represent the source of the navigation. The\n |target_disposition| value indicates where the user intended to navigate\n the browser based on standard Chromium behaviors (e.g. current tab, new\n tab, etc). The |user_gesture| value will be true (1) if the browser\n navigated via explicit user gesture (e.g. clicking a link) or false (0) if\n it navigated automatically (e.g. via the DomContentLoaded event). Return\n true (1) to cancel the navigation or false (0) to allow the navigation to\n proceed in the source browser's top-level frame.\n"]
    pub on_open_urlfrom_tab: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            target_url: *const cef_string_t,
            target_disposition: cef_window_open_disposition_t,
            user_gesture: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Called on the browser process IO thread before a resource request is\n initiated. The |browser| and |frame| values represent the source of the\n request. |request| represents the request contents and cannot be modified\n in this callback. |is_navigation| will be true (1) if the resource request\n is a navigation. |is_download| will be true (1) if the resource request is\n a download. |request_initiator| is the origin (scheme + domain) of the page\n that initiated the request. Set |disable_default_handling| to true (1) to\n disable default handling of the request, in which case it will need to be\n handled via cef_resource_request_handler_t::GetResourceHandler or it will\n be canceled. To allow the resource load to proceed with default handling\n return NULL. To specify a handler for the resource return a\n cef_resource_request_handler_t object. If this callback returns NULL the\n same function will be called on the associated\n cef_request_context_handler_t, if any.\n"]
    pub get_resource_request_handler: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            request: *mut _cef_request_t,
            is_navigation: ::core::ffi::c_int,
            is_download: ::core::ffi::c_int,
            request_initiator: *const cef_string_t,
            disable_default_handling: *mut ::core::ffi::c_int,
        ) -> *mut _cef_resource_request_handler_t,
    >,
    #[doc = "\n Called on the IO thread when the browser needs credentials from the user.\n |origin_url| is the origin making this authentication request. |isProxy|\n indicates whether the host is a proxy server. |host| contains the hostname\n and |port| contains the port number. |realm| is the realm of the challenge\n and may be NULL. |scheme| is the authentication scheme used, such as\n \"basic\" or \"digest\", and will be NULL if the source of the request is an\n FTP server. Return true (1) to continue the request and call\n cef_auth_callback_t::cont() either in this function or at a later time when\n the authentication information is available. Return false (0) to cancel the\n request immediately.\n"]
    pub get_auth_credentials: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_handler_t,
            browser: *mut _cef_browser_t,
            origin_url: *const cef_string_t,
            isProxy: ::core::ffi::c_int,
            host: *const cef_string_t,
            port: ::core::ffi::c_int,
            realm: *const cef_string_t,
            scheme: *const cef_string_t,
            callback: *mut _cef_auth_callback_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Called on the IO thread when JavaScript requests a specific storage quota\n size via the webkitStorageInfo.requestQuota function. |origin_url| is the\n origin of the page making the request. |new_size| is the requested quota\n size in bytes. Return true (1) to continue the request and call\n cef_request_callback_t::cont() either in this function or at a later time\n to grant or deny the request. Return false (0) to cancel the request\n immediately.\n"]
    pub on_quota_request: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_handler_t,
            browser: *mut _cef_browser_t,
            origin_url: *const cef_string_t,
            new_size: int64,
            callback: *mut _cef_request_callback_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Called on the UI thread to handle requests for URLs with an invalid SSL\n certificate. Return true (1) and call cef_request_callback_t::cont() either\n in this function or at a later time to continue or cancel the request.\n Return false (0) to cancel the request immediately. If\n CefSettings.ignore_certificate_errors is set all invalid certificates will\n be accepted without calling this function.\n"]
    pub on_certificate_error: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_handler_t,
            browser: *mut _cef_browser_t,
            cert_error: cef_errorcode_t,
            request_url: *const cef_string_t,
            ssl_info: *mut _cef_sslinfo_t,
            callback: *mut _cef_request_callback_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Called on the UI thread when a client certificate is being requested for\n authentication. Return false (0) to use the default behavior and\n automatically select the first certificate available. Return true (1) and\n call cef_select_client_certificate_callback_t::Select either in this\n function or at a later time to select a certificate. Do not call Select or\n call it with NULL to continue without using any certificate. |isProxy|\n indicates whether the host is an HTTPS proxy or the origin server. |host|\n and |port| contains the hostname and port of the SSL server. |certificates|\n is the list of certificates to choose from; this list has already been\n pruned by Chromium so that it only contains certificates from issuers that\n the server trusts.\n"]
    pub on_select_client_certificate: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_handler_t,
            browser: *mut _cef_browser_t,
            isProxy: ::core::ffi::c_int,
            host: *const cef_string_t,
            port: ::core::ffi::c_int,
            certificatesCount: usize,
            certificates: *const *mut _cef_x509certificate_t,
            callback: *mut _cef_select_client_certificate_callback_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Called on the browser process UI thread when a plugin has crashed.\n |plugin_path| is the path of the plugin that crashed.\n"]
    pub on_plugin_crashed: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_handler_t,
            browser: *mut _cef_browser_t,
            plugin_path: *const cef_string_t,
        ),
    >,
    #[doc = "\n Called on the browser process UI thread when the render view associated\n with |browser| is ready to receive/handle IPC messages in the render\n process.\n"]
    pub on_render_view_ready: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_handler_t, browser: *mut _cef_browser_t),
    >,
    #[doc = "\n Called on the browser process UI thread when the render process terminates\n unexpectedly. |status| indicates how the process terminated.\n"]
    pub on_render_process_terminated: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_handler_t,
            browser: *mut _cef_browser_t,
            status: cef_termination_status_t,
        ),
    >,
    #[doc = "\n Called on the browser process UI thread when the window.document object of\n the main frame has been created.\n"]
    pub on_document_available_in_main_frame: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_handler_t, browser: *mut _cef_browser_t),
    >,
}
#[test]
fn bindgen_test_layout__cef_request_handler_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_request_handler_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_request_handler_t>(),
        128usize,
        concat!("Size of: ", stringify!(_cef_request_handler_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_request_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_request_handler_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_handler_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_before_browse) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_handler_t),
            "::",
            stringify!(on_before_browse)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_open_urlfrom_tab) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_handler_t),
            "::",
            stringify!(on_open_urlfrom_tab)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).get_resource_request_handler) as usize - ptr as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_handler_t),
            "::",
            stringify!(get_resource_request_handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_auth_credentials) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_handler_t),
            "::",
            stringify!(get_auth_credentials)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_quota_request) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_handler_t),
            "::",
            stringify!(on_quota_request)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_certificate_error) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_handler_t),
            "::",
            stringify!(on_certificate_error)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).on_select_client_certificate) as usize - ptr as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_handler_t),
            "::",
            stringify!(on_select_client_certificate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_plugin_crashed) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_handler_t),
            "::",
            stringify!(on_plugin_crashed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_render_view_ready) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_handler_t),
            "::",
            stringify!(on_render_view_ready)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).on_render_process_terminated) as usize - ptr as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_handler_t),
            "::",
            stringify!(on_render_process_terminated)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).on_document_available_in_main_frame) as usize
                - ptr as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_handler_t),
            "::",
            stringify!(on_document_available_in_main_frame)
        )
    );
}
#[doc = "\n Implement this structure to handle events related to browser requests. The\n functions of this structure will be called on the thread indicated.\n"]
pub type cef_request_handler_t = _cef_request_handler_t;
#[doc = "\n Implement this structure to provide handler implementations.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_client_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Return the handler for audio rendering events.\n"]
    pub get_audio_handler: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_audio_handler_t,
    >,
    #[doc = "\n Return the handler for context menus. If no handler is provided the default\n implementation will be used.\n"]
    pub get_context_menu_handler: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_context_menu_handler_t,
    >,
    #[doc = "\n Return the handler for dialogs. If no handler is provided the default\n implementation will be used.\n"]
    pub get_dialog_handler: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_dialog_handler_t,
    >,
    #[doc = "\n Return the handler for browser display state events.\n"]
    pub get_display_handler: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_display_handler_t,
    >,
    #[doc = "\n Return the handler for download events. If no handler is returned downloads\n will not be allowed.\n"]
    pub get_download_handler: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_download_handler_t,
    >,
    #[doc = "\n Return the handler for drag events.\n"]
    pub get_drag_handler: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_drag_handler_t,
    >,
    #[doc = "\n Return the handler for find result events.\n"]
    pub get_find_handler: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_find_handler_t,
    >,
    #[doc = "\n Return the handler for focus events.\n"]
    pub get_focus_handler: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_focus_handler_t,
    >,
    #[doc = "\n Return the handler for JavaScript dialogs. If no handler is provided the\n default implementation will be used.\n"]
    pub get_jsdialog_handler: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_jsdialog_handler_t,
    >,
    #[doc = "\n Return the handler for keyboard events.\n"]
    pub get_keyboard_handler: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_keyboard_handler_t,
    >,
    #[doc = "\n Return the handler for browser life span events.\n"]
    pub get_life_span_handler: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_life_span_handler_t,
    >,
    #[doc = "\n Return the handler for browser load status events.\n"]
    pub get_load_handler: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_load_handler_t,
    >,
    #[doc = "\n Return the handler for printing on Linux. If a print handler is not\n provided then printing will not be supported on the Linux platform.\n"]
    pub get_print_handler: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_print_handler_t,
    >,
    #[doc = "\n Return the handler for off-screen rendering events.\n"]
    pub get_render_handler: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_render_handler_t,
    >,
    #[doc = "\n Return the handler for browser request events.\n"]
    pub get_request_handler: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_request_handler_t,
    >,
    #[doc = "\n Called when a new message is received from a different process. Return true\n (1) if the message was handled or false (0) otherwise. Do not keep a\n reference to or attempt to access the message outside of this callback.\n"]
    pub on_process_message_received: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_client_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            source_process: cef_process_id_t,
            message: *mut _cef_process_message_t,
        ) -> ::core::ffi::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_client_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_client_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_client_t>(),
        168usize,
        concat!("Size of: ", stringify!(_cef_client_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_client_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_client_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_client_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_audio_handler) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_client_t),
            "::",
            stringify!(get_audio_handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_context_menu_handler) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_client_t),
            "::",
            stringify!(get_context_menu_handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_dialog_handler) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_client_t),
            "::",
            stringify!(get_dialog_handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_display_handler) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_client_t),
            "::",
            stringify!(get_display_handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_download_handler) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_client_t),
            "::",
            stringify!(get_download_handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_drag_handler) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_client_t),
            "::",
            stringify!(get_drag_handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_find_handler) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_client_t),
            "::",
            stringify!(get_find_handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_focus_handler) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_client_t),
            "::",
            stringify!(get_focus_handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_jsdialog_handler) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_client_t),
            "::",
            stringify!(get_jsdialog_handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_keyboard_handler) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_client_t),
            "::",
            stringify!(get_keyboard_handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_life_span_handler) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_client_t),
            "::",
            stringify!(get_life_span_handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_load_handler) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_client_t),
            "::",
            stringify!(get_load_handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_print_handler) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_client_t),
            "::",
            stringify!(get_print_handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_render_handler) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_client_t),
            "::",
            stringify!(get_render_handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_request_handler) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_client_t),
            "::",
            stringify!(get_request_handler)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).on_process_message_received) as usize - ptr as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_client_t),
            "::",
            stringify!(on_process_message_received)
        )
    );
}
#[doc = "\n Implement this structure to provide handler implementations.\n"]
pub type cef_client_t = _cef_client_t;
#[doc = "\n Structure used to create and/or parse command line arguments. Arguments with\n '--', '-' and, on Windows, '/' prefixes are considered switches. Switches\n will always precede any arguments without switch prefixes. Switches can\n optionally have a value specified using the '=' delimiter (e.g.\n \"-switch=value\"). An argument of \"--\" will terminate switch parsing with all\n subsequent tokens, regardless of prefix, being interpreted as non-switch\n arguments. Switch names are considered case-insensitive. This structure can\n be used before cef_initialize() is called.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_command_line_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Returns true (1) if this object is valid. Do not call any other functions\n if this function returns false (0).\n"]
    pub is_valid: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if the values of this object are read-only. Some APIs may\n expose read-only objects.\n"]
    pub is_read_only: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns a writable copy of this object.\n"]
    pub copy: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t) -> *mut _cef_command_line_t,
    >,
    #[doc = "\n Initialize the command line with the specified |argc| and |argv| values.\n The first argument must be the name of the program. This function is only\n supported on non-Windows platforms.\n"]
    pub init_from_argv: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_command_line_t,
            argc: ::core::ffi::c_int,
            argv: *const *const ::core::ffi::c_char,
        ),
    >,
    #[doc = "\n Initialize the command line with the string returned by calling\n GetCommandLineW(). This function is only supported on Windows.\n"]
    pub init_from_string: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t, command_line: *const cef_string_t),
    >,
    #[doc = "\n Reset the command-line switches and arguments but leave the program\n component unchanged.\n"]
    pub reset: ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_command_line_t)>,
    #[doc = "\n Retrieve the original command line string as a vector of strings. The argv\n array: { program, [(--|-|/)switch[=value]]*, [--], [argument]* }\n"]
    pub get_argv: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t, argv: cef_string_list_t),
    >,
    #[doc = "\n Constructs and returns the represented command line string. Use this\n function cautiously because quoting behavior is unclear.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_command_line_string: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Get the program part of the command line string (the first item).\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_program: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Set the program part of the command line string (the first item).\n"]
    pub set_program: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t, program: *const cef_string_t),
    >,
    #[doc = "\n Returns true (1) if the command line has switches.\n"]
    pub has_switches: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if the command line contains the given switch.\n"]
    pub has_switch: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_command_line_t,
            name: *const cef_string_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the value associated with the given switch. If the switch has no\n value or isn't present this function returns the NULL string.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_switch_value: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_command_line_t,
            name: *const cef_string_t,
        ) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the map of switch names and values. If a switch has no value an\n NULL string is returned.\n"]
    pub get_switches: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t, switches: cef_string_map_t),
    >,
    #[doc = "\n Add a switch to the end of the command line. If the switch has no value\n pass an NULL value string.\n"]
    pub append_switch: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t, name: *const cef_string_t),
    >,
    #[doc = "\n Add a switch with the specified value to the end of the command line.\n"]
    pub append_switch_with_value: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_command_line_t,
            name: *const cef_string_t,
            value: *const cef_string_t,
        ),
    >,
    #[doc = "\n True if there are remaining command line arguments.\n"]
    pub has_arguments: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Get the remaining command line arguments.\n"]
    pub get_arguments: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t, arguments: cef_string_list_t),
    >,
    #[doc = "\n Add an argument to the end of the command line.\n"]
    pub append_argument: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t, argument: *const cef_string_t),
    >,
    #[doc = "\n Insert a command before the current command. Common for debuggers, like\n \"valgrind\" or \"gdb --args\".\n"]
    pub prepend_wrapper: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t, wrapper: *const cef_string_t),
    >,
}
#[test]
fn bindgen_test_layout__cef_command_line_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_command_line_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_command_line_t>(),
        200usize,
        concat!("Size of: ", stringify!(_cef_command_line_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_command_line_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_command_line_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_command_line_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_valid) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_command_line_t),
            "::",
            stringify!(is_valid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_read_only) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_command_line_t),
            "::",
            stringify!(is_read_only)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).copy) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_command_line_t),
            "::",
            stringify!(copy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init_from_argv) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_command_line_t),
            "::",
            stringify!(init_from_argv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init_from_string) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_command_line_t),
            "::",
            stringify!(init_from_string)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reset) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_command_line_t),
            "::",
            stringify!(reset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_argv) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_command_line_t),
            "::",
            stringify!(get_argv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_command_line_string) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_command_line_t),
            "::",
            stringify!(get_command_line_string)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_program) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_command_line_t),
            "::",
            stringify!(get_program)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_program) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_command_line_t),
            "::",
            stringify!(set_program)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_switches) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_command_line_t),
            "::",
            stringify!(has_switches)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_switch) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_command_line_t),
            "::",
            stringify!(has_switch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_switch_value) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_command_line_t),
            "::",
            stringify!(get_switch_value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_switches) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_command_line_t),
            "::",
            stringify!(get_switches)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).append_switch) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_command_line_t),
            "::",
            stringify!(append_switch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).append_switch_with_value) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_command_line_t),
            "::",
            stringify!(append_switch_with_value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_arguments) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_command_line_t),
            "::",
            stringify!(has_arguments)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_arguments) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_command_line_t),
            "::",
            stringify!(get_arguments)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).append_argument) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_command_line_t),
            "::",
            stringify!(append_argument)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prepend_wrapper) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_command_line_t),
            "::",
            stringify!(prepend_wrapper)
        )
    );
}
#[doc = "\n Structure used to create and/or parse command line arguments. Arguments with\n '--', '-' and, on Windows, '/' prefixes are considered switches. Switches\n will always precede any arguments without switch prefixes. Switches can\n optionally have a value specified using the '=' delimiter (e.g.\n \"-switch=value\"). An argument of \"--\" will terminate switch parsing with all\n subsequent tokens, regardless of prefix, being interpreted as non-switch\n arguments. Switch names are considered case-insensitive. This structure can\n be used before cef_initialize() is called.\n"]
pub type cef_command_line_t = _cef_command_line_t;
#[doc = "\n Structure used to implement browser process callbacks. The functions of this\n structure will be called on the browser process main thread unless otherwise\n indicated.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_browser_process_handler_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Called on the browser process UI thread immediately after the CEF context\n has been initialized.\n"]
    pub on_context_initialized:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_process_handler_t)>,
    #[doc = "\n Called before a child process is launched. Will be called on the browser\n process UI thread when launching a render process and on the browser\n process IO thread when launching a GPU or plugin process. Provides an\n opportunity to modify the child process command line. Do not keep a\n reference to |command_line| outside of this function.\n"]
    pub on_before_child_process_launch: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_process_handler_t,
            command_line: *mut _cef_command_line_t,
        ),
    >,
    #[doc = "\n Called from any thread when work has been scheduled for the browser process\n main (UI) thread. This callback is used in combination with CefSettings.\n external_message_pump and cef_do_message_loop_work() in cases where the CEF\n message loop must be integrated into an existing application message loop\n (see additional comments and warnings on CefDoMessageLoopWork). This\n callback should schedule a cef_do_message_loop_work() call to happen on the\n main (UI) thread. |delay_ms| is the requested delay in milliseconds. If\n |delay_ms| is <= 0 then the call should happen reasonably soon. If\n |delay_ms| is > 0 then the call should be scheduled to happen after the\n specified delay and any currently pending scheduled call should be\n cancelled.\n"]
    pub on_schedule_message_pump_work: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_process_handler_t, delay_ms: int64),
    >,
    #[doc = "\n Return the default client for use with a newly created browser window. If\n null is returned the browser will be unmanaged (no callbacks will be\n executed for that browser) and application shutdown will be blocked until\n the browser window is closed manually. This function is currently only used\n with the chrome runtime.\n"]
    pub get_default_client: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_process_handler_t) -> *mut _cef_client_t,
    >,
}
#[test]
fn bindgen_test_layout__cef_browser_process_handler_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_browser_process_handler_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_browser_process_handler_t>(),
        72usize,
        concat!("Size of: ", stringify!(_cef_browser_process_handler_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_browser_process_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_browser_process_handler_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_process_handler_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_context_initialized) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_process_handler_t),
            "::",
            stringify!(on_context_initialized)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).on_before_child_process_launch) as usize - ptr as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_process_handler_t),
            "::",
            stringify!(on_before_child_process_launch)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).on_schedule_message_pump_work) as usize - ptr as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_process_handler_t),
            "::",
            stringify!(on_schedule_message_pump_work)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_default_client) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_browser_process_handler_t),
            "::",
            stringify!(get_default_client)
        )
    );
}
#[doc = "\n Structure used to implement browser process callbacks. The functions of this\n structure will be called on the browser process main thread unless otherwise\n indicated.\n"]
pub type cef_browser_process_handler_t = _cef_browser_process_handler_t;
#[doc = "\n Implement this structure for asynchronous task execution. If the task is\n posted successfully and if the associated message loop is still running then\n the execute() function will be called on the target thread. If the task fails\n to post then the task object may be destroyed on the source thread instead of\n the target thread. For this reason be cautious when performing work in the\n task object destructor.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_task_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Method that will be executed on the target thread.\n"]
    pub execute: ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_task_t)>,
}
#[test]
fn bindgen_test_layout__cef_task_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_task_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_task_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_task_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_task_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_task_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_task_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).execute) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_task_t),
            "::",
            stringify!(execute)
        )
    );
}
#[doc = "\n Implement this structure for asynchronous task execution. If the task is\n posted successfully and if the associated message loop is still running then\n the execute() function will be called on the target thread. If the task fails\n to post then the task object may be destroyed on the source thread instead of\n the target thread. For this reason be cautious when performing work in the\n task object destructor.\n"]
pub type cef_task_t = _cef_task_t;
#[doc = "\n Structure that asynchronously executes tasks on the associated thread. It is\n safe to call the functions of this structure on any thread.\n\n CEF maintains multiple internal threads that are used for handling different\n types of tasks in different processes. The cef_thread_id_t definitions in\n cef_types.h list the common CEF threads. Task runners are also available for\n other CEF threads as appropriate (for example, V8 WebWorker threads).\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_task_runner_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Returns true (1) if this object is pointing to the same task runner as\n |that| object.\n"]
    pub is_same: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_task_runner_t,
            that: *mut _cef_task_runner_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if this task runner belongs to the current thread.\n"]
    pub belongs_to_current_thread: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_task_runner_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if this task runner is for the specified CEF thread.\n"]
    pub belongs_to_thread: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_task_runner_t,
            threadId: cef_thread_id_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Post a task for execution on the thread associated with this task runner.\n Execution will occur asynchronously.\n"]
    pub post_task: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_task_runner_t,
            task: *mut _cef_task_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Post a task for delayed execution on the thread associated with this task\n runner. Execution will occur asynchronously. Delayed tasks are not\n supported on V8 WebWorker threads and will be executed without the\n specified delay.\n"]
    pub post_delayed_task: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_task_runner_t,
            task: *mut _cef_task_t,
            delay_ms: int64,
        ) -> ::core::ffi::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_task_runner_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_task_runner_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_task_runner_t>(),
        80usize,
        concat!("Size of: ", stringify!(_cef_task_runner_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_task_runner_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_task_runner_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_task_runner_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_same) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_task_runner_t),
            "::",
            stringify!(is_same)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).belongs_to_current_thread) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_task_runner_t),
            "::",
            stringify!(belongs_to_current_thread)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).belongs_to_thread) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_task_runner_t),
            "::",
            stringify!(belongs_to_thread)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).post_task) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_task_runner_t),
            "::",
            stringify!(post_task)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).post_delayed_task) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_task_runner_t),
            "::",
            stringify!(post_delayed_task)
        )
    );
}
#[doc = "\n Structure that asynchronously executes tasks on the associated thread. It is\n safe to call the functions of this structure on any thread.\n\n CEF maintains multiple internal threads that are used for handling different\n types of tasks in different processes. The cef_thread_id_t definitions in\n cef_types.h list the common CEF threads. Task runners are also available for\n other CEF threads as appropriate (for example, V8 WebWorker threads).\n"]
pub type cef_task_runner_t = _cef_task_runner_t;
#[doc = "\n Structure representing a V8 context handle. V8 handles can only be accessed\n from the thread on which they are created. Valid threads for creating a V8\n handle include the render process main thread (TID_RENDERER) and WebWorker\n threads. A task runner for posting tasks on the associated thread can be\n retrieved via the cef_v8context_t::get_task_runner() function.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_v8context_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Returns the task runner associated with this context. V8 handles can only\n be accessed from the thread on which they are created. This function can be\n called on any render process thread.\n"]
    pub get_task_runner: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8context_t) -> *mut _cef_task_runner_t,
    >,
    #[doc = "\n Returns true (1) if the underlying handle is valid and it can be accessed\n on the current thread. Do not call any other functions if this function\n returns false (0).\n"]
    pub is_valid: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8context_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the browser for this context. This function will return an NULL\n reference for WebWorker contexts.\n"]
    pub get_browser: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8context_t) -> *mut _cef_browser_t,
    >,
    #[doc = "\n Returns the frame for this context. This function will return an NULL\n reference for WebWorker contexts.\n"]
    pub get_frame: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8context_t) -> *mut _cef_frame_t,
    >,
    #[doc = "\n Returns the global object for this context. The context must be entered\n before calling this function.\n"]
    pub get_global: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8context_t) -> *mut _cef_v8value_t,
    >,
    #[doc = "\n Enter this context. A context must be explicitly entered before creating a\n V8 Object, Array, Function or Date asynchronously. exit() must be called\n the same number of times as enter() before releasing this context. V8\n objects belong to the context in which they are created. Returns true (1)\n if the scope was entered successfully.\n"]
    pub enter: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8context_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Exit this context. Call this function only after calling enter(). Returns\n true (1) if the scope was exited successfully.\n"]
    pub exit: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8context_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if this object is pointing to the same handle as |that|\n object.\n"]
    pub is_same: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8context_t,
            that: *mut _cef_v8context_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Execute a string of JavaScript code in this V8 context. The |script_url|\n parameter is the URL where the script in question can be found, if any. The\n |start_line| parameter is the base line number to use for error reporting.\n On success |retval| will be set to the return value, if any, and the\n function will return true (1). On failure |exception| will be set to the\n exception, if any, and the function will return false (0).\n"]
    pub eval: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8context_t,
            code: *const cef_string_t,
            script_url: *const cef_string_t,
            start_line: ::core::ffi::c_int,
            retval: *mut *mut _cef_v8value_t,
            exception: *mut *mut _cef_v8exception_t,
        ) -> ::core::ffi::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_v8context_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_v8context_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_v8context_t>(),
        112usize,
        concat!("Size of: ", stringify!(_cef_v8context_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_v8context_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_v8context_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8context_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_task_runner) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8context_t),
            "::",
            stringify!(get_task_runner)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_valid) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8context_t),
            "::",
            stringify!(is_valid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_browser) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8context_t),
            "::",
            stringify!(get_browser)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_frame) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8context_t),
            "::",
            stringify!(get_frame)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_global) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8context_t),
            "::",
            stringify!(get_global)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).enter) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8context_t),
            "::",
            stringify!(enter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).exit) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8context_t),
            "::",
            stringify!(exit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_same) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8context_t),
            "::",
            stringify!(is_same)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).eval) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8context_t),
            "::",
            stringify!(eval)
        )
    );
}
#[doc = "\n Structure representing a V8 context handle. V8 handles can only be accessed\n from the thread on which they are created. Valid threads for creating a V8\n handle include the render process main thread (TID_RENDERER) and WebWorker\n threads. A task runner for posting tasks on the associated thread can be\n retrieved via the cef_v8context_t::get_task_runner() function.\n"]
pub type cef_v8context_t = _cef_v8context_t;
#[doc = "\n Structure that should be implemented to handle V8 function calls. The\n functions of this structure will be called on the thread associated with the\n V8 function.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_v8handler_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Handle execution of the function identified by |name|. |object| is the\n receiver ('this' object) of the function. |arguments| is the list of\n arguments passed to the function. If execution succeeds set |retval| to the\n function return value. If execution fails set |exception| to the exception\n that will be thrown. Return true (1) if execution was handled.\n"]
    pub execute: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8handler_t,
            name: *const cef_string_t,
            object: *mut _cef_v8value_t,
            argumentsCount: usize,
            arguments: *const *mut _cef_v8value_t,
            retval: *mut *mut _cef_v8value_t,
            exception: *mut cef_string_t,
        ) -> ::core::ffi::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_v8handler_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_v8handler_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_v8handler_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_v8handler_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_v8handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_v8handler_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8handler_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).execute) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8handler_t),
            "::",
            stringify!(execute)
        )
    );
}
#[doc = "\n Structure that should be implemented to handle V8 function calls. The\n functions of this structure will be called on the thread associated with the\n V8 function.\n"]
pub type cef_v8handler_t = _cef_v8handler_t;
#[doc = "\n Structure that should be implemented to handle V8 accessor calls. Accessor\n identifiers are registered by calling cef_v8value_t::set_value(). The\n functions of this structure will be called on the thread associated with the\n V8 accessor.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_v8accessor_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Handle retrieval the accessor value identified by |name|. |object| is the\n receiver ('this' object) of the accessor. If retrieval succeeds set\n |retval| to the return value. If retrieval fails set |exception| to the\n exception that will be thrown. Return true (1) if accessor retrieval was\n handled.\n"]
    pub get: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8accessor_t,
            name: *const cef_string_t,
            object: *mut _cef_v8value_t,
            retval: *mut *mut _cef_v8value_t,
            exception: *mut cef_string_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Handle assignment of the accessor value identified by |name|. |object| is\n the receiver ('this' object) of the accessor. |value| is the new value\n being assigned to the accessor. If assignment fails set |exception| to the\n exception that will be thrown. Return true (1) if accessor assignment was\n handled.\n"]
    pub set: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8accessor_t,
            name: *const cef_string_t,
            object: *mut _cef_v8value_t,
            value: *mut _cef_v8value_t,
            exception: *mut cef_string_t,
        ) -> ::core::ffi::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_v8accessor_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_v8accessor_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_v8accessor_t>(),
        56usize,
        concat!("Size of: ", stringify!(_cef_v8accessor_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_v8accessor_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_v8accessor_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8accessor_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8accessor_t),
            "::",
            stringify!(get)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8accessor_t),
            "::",
            stringify!(set)
        )
    );
}
#[doc = "\n Structure that should be implemented to handle V8 accessor calls. Accessor\n identifiers are registered by calling cef_v8value_t::set_value(). The\n functions of this structure will be called on the thread associated with the\n V8 accessor.\n"]
pub type cef_v8accessor_t = _cef_v8accessor_t;
#[doc = "\n Structure that should be implemented to handle V8 interceptor calls. The\n functions of this structure will be called on the thread associated with the\n V8 interceptor. Interceptor's named property handlers (with first argument of\n type CefString) are called when object is indexed by string. Indexed property\n handlers (with first argument of type int) are called when object is indexed\n by integer.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_v8interceptor_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Handle retrieval of the interceptor value identified by |name|. |object| is\n the receiver ('this' object) of the interceptor. If retrieval succeeds, set\n |retval| to the return value. If the requested value does not exist, don't\n set either |retval| or |exception|. If retrieval fails, set |exception| to\n the exception that will be thrown. If the property has an associated\n accessor, it will be called only if you don't set |retval|. Return true (1)\n if interceptor retrieval was handled, false (0) otherwise.\n"]
    pub get_byname: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8interceptor_t,
            name: *const cef_string_t,
            object: *mut _cef_v8value_t,
            retval: *mut *mut _cef_v8value_t,
            exception: *mut cef_string_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Handle retrieval of the interceptor value identified by |index|. |object|\n is the receiver ('this' object) of the interceptor. If retrieval succeeds,\n set |retval| to the return value. If the requested value does not exist,\n don't set either |retval| or |exception|. If retrieval fails, set\n |exception| to the exception that will be thrown. Return true (1) if\n interceptor retrieval was handled, false (0) otherwise.\n"]
    pub get_byindex: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8interceptor_t,
            index: ::core::ffi::c_int,
            object: *mut _cef_v8value_t,
            retval: *mut *mut _cef_v8value_t,
            exception: *mut cef_string_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Handle assignment of the interceptor value identified by |name|. |object|\n is the receiver ('this' object) of the interceptor. |value| is the new\n value being assigned to the interceptor. If assignment fails, set\n |exception| to the exception that will be thrown. This setter will always\n be called, even when the property has an associated accessor. Return true\n (1) if interceptor assignment was handled, false (0) otherwise.\n"]
    pub set_byname: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8interceptor_t,
            name: *const cef_string_t,
            object: *mut _cef_v8value_t,
            value: *mut _cef_v8value_t,
            exception: *mut cef_string_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Handle assignment of the interceptor value identified by |index|. |object|\n is the receiver ('this' object) of the interceptor. |value| is the new\n value being assigned to the interceptor. If assignment fails, set\n |exception| to the exception that will be thrown. Return true (1) if\n interceptor assignment was handled, false (0) otherwise.\n"]
    pub set_byindex: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8interceptor_t,
            index: ::core::ffi::c_int,
            object: *mut _cef_v8value_t,
            value: *mut _cef_v8value_t,
            exception: *mut cef_string_t,
        ) -> ::core::ffi::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_v8interceptor_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_v8interceptor_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_v8interceptor_t>(),
        72usize,
        concat!("Size of: ", stringify!(_cef_v8interceptor_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_v8interceptor_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_v8interceptor_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8interceptor_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_byname) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8interceptor_t),
            "::",
            stringify!(get_byname)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_byindex) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8interceptor_t),
            "::",
            stringify!(get_byindex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_byname) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8interceptor_t),
            "::",
            stringify!(set_byname)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_byindex) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8interceptor_t),
            "::",
            stringify!(set_byindex)
        )
    );
}
#[doc = "\n Structure that should be implemented to handle V8 interceptor calls. The\n functions of this structure will be called on the thread associated with the\n V8 interceptor. Interceptor's named property handlers (with first argument of\n type CefString) are called when object is indexed by string. Indexed property\n handlers (with first argument of type int) are called when object is indexed\n by integer.\n"]
pub type cef_v8interceptor_t = _cef_v8interceptor_t;
#[doc = "\n Structure representing a V8 exception. The functions of this structure may be\n called on any render process thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_v8exception_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Returns the exception message.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_message: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8exception_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the line of source code that the exception occurred within.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_source_line: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8exception_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the resource name for the script from where the function causing\n the error originates.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_script_resource_name: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8exception_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the 1-based number of the line where the error occurred or 0 if the\n line number is unknown.\n"]
    pub get_line_number: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8exception_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the index within the script of the first character where the error\n occurred.\n"]
    pub get_start_position: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8exception_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the index within the script of the last character where the error\n occurred.\n"]
    pub get_end_position: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8exception_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the index within the line of the first character where the error\n occurred.\n"]
    pub get_start_column: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8exception_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the index within the line of the last character where the error\n occurred.\n"]
    pub get_end_column: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8exception_t) -> ::core::ffi::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_v8exception_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_v8exception_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_v8exception_t>(),
        104usize,
        concat!("Size of: ", stringify!(_cef_v8exception_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_v8exception_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_v8exception_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8exception_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_message) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8exception_t),
            "::",
            stringify!(get_message)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_source_line) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8exception_t),
            "::",
            stringify!(get_source_line)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_script_resource_name) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8exception_t),
            "::",
            stringify!(get_script_resource_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_line_number) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8exception_t),
            "::",
            stringify!(get_line_number)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_start_position) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8exception_t),
            "::",
            stringify!(get_start_position)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_end_position) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8exception_t),
            "::",
            stringify!(get_end_position)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_start_column) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8exception_t),
            "::",
            stringify!(get_start_column)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_end_column) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8exception_t),
            "::",
            stringify!(get_end_column)
        )
    );
}
#[doc = "\n Structure representing a V8 exception. The functions of this structure may be\n called on any render process thread.\n"]
pub type cef_v8exception_t = _cef_v8exception_t;
#[doc = "\n Callback structure that is passed to cef_v8value_t::CreateArrayBuffer.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_v8array_buffer_release_callback_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Called to release |buffer| when the ArrayBuffer JS object is garbage\n collected. |buffer| is the value that was passed to CreateArrayBuffer along\n with this object.\n"]
    pub release_buffer: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8array_buffer_release_callback_t,
            buffer: *mut ::core::ffi::c_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_v8array_buffer_release_callback_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_v8array_buffer_release_callback_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_v8array_buffer_release_callback_t>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_cef_v8array_buffer_release_callback_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_v8array_buffer_release_callback_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_cef_v8array_buffer_release_callback_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8array_buffer_release_callback_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).release_buffer) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8array_buffer_release_callback_t),
            "::",
            stringify!(release_buffer)
        )
    );
}
#[doc = "\n Callback structure that is passed to cef_v8value_t::CreateArrayBuffer.\n"]
pub type cef_v8array_buffer_release_callback_t = _cef_v8array_buffer_release_callback_t;
#[doc = "\n Structure representing a V8 value handle. V8 handles can only be accessed\n from the thread on which they are created. Valid threads for creating a V8\n handle include the render process main thread (TID_RENDERER) and WebWorker\n threads. A task runner for posting tasks on the associated thread can be\n retrieved via the cef_v8context_t::get_task_runner() function.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_v8value_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Returns true (1) if the underlying handle is valid and it can be accessed\n on the current thread. Do not call any other functions if this function\n returns false (0).\n"]
    pub is_valid: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n True if the value type is undefined.\n"]
    pub is_undefined: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n True if the value type is null.\n"]
    pub is_null: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n True if the value type is bool.\n"]
    pub is_bool: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n True if the value type is int.\n"]
    pub is_int: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n True if the value type is unsigned int.\n"]
    pub is_uint: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n True if the value type is double.\n"]
    pub is_double: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n True if the value type is Date.\n"]
    pub is_date: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n True if the value type is string.\n"]
    pub is_string: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n True if the value type is object.\n"]
    pub is_object: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n True if the value type is array.\n"]
    pub is_array: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n True if the value type is an ArrayBuffer.\n"]
    pub is_array_buffer: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n True if the value type is function.\n"]
    pub is_function: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if this object is pointing to the same handle as |that|\n object.\n"]
    pub is_same: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            that: *mut _cef_v8value_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Return a bool value.\n"]
    pub get_bool_value: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Return an int value.\n"]
    pub get_int_value:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> int32>,
    #[doc = "\n Return an unsigned int value.\n"]
    pub get_uint_value:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> uint32>,
    #[doc = "\n Return a double value.\n"]
    pub get_double_value:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> f64>,
    #[doc = "\n Return a Date value.\n"]
    pub get_date_value:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> cef_time_t>,
    #[doc = "\n Return a string value.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_string_value: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns true (1) if this is a user created object.\n"]
    pub is_user_created: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if the last function call resulted in an exception. This\n attribute exists only in the scope of the current CEF value object.\n"]
    pub has_exception: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the exception resulting from the last function call. This attribute\n exists only in the scope of the current CEF value object.\n"]
    pub get_exception: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> *mut _cef_v8exception_t,
    >,
    #[doc = "\n Clears the last exception and returns true (1) on success.\n"]
    pub clear_exception: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if this object will re-throw future exceptions. This\n attribute exists only in the scope of the current CEF value object.\n"]
    pub will_rethrow_exceptions: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Set whether this object will re-throw future exceptions. By default\n exceptions are not re-thrown. If a exception is re-thrown the current\n context should not be accessed again until after the exception has been\n caught and not re-thrown. Returns true (1) on success. This attribute\n exists only in the scope of the current CEF value object.\n"]
    pub set_rethrow_exceptions: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            rethrow: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if the object has a value with the specified identifier.\n"]
    pub has_value_bykey: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            key: *const cef_string_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if the object has a value with the specified identifier.\n"]
    pub has_value_byindex: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            index: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Deletes the value with the specified identifier and returns true (1) on\n success. Returns false (0) if this function is called incorrectly or an\n exception is thrown. For read-only and don't-delete values this function\n will return true (1) even though deletion failed.\n"]
    pub delete_value_bykey: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            key: *const cef_string_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Deletes the value with the specified identifier and returns true (1) on\n success. Returns false (0) if this function is called incorrectly, deletion\n fails or an exception is thrown. For read-only and don't-delete values this\n function will return true (1) even though deletion failed.\n"]
    pub delete_value_byindex: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            index: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the value with the specified identifier on success. Returns NULL if\n this function is called incorrectly or an exception is thrown.\n"]
    pub get_value_bykey: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            key: *const cef_string_t,
        ) -> *mut _cef_v8value_t,
    >,
    #[doc = "\n Returns the value with the specified identifier on success. Returns NULL if\n this function is called incorrectly or an exception is thrown.\n"]
    pub get_value_byindex: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            index: ::core::ffi::c_int,
        ) -> *mut _cef_v8value_t,
    >,
    #[doc = "\n Associates a value with the specified identifier and returns true (1) on\n success. Returns false (0) if this function is called incorrectly or an\n exception is thrown. For read-only values this function will return true\n (1) even though assignment failed.\n"]
    pub set_value_bykey: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            key: *const cef_string_t,
            value: *mut _cef_v8value_t,
            attribute: cef_v8_propertyattribute_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Associates a value with the specified identifier and returns true (1) on\n success. Returns false (0) if this function is called incorrectly or an\n exception is thrown. For read-only values this function will return true\n (1) even though assignment failed.\n"]
    pub set_value_byindex: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            index: ::core::ffi::c_int,
            value: *mut _cef_v8value_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Registers an identifier and returns true (1) on success. Access to the\n identifier will be forwarded to the cef_v8accessor_t instance passed to\n cef_v8value_t::cef_v8value_create_object(). Returns false (0) if this\n function is called incorrectly or an exception is thrown. For read-only\n values this function will return true (1) even though assignment failed.\n"]
    pub set_value_byaccessor: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            key: *const cef_string_t,
            settings: cef_v8_accesscontrol_t,
            attribute: cef_v8_propertyattribute_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Read the keys for the object's values into the specified vector. Integer-\n based keys will also be returned as strings.\n"]
    pub get_keys: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            keys: cef_string_list_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Sets the user data for this object and returns true (1) on success. Returns\n false (0) if this function is called incorrectly. This function can only be\n called on user created objects.\n"]
    pub set_user_data: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            user_data: *mut _cef_base_ref_counted_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the user data, if any, assigned to this object.\n"]
    pub get_user_data: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> *mut _cef_base_ref_counted_t,
    >,
    #[doc = "\n Returns the amount of externally allocated memory registered for the\n object.\n"]
    pub get_externally_allocated_memory: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Adjusts the amount of registered external memory for the object. Used to\n give V8 an indication of the amount of externally allocated memory that is\n kept alive by JavaScript objects. V8 uses this information to decide when\n to perform global garbage collection. Each cef_v8value_t tracks the amount\n of external memory associated with it and automatically decreases the\n global total by the appropriate amount on its destruction.\n |change_in_bytes| specifies the number of bytes to adjust by. This function\n returns the number of bytes associated with the object after the\n adjustment. This function can only be called on user created objects.\n"]
    pub adjust_externally_allocated_memory: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            change_in_bytes: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the number of elements in the array.\n"]
    pub get_array_length: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the ReleaseCallback object associated with the ArrayBuffer or NULL\n if the ArrayBuffer was not created with CreateArrayBuffer.\n"]
    pub get_array_buffer_release_callback: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
        ) -> *mut _cef_v8array_buffer_release_callback_t,
    >,
    #[doc = "\n Prevent the ArrayBuffer from using it's memory block by setting the length\n to zero. This operation cannot be undone. If the ArrayBuffer was created\n with CreateArrayBuffer then\n cef_v8array_buffer_release_callback_t::ReleaseBuffer will be called to\n release the underlying buffer.\n"]
    pub neuter_array_buffer: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the function name.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_function_name: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the function handler or NULL if not a CEF-created function.\n"]
    pub get_function_handler: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> *mut _cef_v8handler_t,
    >,
    #[doc = "\n Execute the function using the current V8 context. This function should\n only be called from within the scope of a cef_v8handler_t or\n cef_v8accessor_t callback, or in combination with calling enter() and\n exit() on a stored cef_v8context_t reference. |object| is the receiver\n ('this' object) of the function. If |object| is NULL the current context's\n global object will be used. |arguments| is the list of arguments that will\n be passed to the function. Returns the function return value on success.\n Returns NULL if this function is called incorrectly or an exception is\n thrown.\n"]
    pub execute_function: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            object: *mut _cef_v8value_t,
            argumentsCount: usize,
            arguments: *const *mut _cef_v8value_t,
        ) -> *mut _cef_v8value_t,
    >,
    #[doc = "\n Execute the function using the specified V8 context. |object| is the\n receiver ('this' object) of the function. If |object| is NULL the specified\n context's global object will be used. |arguments| is the list of arguments\n that will be passed to the function. Returns the function return value on\n success. Returns NULL if this function is called incorrectly or an\n exception is thrown.\n"]
    pub execute_function_with_context: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            context: *mut _cef_v8context_t,
            object: *mut _cef_v8value_t,
            argumentsCount: usize,
            arguments: *const *mut _cef_v8value_t,
        ) -> *mut _cef_v8value_t,
    >,
}
#[test]
fn bindgen_test_layout__cef_v8value_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_v8value_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_v8value_t>(),
        416usize,
        concat!("Size of: ", stringify!(_cef_v8value_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_v8value_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_v8value_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_valid) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(is_valid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_undefined) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(is_undefined)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_null) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(is_null)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_bool) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(is_bool)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_int) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(is_int)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_uint) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(is_uint)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_double) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(is_double)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_date) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(is_date)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_string) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(is_string)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_object) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(is_object)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_array) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(is_array)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_array_buffer) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(is_array_buffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_function) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(is_function)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_same) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(is_same)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_bool_value) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(get_bool_value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_int_value) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(get_int_value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_uint_value) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(get_uint_value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_double_value) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(get_double_value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_date_value) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(get_date_value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_string_value) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(get_string_value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_user_created) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(is_user_created)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_exception) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(has_exception)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_exception) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(get_exception)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clear_exception) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(clear_exception)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).will_rethrow_exceptions) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(will_rethrow_exceptions)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_rethrow_exceptions) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(set_rethrow_exceptions)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_value_bykey) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(has_value_bykey)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_value_byindex) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(has_value_byindex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).delete_value_bykey) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(delete_value_bykey)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).delete_value_byindex) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(delete_value_byindex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_value_bykey) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(get_value_bykey)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_value_byindex) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(get_value_byindex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_value_bykey) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(set_value_bykey)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_value_byindex) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(set_value_byindex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_value_byaccessor) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(set_value_byaccessor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_keys) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(get_keys)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).set_user_data) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(set_user_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_user_data) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(get_user_data)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).get_externally_allocated_memory) as usize - ptr as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(get_externally_allocated_memory)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).adjust_externally_allocated_memory) as usize - ptr as usize
        },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(adjust_externally_allocated_memory)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_array_length) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(get_array_length)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).get_array_buffer_release_callback) as usize - ptr as usize
        },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(get_array_buffer_release_callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).neuter_array_buffer) as usize - ptr as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(neuter_array_buffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_function_name) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(get_function_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_function_handler) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(get_function_handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).execute_function) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(execute_function)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).execute_function_with_context) as usize - ptr as usize
        },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8value_t),
            "::",
            stringify!(execute_function_with_context)
        )
    );
}
#[doc = "\n Structure representing a V8 value handle. V8 handles can only be accessed\n from the thread on which they are created. Valid threads for creating a V8\n handle include the render process main thread (TID_RENDERER) and WebWorker\n threads. A task runner for posting tasks on the associated thread can be\n retrieved via the cef_v8context_t::get_task_runner() function.\n"]
pub type cef_v8value_t = _cef_v8value_t;
#[doc = "\n Structure representing a V8 stack trace handle. V8 handles can only be\n accessed from the thread on which they are created. Valid threads for\n creating a V8 handle include the render process main thread (TID_RENDERER)\n and WebWorker threads. A task runner for posting tasks on the associated\n thread can be retrieved via the cef_v8context_t::get_task_runner() function.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_v8stack_trace_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Returns true (1) if the underlying handle is valid and it can be accessed\n on the current thread. Do not call any other functions if this function\n returns false (0).\n"]
    pub is_valid: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8stack_trace_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the number of stack frames.\n"]
    pub get_frame_count: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8stack_trace_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the stack frame at the specified 0-based index.\n"]
    pub get_frame: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8stack_trace_t,
            index: ::core::ffi::c_int,
        ) -> *mut _cef_v8stack_frame_t,
    >,
}
#[test]
fn bindgen_test_layout__cef_v8stack_trace_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_v8stack_trace_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_v8stack_trace_t>(),
        64usize,
        concat!("Size of: ", stringify!(_cef_v8stack_trace_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_v8stack_trace_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_v8stack_trace_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8stack_trace_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_valid) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8stack_trace_t),
            "::",
            stringify!(is_valid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_frame_count) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8stack_trace_t),
            "::",
            stringify!(get_frame_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_frame) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8stack_trace_t),
            "::",
            stringify!(get_frame)
        )
    );
}
#[doc = "\n Structure representing a V8 stack trace handle. V8 handles can only be\n accessed from the thread on which they are created. Valid threads for\n creating a V8 handle include the render process main thread (TID_RENDERER)\n and WebWorker threads. A task runner for posting tasks on the associated\n thread can be retrieved via the cef_v8context_t::get_task_runner() function.\n"]
pub type cef_v8stack_trace_t = _cef_v8stack_trace_t;
#[doc = "\n Structure representing a V8 stack frame handle. V8 handles can only be\n accessed from the thread on which they are created. Valid threads for\n creating a V8 handle include the render process main thread (TID_RENDERER)\n and WebWorker threads. A task runner for posting tasks on the associated\n thread can be retrieved via the cef_v8context_t::get_task_runner() function.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_v8stack_frame_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Returns true (1) if the underlying handle is valid and it can be accessed\n on the current thread. Do not call any other functions if this function\n returns false (0).\n"]
    pub is_valid: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8stack_frame_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the name of the resource script that contains the function.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_script_name: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8stack_frame_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the name of the resource script that contains the function or the\n sourceURL value if the script name is undefined and its source ends with a\n \"//@ sourceURL=...\" string.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_script_name_or_source_url: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8stack_frame_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the name of the function.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_function_name: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8stack_frame_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the 1-based line number for the function call or 0 if unknown.\n"]
    pub get_line_number: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8stack_frame_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the 1-based column offset on the line for the function call or 0 if\n unknown.\n"]
    pub get_column: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8stack_frame_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if the function was compiled using eval().\n"]
    pub is_eval: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8stack_frame_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if the function was called as a constructor via \"new\".\n"]
    pub is_constructor: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8stack_frame_t) -> ::core::ffi::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_v8stack_frame_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_v8stack_frame_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_v8stack_frame_t>(),
        104usize,
        concat!("Size of: ", stringify!(_cef_v8stack_frame_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_v8stack_frame_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_v8stack_frame_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8stack_frame_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_valid) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8stack_frame_t),
            "::",
            stringify!(is_valid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_script_name) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8stack_frame_t),
            "::",
            stringify!(get_script_name)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).get_script_name_or_source_url) as usize - ptr as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8stack_frame_t),
            "::",
            stringify!(get_script_name_or_source_url)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_function_name) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8stack_frame_t),
            "::",
            stringify!(get_function_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_line_number) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8stack_frame_t),
            "::",
            stringify!(get_line_number)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_column) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8stack_frame_t),
            "::",
            stringify!(get_column)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_eval) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8stack_frame_t),
            "::",
            stringify!(is_eval)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_constructor) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_v8stack_frame_t),
            "::",
            stringify!(is_constructor)
        )
    );
}
#[doc = "\n Structure representing a V8 stack frame handle. V8 handles can only be\n accessed from the thread on which they are created. Valid threads for\n creating a V8 handle include the render process main thread (TID_RENDERER)\n and WebWorker threads. A task runner for posting tasks on the associated\n thread can be retrieved via the cef_v8context_t::get_task_runner() function.\n"]
pub type cef_v8stack_frame_t = _cef_v8stack_frame_t;
#[doc = "\n Structure used to implement render process callbacks. The functions of this\n structure will be called on the render process main thread (TID_RENDERER)\n unless otherwise indicated.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_render_process_handler_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Called after WebKit has been initialized.\n"]
    pub on_web_kit_initialized:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_render_process_handler_t)>,
    #[doc = "\n Called after a browser has been created. When browsing cross-origin a new\n browser will be created before the old browser with the same identifier is\n destroyed. |extra_info| is a read-only value originating from\n cef_browser_host_t::cef_browser_host_create_browser(),\n cef_browser_host_t::cef_browser_host_create_browser_sync(),\n cef_life_span_handler_t::on_before_popup() or\n cef_browser_view_t::cef_browser_view_create().\n"]
    pub on_browser_created: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_process_handler_t,
            browser: *mut _cef_browser_t,
            extra_info: *mut _cef_dictionary_value_t,
        ),
    >,
    #[doc = "\n Called before a browser is destroyed.\n"]
    pub on_browser_destroyed: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_process_handler_t,
            browser: *mut _cef_browser_t,
        ),
    >,
    #[doc = "\n Return the handler for browser load status events.\n"]
    pub get_load_handler: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_render_process_handler_t) -> *mut _cef_load_handler_t,
    >,
    #[doc = "\n Called immediately after the V8 context for a frame has been created. To\n retrieve the JavaScript 'window' object use the\n cef_v8context_t::get_global() function. V8 handles can only be accessed\n from the thread on which they are created. A task runner for posting tasks\n on the associated thread can be retrieved via the\n cef_v8context_t::get_task_runner() function.\n"]
    pub on_context_created: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_process_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            context: *mut _cef_v8context_t,
        ),
    >,
    #[doc = "\n Called immediately before the V8 context for a frame is released. No\n references to the context should be kept after this function is called.\n"]
    pub on_context_released: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_process_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            context: *mut _cef_v8context_t,
        ),
    >,
    #[doc = "\n Called for global uncaught exceptions in a frame. Execution of this\n callback is disabled by default. To enable set\n CefSettings.uncaught_exception_stack_size > 0.\n"]
    pub on_uncaught_exception: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_process_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            context: *mut _cef_v8context_t,
            exception: *mut _cef_v8exception_t,
            stackTrace: *mut _cef_v8stack_trace_t,
        ),
    >,
    #[doc = "\n Called when a new node in the the browser gets focus. The |node| value may\n be NULL if no specific node has gained focus. The node object passed to\n this function represents a snapshot of the DOM at the time this function is\n executed. DOM objects are only valid for the scope of this function. Do not\n keep references to or attempt to access any DOM objects outside the scope\n of this function.\n"]
    pub on_focused_node_changed: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_process_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            node: *mut _cef_domnode_t,
        ),
    >,
    #[doc = "\n Called when a new message is received from a different process. Return true\n (1) if the message was handled or false (0) otherwise. Do not keep a\n reference to or attempt to access the message outside of this callback.\n"]
    pub on_process_message_received: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_process_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            source_process: cef_process_id_t,
            message: *mut _cef_process_message_t,
        ) -> ::core::ffi::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_render_process_handler_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_render_process_handler_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_render_process_handler_t>(),
        112usize,
        concat!("Size of: ", stringify!(_cef_render_process_handler_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_render_process_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_render_process_handler_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_render_process_handler_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_web_kit_initialized) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_render_process_handler_t),
            "::",
            stringify!(on_web_kit_initialized)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_browser_created) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_render_process_handler_t),
            "::",
            stringify!(on_browser_created)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_browser_destroyed) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_render_process_handler_t),
            "::",
            stringify!(on_browser_destroyed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_load_handler) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_render_process_handler_t),
            "::",
            stringify!(get_load_handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_context_created) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_render_process_handler_t),
            "::",
            stringify!(on_context_created)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_context_released) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_render_process_handler_t),
            "::",
            stringify!(on_context_released)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_uncaught_exception) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_render_process_handler_t),
            "::",
            stringify!(on_uncaught_exception)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_focused_node_changed) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_render_process_handler_t),
            "::",
            stringify!(on_focused_node_changed)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).on_process_message_received) as usize - ptr as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_render_process_handler_t),
            "::",
            stringify!(on_process_message_received)
        )
    );
}
#[doc = "\n Structure used to implement render process callbacks. The functions of this\n structure will be called on the render process main thread (TID_RENDERER)\n unless otherwise indicated.\n"]
pub type cef_render_process_handler_t = _cef_render_process_handler_t;
#[doc = "\n Structure used to implement a custom resource bundle structure. See\n CefSettings for additional options related to resource bundle loading. The\n functions of this structure may be called on multiple threads.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_resource_bundle_handler_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Called to retrieve a localized translation for the specified |string_id|.\n To provide the translation set |string| to the translation string and\n return true (1). To use the default translation return false (0). Include\n cef_pack_strings.h for a listing of valid string ID values.\n"]
    pub get_localized_string: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_bundle_handler_t,
            string_id: ::core::ffi::c_int,
            string: *mut cef_string_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Called to retrieve data for the specified scale independent |resource_id|.\n To provide the resource data set |data| and |data_size| to the data pointer\n and size respectively and return true (1). To use the default resource data\n return false (0). The resource data will not be copied and must remain\n resident in memory. Include cef_pack_resources.h for a listing of valid\n resource ID values.\n"]
    pub get_data_resource: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_bundle_handler_t,
            resource_id: ::core::ffi::c_int,
            data: *mut *mut ::core::ffi::c_void,
            data_size: *mut usize,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Called to retrieve data for the specified |resource_id| nearest the scale\n factor |scale_factor|. To provide the resource data set |data| and\n |data_size| to the data pointer and size respectively and return true (1).\n To use the default resource data return false (0). The resource data will\n not be copied and must remain resident in memory. Include\n cef_pack_resources.h for a listing of valid resource ID values.\n"]
    pub get_data_resource_for_scale: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_bundle_handler_t,
            resource_id: ::core::ffi::c_int,
            scale_factor: cef_scale_factor_t,
            data: *mut *mut ::core::ffi::c_void,
            data_size: *mut usize,
        ) -> ::core::ffi::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_resource_bundle_handler_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_resource_bundle_handler_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_resource_bundle_handler_t>(),
        64usize,
        concat!("Size of: ", stringify!(_cef_resource_bundle_handler_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_resource_bundle_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_resource_bundle_handler_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_resource_bundle_handler_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_localized_string) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_resource_bundle_handler_t),
            "::",
            stringify!(get_localized_string)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_data_resource) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_resource_bundle_handler_t),
            "::",
            stringify!(get_data_resource)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).get_data_resource_for_scale) as usize - ptr as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_resource_bundle_handler_t),
            "::",
            stringify!(get_data_resource_for_scale)
        )
    );
}
#[doc = "\n Structure used to implement a custom resource bundle structure. See\n CefSettings for additional options related to resource bundle loading. The\n functions of this structure may be called on multiple threads.\n"]
pub type cef_resource_bundle_handler_t = _cef_resource_bundle_handler_t;
#[doc = "\n Structure that manages custom scheme registrations.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_scheme_registrar_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_scoped_t,
    #[doc = "\n Register a custom scheme. This function should not be called for the built-\n in HTTP, HTTPS, FILE, FTP, ABOUT and DATA schemes.\n\n See cef_scheme_options_t for possible values for |options|.\n\n This function may be called on any thread. It should only be called once\n per unique |scheme_name| value. If |scheme_name| is already registered or\n if an error occurs this function will return false (0).\n"]
    pub add_custom_scheme: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_scheme_registrar_t,
            scheme_name: *const cef_string_t,
            options: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_scheme_registrar_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_scheme_registrar_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_scheme_registrar_t>(),
        24usize,
        concat!("Size of: ", stringify!(_cef_scheme_registrar_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_scheme_registrar_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_scheme_registrar_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_scheme_registrar_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).add_custom_scheme) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_scheme_registrar_t),
            "::",
            stringify!(add_custom_scheme)
        )
    );
}
#[doc = "\n Structure that manages custom scheme registrations.\n"]
pub type cef_scheme_registrar_t = _cef_scheme_registrar_t;
#[doc = "\n Structure that creates cef_resource_handler_t instances for handling scheme\n requests. The functions of this structure will always be called on the IO\n thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_scheme_handler_factory_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Return a new resource handler instance to handle the request or an NULL\n reference to allow default handling of the request. |browser| and |frame|\n will be the browser window and frame respectively that originated the\n request or NULL if the request did not originate from a browser window (for\n example, if the request came from cef_urlrequest_t). The |request| object\n passed to this function cannot be modified.\n"]
    pub create: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_scheme_handler_factory_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            scheme_name: *const cef_string_t,
            request: *mut _cef_request_t,
        ) -> *mut _cef_resource_handler_t,
    >,
}
#[test]
fn bindgen_test_layout__cef_scheme_handler_factory_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_scheme_handler_factory_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_scheme_handler_factory_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_scheme_handler_factory_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_scheme_handler_factory_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_scheme_handler_factory_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_scheme_handler_factory_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).create) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_scheme_handler_factory_t),
            "::",
            stringify!(create)
        )
    );
}
#[doc = "\n Structure that creates cef_resource_handler_t instances for handling scheme\n requests. The functions of this structure will always be called on the IO\n thread.\n"]
pub type cef_scheme_handler_factory_t = _cef_scheme_handler_factory_t;
#[doc = "\n Implement this structure to provide handler implementations. Methods will be\n called by the process and/or thread indicated.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_app_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Provides an opportunity to view and/or modify command-line arguments before\n processing by CEF and Chromium. The |process_type| value will be NULL for\n the browser process. Do not keep a reference to the cef_command_line_t\n object passed to this function. The CefSettings.command_line_args_disabled\n value can be used to start with an NULL command-line object. Any values\n specified in CefSettings that equate to command-line arguments will be set\n before this function is called. Be cautious when using this function to\n modify command-line arguments for non-browser processes as this may result\n in undefined behavior including crashes.\n"]
    pub on_before_command_line_processing: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_app_t,
            process_type: *const cef_string_t,
            command_line: *mut _cef_command_line_t,
        ),
    >,
    #[doc = "\n Provides an opportunity to register custom schemes. Do not keep a reference\n to the |registrar| object. This function is called on the main thread for\n each process and the registered schemes should be the same across all\n processes.\n"]
    pub on_register_custom_schemes: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_app_t, registrar: *mut _cef_scheme_registrar_t),
    >,
    #[doc = "\n Return the handler for resource bundle events. If\n CefSettings.pack_loading_disabled is true (1) a handler must be returned.\n If no handler is returned resources will be loaded from pack files. This\n function is called by the browser and render processes on multiple threads.\n"]
    pub get_resource_bundle_handler: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_app_t) -> *mut _cef_resource_bundle_handler_t,
    >,
    #[doc = "\n Return the handler for functionality specific to the browser process. This\n function is called on multiple threads in the browser process.\n"]
    pub get_browser_process_handler: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_app_t) -> *mut _cef_browser_process_handler_t,
    >,
    #[doc = "\n Return the handler for functionality specific to the render process. This\n function is called on the render process main thread.\n"]
    pub get_render_process_handler: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_app_t) -> *mut _cef_render_process_handler_t,
    >,
}
#[test]
fn bindgen_test_layout__cef_app_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_app_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_app_t>(),
        80usize,
        concat!("Size of: ", stringify!(_cef_app_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_app_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_app_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_app_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).on_before_command_line_processing) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_app_t),
            "::",
            stringify!(on_before_command_line_processing)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_register_custom_schemes) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_app_t),
            "::",
            stringify!(on_register_custom_schemes)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).get_resource_bundle_handler) as usize - ptr as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_app_t),
            "::",
            stringify!(get_resource_bundle_handler)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).get_browser_process_handler) as usize - ptr as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_app_t),
            "::",
            stringify!(get_browser_process_handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_render_process_handler) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_app_t),
            "::",
            stringify!(get_render_process_handler)
        )
    );
}
#[doc = "\n Implement this structure to provide handler implementations. Methods will be\n called by the process and/or thread indicated.\n"]
pub type cef_app_t = _cef_app_t;
#[doc = "\n Information about a specific web plugin.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_web_plugin_info_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Returns the plugin name.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_name: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_web_plugin_info_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the plugin file path (DLL/bundle/library).\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_path: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_web_plugin_info_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the version of the plugin (may be OS-specific).\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_version: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_web_plugin_info_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns a description of the plugin from the version information.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_description: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_web_plugin_info_t) -> cef_string_userfree_t,
    >,
}
#[test]
fn bindgen_test_layout__cef_web_plugin_info_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_web_plugin_info_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_web_plugin_info_t>(),
        72usize,
        concat!("Size of: ", stringify!(_cef_web_plugin_info_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_web_plugin_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_web_plugin_info_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_web_plugin_info_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_name) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_web_plugin_info_t),
            "::",
            stringify!(get_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_path) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_web_plugin_info_t),
            "::",
            stringify!(get_path)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_version) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_web_plugin_info_t),
            "::",
            stringify!(get_version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_description) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_web_plugin_info_t),
            "::",
            stringify!(get_description)
        )
    );
}
#[doc = "\n Information about a specific web plugin.\n"]
pub type cef_web_plugin_info_t = _cef_web_plugin_info_t;
#[doc = "\n Structure to implement for visiting web plugin information. The functions of\n this structure will be called on the browser process UI thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_web_plugin_info_visitor_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Method that will be called once for each plugin. |count| is the 0-based\n index for the current plugin. |total| is the total number of plugins.\n Return false (0) to stop visiting plugins. This function may never be\n called if no plugins are found.\n"]
    pub visit: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_web_plugin_info_visitor_t,
            info: *mut _cef_web_plugin_info_t,
            count: ::core::ffi::c_int,
            total: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_web_plugin_info_visitor_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_web_plugin_info_visitor_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_web_plugin_info_visitor_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_web_plugin_info_visitor_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_web_plugin_info_visitor_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_web_plugin_info_visitor_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_web_plugin_info_visitor_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).visit) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_web_plugin_info_visitor_t),
            "::",
            stringify!(visit)
        )
    );
}
#[doc = "\n Structure to implement for visiting web plugin information. The functions of\n this structure will be called on the browser process UI thread.\n"]
pub type cef_web_plugin_info_visitor_t = _cef_web_plugin_info_visitor_t;
#[doc = "\n Structure to implement for receiving unstable plugin information. The\n functions of this structure will be called on the browser process IO thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_web_plugin_unstable_callback_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Method that will be called for the requested plugin. |unstable| will be\n true (1) if the plugin has reached the crash count threshold of 3 times in\n 120 seconds.\n"]
    pub is_unstable: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_web_plugin_unstable_callback_t,
            path: *const cef_string_t,
            unstable: ::core::ffi::c_int,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_web_plugin_unstable_callback_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_web_plugin_unstable_callback_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_web_plugin_unstable_callback_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_web_plugin_unstable_callback_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_web_plugin_unstable_callback_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_cef_web_plugin_unstable_callback_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_web_plugin_unstable_callback_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_unstable) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_web_plugin_unstable_callback_t),
            "::",
            stringify!(is_unstable)
        )
    );
}
#[doc = "\n Structure to implement for receiving unstable plugin information. The\n functions of this structure will be called on the browser process IO thread.\n"]
pub type cef_web_plugin_unstable_callback_t = _cef_web_plugin_unstable_callback_t;
#[doc = "\n Implement this structure to receive notification when CDM registration is\n complete. The functions of this structure will be called on the browser\n process UI thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_register_cdm_callback_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Method that will be called when CDM registration is complete. |result| will\n be CEF_CDM_REGISTRATION_ERROR_NONE if registration completed successfully.\n Otherwise, |result| and |error_message| will contain additional information\n about why registration failed.\n"]
    pub on_cdm_registration_complete: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_register_cdm_callback_t,
            result: cef_cdm_registration_error_t,
            error_message: *const cef_string_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_register_cdm_callback_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_register_cdm_callback_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_register_cdm_callback_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_register_cdm_callback_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_register_cdm_callback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_register_cdm_callback_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_register_cdm_callback_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).on_cdm_registration_complete) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_register_cdm_callback_t),
            "::",
            stringify!(on_cdm_registration_complete)
        )
    );
}
#[doc = "\n Implement this structure to receive notification when CDM registration is\n complete. The functions of this structure will be called on the browser\n process UI thread.\n"]
pub type cef_register_cdm_callback_t = _cef_register_cdm_callback_t;
#[doc = "\n Implement this structure to provide handler implementations. The handler\n instance will not be released until all objects related to the context have\n been destroyed.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_request_context_handler_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Called on the browser process UI thread immediately after the request\n context has been initialized.\n"]
    pub on_request_context_initialized: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_handler_t,
            request_context: *mut _cef_request_context_t,
        ),
    >,
    #[doc = "\n Called on multiple browser process threads before a plugin instance is\n loaded. |mime_type| is the mime type of the plugin that will be loaded.\n |plugin_url| is the content URL that the plugin will load and may be NULL.\n |is_main_frame| will be true (1) if the plugin is being loaded in the main\n (top-level) frame, |top_origin_url| is the URL for the top-level frame that\n contains the plugin when loading a specific plugin instance or NULL when\n building the initial list of enabled plugins for 'navigator.plugins'\n JavaScript state. |plugin_info| includes additional information about the\n plugin that will be loaded. |plugin_policy| is the recommended policy.\n Modify |plugin_policy| and return true (1) to change the policy. Return\n false (0) to use the recommended policy. The default plugin policy can be\n set at runtime using the `--plugin-policy=[allow|detect|block]` command-\n line flag. Decisions to mark a plugin as disabled by setting\n |plugin_policy| to PLUGIN_POLICY_DISABLED may be cached when\n |top_origin_url| is NULL. To purge the plugin list cache and potentially\n trigger new calls to this function call\n cef_request_context_t::PurgePluginListCache.\n"]
    pub on_before_plugin_load: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_handler_t,
            mime_type: *const cef_string_t,
            plugin_url: *const cef_string_t,
            is_main_frame: ::core::ffi::c_int,
            top_origin_url: *const cef_string_t,
            plugin_info: *mut _cef_web_plugin_info_t,
            plugin_policy: *mut cef_plugin_policy_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Called on the browser process IO thread before a resource request is\n initiated. The |browser| and |frame| values represent the source of the\n request, and may be NULL for requests originating from service workers or\n cef_urlrequest_t. |request| represents the request contents and cannot be\n modified in this callback. |is_navigation| will be true (1) if the resource\n request is a navigation. |is_download| will be true (1) if the resource\n request is a download. |request_initiator| is the origin (scheme + domain)\n of the page that initiated the request. Set |disable_default_handling| to\n true (1) to disable default handling of the request, in which case it will\n need to be handled via cef_resource_request_handler_t::GetResourceHandler\n or it will be canceled. To allow the resource load to proceed with default\n handling return NULL. To specify a handler for the resource return a\n cef_resource_request_handler_t object. This function will not be called if\n the client associated with |browser| returns a non-NULL value from\n cef_request_handler_t::GetResourceRequestHandler for the same request\n (identified by cef_request_t::GetIdentifier).\n"]
    pub get_resource_request_handler: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            request: *mut _cef_request_t,
            is_navigation: ::core::ffi::c_int,
            is_download: ::core::ffi::c_int,
            request_initiator: *const cef_string_t,
            disable_default_handling: *mut ::core::ffi::c_int,
        ) -> *mut _cef_resource_request_handler_t,
    >,
}
#[test]
fn bindgen_test_layout__cef_request_context_handler_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_request_context_handler_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_request_context_handler_t>(),
        64usize,
        concat!("Size of: ", stringify!(_cef_request_context_handler_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_request_context_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_request_context_handler_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_context_handler_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).on_request_context_initialized) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_context_handler_t),
            "::",
            stringify!(on_request_context_initialized)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_before_plugin_load) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_context_handler_t),
            "::",
            stringify!(on_before_plugin_load)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).get_resource_request_handler) as usize - ptr as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_request_context_handler_t),
            "::",
            stringify!(get_resource_request_handler)
        )
    );
}
#[doc = "\n Implement this structure to provide handler implementations. The handler\n instance will not be released until all objects related to the context have\n been destroyed.\n"]
pub type cef_request_context_handler_t = _cef_request_context_handler_t;
#[doc = "\n Structure used for retrieving resources from the resource bundle (*.pak)\n files loaded by CEF during startup or via the cef_resource_bundle_handler_t\n returned from cef_app_t::GetResourceBundleHandler. See CefSettings for\n additional options related to resource bundle loading. The functions of this\n structure may be called on any thread unless otherwise indicated.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_resource_bundle_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Returns the localized string for the specified |string_id| or an NULL\n string if the value is not found. Include cef_pack_strings.h for a listing\n of valid string ID values.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_localized_string: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_bundle_t,
            string_id: ::core::ffi::c_int,
        ) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns a cef_binary_value_t containing the decompressed contents of the\n specified scale independent |resource_id| or NULL if not found. Include\n cef_pack_resources.h for a listing of valid resource ID values.\n"]
    pub get_data_resource: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_bundle_t,
            resource_id: ::core::ffi::c_int,
        ) -> *mut _cef_binary_value_t,
    >,
    #[doc = "\n Returns a cef_binary_value_t containing the decompressed contents of the\n specified |resource_id| nearest the scale factor |scale_factor| or NULL if\n not found. Use a |scale_factor| value of SCALE_FACTOR_NONE for scale\n independent resources or call GetDataResource instead.Include\n cef_pack_resources.h for a listing of valid resource ID values.\n"]
    pub get_data_resource_for_scale: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_bundle_t,
            resource_id: ::core::ffi::c_int,
            scale_factor: cef_scale_factor_t,
        ) -> *mut _cef_binary_value_t,
    >,
}
#[test]
fn bindgen_test_layout__cef_resource_bundle_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_resource_bundle_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_resource_bundle_t>(),
        64usize,
        concat!("Size of: ", stringify!(_cef_resource_bundle_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_resource_bundle_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_resource_bundle_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_resource_bundle_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_localized_string) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_resource_bundle_t),
            "::",
            stringify!(get_localized_string)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_data_resource) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_resource_bundle_t),
            "::",
            stringify!(get_data_resource)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).get_data_resource_for_scale) as usize - ptr as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_resource_bundle_t),
            "::",
            stringify!(get_data_resource_for_scale)
        )
    );
}
#[doc = "\n Structure used for retrieving resources from the resource bundle (*.pak)\n files loaded by CEF during startup or via the cef_resource_bundle_handler_t\n returned from cef_app_t::GetResourceBundleHandler. See CefSettings for\n additional options related to resource bundle loading. The functions of this\n structure may be called on any thread unless otherwise indicated.\n"]
pub type cef_resource_bundle_t = _cef_resource_bundle_t;
#[doc = "\n Structure representing a server that supports HTTP and WebSocket requests.\n Server capacity is limited and is intended to handle only a small number of\n simultaneous connections (e.g. for communicating between applications on\n localhost). The functions of this structure are safe to call from any thread\n in the brower process unless otherwise indicated.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_server_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Returns the task runner for the dedicated server thread.\n"]
    pub get_task_runner: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_server_t) -> *mut _cef_task_runner_t,
    >,
    #[doc = "\n Stop the server and shut down the dedicated server thread. See\n cef_server_handler_t::OnServerCreated documentation for a description of\n server lifespan.\n"]
    pub shutdown: ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_server_t)>,
    #[doc = "\n Returns true (1) if the server is currently running and accepting incoming\n connections. See cef_server_handler_t::OnServerCreated documentation for a\n description of server lifespan. This function must be called on the\n dedicated server thread.\n"]
    pub is_running: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_server_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the server address including the port number.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_address: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_server_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns true (1) if the server currently has a connection. This function\n must be called on the dedicated server thread.\n"]
    pub has_connection: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_server_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if |connection_id| represents a valid connection. This\n function must be called on the dedicated server thread.\n"]
    pub is_valid_connection: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_server_t,
            connection_id: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Send an HTTP 200 \"OK\" response to the connection identified by\n |connection_id|. |content_type| is the response content type (e.g.\n \"text/html\"), |data| is the response content, and |data_size| is the size\n of |data| in bytes. The contents of |data| will be copied. The connection\n will be closed automatically after the response is sent.\n"]
    pub send_http200response: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_server_t,
            connection_id: ::core::ffi::c_int,
            content_type: *const cef_string_t,
            data: *const ::core::ffi::c_void,
            data_size: usize,
        ),
    >,
    #[doc = "\n Send an HTTP 404 \"Not Found\" response to the connection identified by\n |connection_id|. The connection will be closed automatically after the\n response is sent.\n"]
    pub send_http404response: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_server_t, connection_id: ::core::ffi::c_int),
    >,
    #[doc = "\n Send an HTTP 500 \"Internal Server Error\" response to the connection\n identified by |connection_id|. |error_message| is the associated error\n message. The connection will be closed automatically after the response is\n sent.\n"]
    pub send_http500response: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_server_t,
            connection_id: ::core::ffi::c_int,
            error_message: *const cef_string_t,
        ),
    >,
    #[doc = "\n Send a custom HTTP response to the connection identified by\n |connection_id|. |response_code| is the HTTP response code sent in the\n status line (e.g. 200), |content_type| is the response content type sent as\n the \"Content-Type\" header (e.g. \"text/html\"), |content_length| is the\n expected content length, and |extra_headers| is the map of extra response\n headers. If |content_length| is >= 0 then the \"Content-Length\" header will\n be sent. If |content_length| is 0 then no content is expected and the\n connection will be closed automatically after the response is sent. If\n |content_length| is < 0 then no \"Content-Length\" header will be sent and\n the client will continue reading until the connection is closed. Use the\n SendRawData function to send the content, if applicable, and call\n CloseConnection after all content has been sent.\n"]
    pub send_http_response: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_server_t,
            connection_id: ::core::ffi::c_int,
            response_code: ::core::ffi::c_int,
            content_type: *const cef_string_t,
            content_length: int64,
            extra_headers: cef_string_multimap_t,
        ),
    >,
    #[doc = "\n Send raw data directly to the connection identified by |connection_id|.\n |data| is the raw data and |data_size| is the size of |data| in bytes. The\n contents of |data| will be copied. No validation of |data| is performed\n internally so the client should be careful to send the amount indicated by\n the \"Content-Length\" header, if specified. See SendHttpResponse\n documentation for intended usage.\n"]
    pub send_raw_data: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_server_t,
            connection_id: ::core::ffi::c_int,
            data: *const ::core::ffi::c_void,
            data_size: usize,
        ),
    >,
    #[doc = "\n Close the connection identified by |connection_id|. See SendHttpResponse\n documentation for intended usage.\n"]
    pub close_connection: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_server_t, connection_id: ::core::ffi::c_int),
    >,
    #[doc = "\n Send a WebSocket message to the connection identified by |connection_id|.\n |data| is the response content and |data_size| is the size of |data| in\n bytes. The contents of |data| will be copied. See\n cef_server_handler_t::OnWebSocketRequest documentation for intended usage.\n"]
    pub send_web_socket_message: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_server_t,
            connection_id: ::core::ffi::c_int,
            data: *const ::core::ffi::c_void,
            data_size: usize,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_server_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_server_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_server_t>(),
        144usize,
        concat!("Size of: ", stringify!(_cef_server_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_server_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_server_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_server_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_task_runner) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_server_t),
            "::",
            stringify!(get_task_runner)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).shutdown) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_server_t),
            "::",
            stringify!(shutdown)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_running) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_server_t),
            "::",
            stringify!(is_running)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_address) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_server_t),
            "::",
            stringify!(get_address)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_connection) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_server_t),
            "::",
            stringify!(has_connection)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_valid_connection) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_server_t),
            "::",
            stringify!(is_valid_connection)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_http200response) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_server_t),
            "::",
            stringify!(send_http200response)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_http404response) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_server_t),
            "::",
            stringify!(send_http404response)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_http500response) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_server_t),
            "::",
            stringify!(send_http500response)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_http_response) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_server_t),
            "::",
            stringify!(send_http_response)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_raw_data) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_server_t),
            "::",
            stringify!(send_raw_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).close_connection) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_server_t),
            "::",
            stringify!(close_connection)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).send_web_socket_message) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_server_t),
            "::",
            stringify!(send_web_socket_message)
        )
    );
}
#[doc = "\n Structure representing a server that supports HTTP and WebSocket requests.\n Server capacity is limited and is intended to handle only a small number of\n simultaneous connections (e.g. for communicating between applications on\n localhost). The functions of this structure are safe to call from any thread\n in the brower process unless otherwise indicated.\n"]
pub type cef_server_t = _cef_server_t;
#[doc = "\n Implement this structure to handle HTTP server requests. A new thread will be\n created for each cef_server_t::CreateServer call (the \"dedicated server\n thread\"), and the functions of this structure will be called on that thread.\n It is therefore recommended to use a different cef_server_handler_t instance\n for each cef_server_t::CreateServer call to avoid thread safety issues in the\n cef_server_handler_t implementation.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_server_handler_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Called when |server| is created. If the server was started successfully\n then cef_server_t::IsRunning will return true (1). The server will continue\n running until cef_server_t::Shutdown is called, after which time\n OnServerDestroyed will be called. If the server failed to start then\n OnServerDestroyed will be called immediately after this function returns.\n"]
    pub on_server_created: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_server_handler_t, server: *mut _cef_server_t),
    >,
    #[doc = "\n Called when |server| is destroyed. The server thread will be stopped after\n this function returns. The client should release any references to |server|\n when this function is called. See OnServerCreated documentation for a\n description of server lifespan.\n"]
    pub on_server_destroyed: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_server_handler_t, server: *mut _cef_server_t),
    >,
    #[doc = "\n Called when a client connects to |server|. |connection_id| uniquely\n identifies the connection. Each call to this function will have a matching\n call to OnClientDisconnected.\n"]
    pub on_client_connected: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_server_handler_t,
            server: *mut _cef_server_t,
            connection_id: ::core::ffi::c_int,
        ),
    >,
    #[doc = "\n Called when a client disconnects from |server|. |connection_id| uniquely\n identifies the connection. The client should release any data associated\n with |connection_id| when this function is called and |connection_id|\n should no longer be passed to cef_server_t functions. Disconnects can\n originate from either the client or the server. For example, the server\n will disconnect automatically after a cef_server_t::SendHttpXXXResponse\n function is called.\n"]
    pub on_client_disconnected: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_server_handler_t,
            server: *mut _cef_server_t,
            connection_id: ::core::ffi::c_int,
        ),
    >,
    #[doc = "\n Called when |server| receives an HTTP request. |connection_id| uniquely\n identifies the connection, |client_address| is the requesting IPv4 or IPv6\n client address including port number, and |request| contains the request\n contents (URL, function, headers and optional POST data). Call cef_server_t\n functions either synchronously or asynchronusly to send a response.\n"]
    pub on_http_request: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_server_handler_t,
            server: *mut _cef_server_t,
            connection_id: ::core::ffi::c_int,
            client_address: *const cef_string_t,
            request: *mut _cef_request_t,
        ),
    >,
    #[doc = "\n Called when |server| receives a WebSocket request. |connection_id| uniquely\n identifies the connection, |client_address| is the requesting IPv4 or IPv6\n client address including port number, and |request| contains the request\n contents (URL, function, headers and optional POST data). Execute\n |callback| either synchronously or asynchronously to accept or decline the\n WebSocket connection. If the request is accepted then OnWebSocketConnected\n will be called after the WebSocket has connected and incoming messages will\n be delivered to the OnWebSocketMessage callback. If the request is declined\n then the client will be disconnected and OnClientDisconnected will be\n called. Call the cef_server_t::SendWebSocketMessage function after\n receiving the OnWebSocketConnected callback to respond with WebSocket\n messages.\n"]
    pub on_web_socket_request: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_server_handler_t,
            server: *mut _cef_server_t,
            connection_id: ::core::ffi::c_int,
            client_address: *const cef_string_t,
            request: *mut _cef_request_t,
            callback: *mut _cef_callback_t,
        ),
    >,
    #[doc = "\n Called after the client has accepted the WebSocket connection for |server|\n and |connection_id| via the OnWebSocketRequest callback. See\n OnWebSocketRequest documentation for intended usage.\n"]
    pub on_web_socket_connected: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_server_handler_t,
            server: *mut _cef_server_t,
            connection_id: ::core::ffi::c_int,
        ),
    >,
    #[doc = "\n Called when |server| receives an WebSocket message. |connection_id|\n uniquely identifies the connection, |data| is the message content and\n |data_size| is the size of |data| in bytes. Do not keep a reference to\n |data| outside of this function. See OnWebSocketRequest documentation for\n intended usage.\n"]
    pub on_web_socket_message: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_server_handler_t,
            server: *mut _cef_server_t,
            connection_id: ::core::ffi::c_int,
            data: *const ::core::ffi::c_void,
            data_size: usize,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_server_handler_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_server_handler_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_server_handler_t>(),
        104usize,
        concat!("Size of: ", stringify!(_cef_server_handler_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_server_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_server_handler_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_server_handler_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_server_created) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_server_handler_t),
            "::",
            stringify!(on_server_created)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_server_destroyed) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_server_handler_t),
            "::",
            stringify!(on_server_destroyed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_client_connected) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_server_handler_t),
            "::",
            stringify!(on_client_connected)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_client_disconnected) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_server_handler_t),
            "::",
            stringify!(on_client_disconnected)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_http_request) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_server_handler_t),
            "::",
            stringify!(on_http_request)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_web_socket_request) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_server_handler_t),
            "::",
            stringify!(on_web_socket_request)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_web_socket_connected) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_server_handler_t),
            "::",
            stringify!(on_web_socket_connected)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_web_socket_message) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_server_handler_t),
            "::",
            stringify!(on_web_socket_message)
        )
    );
}
#[doc = "\n Implement this structure to handle HTTP server requests. A new thread will be\n created for each cef_server_t::CreateServer call (the \"dedicated server\n thread\"), and the functions of this structure will be called on that thread.\n It is therefore recommended to use a different cef_server_handler_t instance\n for each cef_server_t::CreateServer call to avoid thread safety issues in the\n cef_server_handler_t implementation.\n"]
pub type cef_server_handler_t = _cef_server_handler_t;
pub type cef_platform_thread_id_t = DWORD;
pub type cef_platform_thread_handle_t = DWORD;
#[doc = "\n A simple thread abstraction that establishes a message loop on a new thread.\n The consumer uses cef_task_runner_t to execute code on the thread's message\n loop. The thread is terminated when the cef_thread_t object is destroyed or\n stop() is called. All pending tasks queued on the thread's message loop will\n run to completion before the thread is terminated. cef_thread_create() can be\n called on any valid CEF thread in either the browser or render process. This\n structure should only be used for tasks that require a dedicated thread. In\n most cases you can post tasks to an existing CEF thread instead of creating a\n new one; see cef_task.h for details.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_thread_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Returns the cef_task_runner_t that will execute code on this thread's\n message loop. This function is safe to call from any thread.\n"]
    pub get_task_runner: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_thread_t) -> *mut _cef_task_runner_t,
    >,
    #[doc = "\n Returns the platform thread ID. It will return the same value after stop()\n is called. This function is safe to call from any thread.\n"]
    pub get_platform_thread_id: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_thread_t) -> cef_platform_thread_id_t,
    >,
    #[doc = "\n Stop and join the thread. This function must be called from the same thread\n that called cef_thread_create(). Do not call this function if\n cef_thread_create() was called with a |stoppable| value of false (0).\n"]
    pub stop: ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_thread_t)>,
    #[doc = "\n Returns true (1) if the thread is currently running. This function must be\n called from the same thread that called cef_thread_create().\n"]
    pub is_running: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_thread_t) -> ::core::ffi::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_thread_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_thread_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_thread_t>(),
        72usize,
        concat!("Size of: ", stringify!(_cef_thread_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_thread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_thread_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_thread_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_task_runner) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_thread_t),
            "::",
            stringify!(get_task_runner)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_platform_thread_id) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_thread_t),
            "::",
            stringify!(get_platform_thread_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stop) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_thread_t),
            "::",
            stringify!(stop)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_running) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_thread_t),
            "::",
            stringify!(is_running)
        )
    );
}
#[doc = "\n A simple thread abstraction that establishes a message loop on a new thread.\n The consumer uses cef_task_runner_t to execute code on the thread's message\n loop. The thread is terminated when the cef_thread_t object is destroyed or\n stop() is called. All pending tasks queued on the thread's message loop will\n run to completion before the thread is terminated. cef_thread_create() can be\n called on any valid CEF thread in either the browser or render process. This\n structure should only be used for tasks that require a dedicated thread. In\n most cases you can post tasks to an existing CEF thread instead of creating a\n new one; see cef_task.h for details.\n"]
pub type cef_thread_t = _cef_thread_t;
#[doc = "\n Implement this structure to receive notification when tracing has completed.\n The functions of this structure will be called on the browser process UI\n thread.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_end_tracing_callback_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Called after all processes have sent their trace data. |tracing_file| is\n the path at which tracing data was written. The client is responsible for\n deleting |tracing_file|.\n"]
    pub on_end_tracing_complete: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_end_tracing_callback_t,
            tracing_file: *const cef_string_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_end_tracing_callback_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_end_tracing_callback_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_end_tracing_callback_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_end_tracing_callback_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_end_tracing_callback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_end_tracing_callback_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_end_tracing_callback_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_end_tracing_complete) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_end_tracing_callback_t),
            "::",
            stringify!(on_end_tracing_complete)
        )
    );
}
#[doc = "\n Implement this structure to receive notification when tracing has completed.\n The functions of this structure will be called on the browser process UI\n thread.\n"]
pub type cef_end_tracing_callback_t = _cef_end_tracing_callback_t;
#[doc = "\n Structure used to make a URL request. URL requests are not associated with a\n browser instance so no cef_client_t callbacks will be executed. URL requests\n can be created on any valid CEF thread in either the browser or render\n process. Once created the functions of the URL request object must be\n accessed on the same thread that created it.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_urlrequest_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Returns the request object used to create this URL request. The returned\n object is read-only and should not be modified.\n"]
    pub get_request: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_urlrequest_t) -> *mut _cef_request_t,
    >,
    #[doc = "\n Returns the client.\n"]
    pub get_client: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_urlrequest_t) -> *mut _cef_urlrequest_client_t,
    >,
    #[doc = "\n Returns the request status.\n"]
    pub get_request_status: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_urlrequest_t) -> cef_urlrequest_status_t,
    >,
    #[doc = "\n Returns the request error if status is UR_CANCELED or UR_FAILED, or 0\n otherwise.\n"]
    pub get_request_error: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_urlrequest_t) -> cef_errorcode_t,
    >,
    #[doc = "\n Returns the response, or NULL if no response information is available.\n Response information will only be available after the upload has completed.\n The returned object is read-only and should not be modified.\n"]
    pub get_response: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_urlrequest_t) -> *mut _cef_response_t,
    >,
    #[doc = "\n Returns true (1) if the response body was served from the cache. This\n includes responses for which revalidation was required.\n"]
    pub response_was_cached: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_urlrequest_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Cancel the request.\n"]
    pub cancel: ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_urlrequest_t)>,
}
#[test]
fn bindgen_test_layout__cef_urlrequest_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_urlrequest_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_urlrequest_t>(),
        96usize,
        concat!("Size of: ", stringify!(_cef_urlrequest_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_urlrequest_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_urlrequest_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_urlrequest_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_request) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_urlrequest_t),
            "::",
            stringify!(get_request)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_client) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_urlrequest_t),
            "::",
            stringify!(get_client)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_request_status) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_urlrequest_t),
            "::",
            stringify!(get_request_status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_request_error) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_urlrequest_t),
            "::",
            stringify!(get_request_error)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_response) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_urlrequest_t),
            "::",
            stringify!(get_response)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).response_was_cached) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_urlrequest_t),
            "::",
            stringify!(response_was_cached)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cancel) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_urlrequest_t),
            "::",
            stringify!(cancel)
        )
    );
}
#[doc = "\n Structure used to make a URL request. URL requests are not associated with a\n browser instance so no cef_client_t callbacks will be executed. URL requests\n can be created on any valid CEF thread in either the browser or render\n process. Once created the functions of the URL request object must be\n accessed on the same thread that created it.\n"]
pub type cef_urlrequest_t = _cef_urlrequest_t;
#[doc = "\n Structure that should be implemented by the cef_urlrequest_t client. The\n functions of this structure will be called on the same thread that created\n the request unless otherwise documented.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_urlrequest_client_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Notifies the client that the request has completed. Use the\n cef_urlrequest_t::GetRequestStatus function to determine if the request was\n successful or not.\n"]
    pub on_request_complete: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_urlrequest_client_t, request: *mut _cef_urlrequest_t),
    >,
    #[doc = "\n Notifies the client of upload progress. |current| denotes the number of\n bytes sent so far and |total| is the total size of uploading data (or -1 if\n chunked upload is enabled). This function will only be called if the\n UR_FLAG_REPORT_UPLOAD_PROGRESS flag is set on the request.\n"]
    pub on_upload_progress: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_urlrequest_client_t,
            request: *mut _cef_urlrequest_t,
            current: int64,
            total: int64,
        ),
    >,
    #[doc = "\n Notifies the client of download progress. |current| denotes the number of\n bytes received up to the call and |total| is the expected total size of the\n response (or -1 if not determined).\n"]
    pub on_download_progress: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_urlrequest_client_t,
            request: *mut _cef_urlrequest_t,
            current: int64,
            total: int64,
        ),
    >,
    #[doc = "\n Called when some part of the response is read. |data| contains the current\n bytes received since the last call. This function will not be called if the\n UR_FLAG_NO_DOWNLOAD_DATA flag is set on the request.\n"]
    pub on_download_data: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_urlrequest_client_t,
            request: *mut _cef_urlrequest_t,
            data: *const ::core::ffi::c_void,
            data_length: usize,
        ),
    >,
    #[doc = "\n Called on the IO thread when the browser needs credentials from the user.\n |isProxy| indicates whether the host is a proxy server. |host| contains the\n hostname and |port| contains the port number. Return true (1) to continue\n the request and call cef_auth_callback_t::cont() when the authentication\n information is available. If the request has an associated browser/frame\n then returning false (0) will result in a call to GetAuthCredentials on the\n cef_request_handler_t associated with that browser, if any. Otherwise,\n returning false (0) will cancel the request immediately. This function will\n only be called for requests initiated from the browser process.\n"]
    pub get_auth_credentials: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_urlrequest_client_t,
            isProxy: ::core::ffi::c_int,
            host: *const cef_string_t,
            port: ::core::ffi::c_int,
            realm: *const cef_string_t,
            scheme: *const cef_string_t,
            callback: *mut _cef_auth_callback_t,
        ) -> ::core::ffi::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_urlrequest_client_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_urlrequest_client_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_urlrequest_client_t>(),
        80usize,
        concat!("Size of: ", stringify!(_cef_urlrequest_client_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_urlrequest_client_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_urlrequest_client_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_urlrequest_client_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_request_complete) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_urlrequest_client_t),
            "::",
            stringify!(on_request_complete)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_upload_progress) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_urlrequest_client_t),
            "::",
            stringify!(on_upload_progress)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_download_progress) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_urlrequest_client_t),
            "::",
            stringify!(on_download_progress)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).on_download_data) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_urlrequest_client_t),
            "::",
            stringify!(on_download_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_auth_credentials) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_urlrequest_client_t),
            "::",
            stringify!(get_auth_credentials)
        )
    );
}
#[doc = "\n Structure that should be implemented by the cef_urlrequest_t client. The\n functions of this structure will be called on the same thread that created\n the request unless otherwise documented.\n"]
pub type cef_urlrequest_client_t = _cef_urlrequest_client_t;
#[doc = "\n WaitableEvent is a thread synchronization tool that allows one thread to wait\n for another thread to finish some work. This is equivalent to using a\n Lock+ConditionVariable to protect a simple boolean value. However, using\n WaitableEvent in conjunction with a Lock to wait for a more complex state\n change (e.g., for an item to be added to a queue) is not recommended. In that\n case consider using a ConditionVariable instead of a WaitableEvent. It is\n safe to create and/or signal a WaitableEvent from any thread. Blocking on a\n WaitableEvent by calling the *wait() functions is not allowed on the browser\n process UI or IO threads.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_waitable_event_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Put the event in the un-signaled state.\n"]
    pub reset: ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_waitable_event_t)>,
    #[doc = "\n Put the event in the signaled state. This causes any thread blocked on Wait\n to be woken up.\n"]
    pub signal: ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_waitable_event_t)>,
    #[doc = "\n Returns true (1) if the event is in the signaled state, else false (0). If\n the event was created with |automatic_reset| set to true (1) then calling\n this function will also cause a reset.\n"]
    pub is_signaled: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_waitable_event_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Wait indefinitely for the event to be signaled. This function will not\n return until after the call to signal() has completed. This function cannot\n be called on the browser process UI or IO threads.\n"]
    pub wait: ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_waitable_event_t)>,
    #[doc = "\n Wait up to |max_ms| milliseconds for the event to be signaled. Returns true\n (1) if the event was signaled. A return value of false (0) does not\n necessarily mean that |max_ms| was exceeded. This function will not return\n until after the call to signal() has completed. This function cannot be\n called on the browser process UI or IO threads.\n"]
    pub timed_wait: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_waitable_event_t,
            max_ms: int64,
        ) -> ::core::ffi::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_waitable_event_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_waitable_event_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_waitable_event_t>(),
        80usize,
        concat!("Size of: ", stringify!(_cef_waitable_event_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_waitable_event_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_waitable_event_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_waitable_event_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reset) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_waitable_event_t),
            "::",
            stringify!(reset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).signal) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_waitable_event_t),
            "::",
            stringify!(signal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_signaled) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_waitable_event_t),
            "::",
            stringify!(is_signaled)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wait) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_waitable_event_t),
            "::",
            stringify!(wait)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timed_wait) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_waitable_event_t),
            "::",
            stringify!(timed_wait)
        )
    );
}
#[doc = "\n WaitableEvent is a thread synchronization tool that allows one thread to wait\n for another thread to finish some work. This is equivalent to using a\n Lock+ConditionVariable to protect a simple boolean value. However, using\n WaitableEvent in conjunction with a Lock to wait for a more complex state\n change (e.g., for an item to be added to a queue) is not recommended. In that\n case consider using a ConditionVariable instead of a WaitableEvent. It is\n safe to create and/or signal a WaitableEvent from any thread. Blocking on a\n WaitableEvent by calling the *wait() functions is not allowed on the browser\n process UI or IO threads.\n"]
pub type cef_waitable_event_t = _cef_waitable_event_t;
#[doc = "\n Structure that supports the reading of XML data via the libxml streaming API.\n The functions of this structure should only be called on the thread that\n creates the object.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_xml_reader_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Moves the cursor to the next node in the document. This function must be\n called at least once to set the current cursor position. Returns true (1)\n if the cursor position was set successfully.\n"]
    pub move_to_next_node: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_xml_reader_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Close the document. This should be called directly to ensure that cleanup\n occurs on the correct thread.\n"]
    pub close: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_xml_reader_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if an error has been reported by the XML parser.\n"]
    pub has_error: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_xml_reader_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the error string.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_error: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_xml_reader_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the node type.\n"]
    pub get_type: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_xml_reader_t) -> cef_xml_node_type_t,
    >,
    #[doc = "\n Returns the node depth. Depth starts at 0 for the root node.\n"]
    pub get_depth: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_xml_reader_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the local name. See http://www.w3.org/TR/REC-xml-names/#NT-\n LocalPart for additional details.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_local_name: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_xml_reader_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the namespace prefix. See http://www.w3.org/TR/REC-xml-names/ for\n additional details.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_prefix: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_xml_reader_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the qualified name, equal to (Prefix:)LocalName. See\n http://www.w3.org/TR/REC-xml-names/#ns-qualnames for additional details.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_qualified_name: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_xml_reader_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the URI defining the namespace associated with the node. See\n http://www.w3.org/TR/REC-xml-names/ for additional details.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_namespace_uri: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_xml_reader_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the base URI of the node. See http://www.w3.org/TR/xmlbase/ for\n additional details.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_base_uri: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_xml_reader_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the xml:lang scope within which the node resides. See\n http://www.w3.org/TR/REC-xml/#sec-lang-tag for additional details.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_xml_lang: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_xml_reader_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns true (1) if the node represents an NULL element. <a/> is considered\n NULL but <a></a> is not.\n"]
    pub is_empty_element: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_xml_reader_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns true (1) if the node has a text value.\n"]
    pub has_value: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_xml_reader_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the text value.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_value: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_xml_reader_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns true (1) if the node has attributes.\n"]
    pub has_attributes: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_xml_reader_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the number of attributes.\n"]
    pub get_attribute_count:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_xml_reader_t) -> usize>,
    #[doc = "\n Returns the value of the attribute at the specified 0-based index.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_attribute_byindex: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_xml_reader_t,
            index: ::core::ffi::c_int,
        ) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the value of the attribute with the specified qualified name.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_attribute_byqname: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_xml_reader_t,
            qualifiedName: *const cef_string_t,
        ) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the value of the attribute with the specified local name and\n namespace URI.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_attribute_bylname: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_xml_reader_t,
            localName: *const cef_string_t,
            namespaceURI: *const cef_string_t,
        ) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns an XML representation of the current node's children.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_inner_xml: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_xml_reader_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns an XML representation of the current node including its children.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_outer_xml: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_xml_reader_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the line number for the current node.\n"]
    pub get_line_number: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_xml_reader_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Moves the cursor to the attribute at the specified 0-based index. Returns\n true (1) if the cursor position was set successfully.\n"]
    pub move_to_attribute_byindex: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_xml_reader_t,
            index: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Moves the cursor to the attribute with the specified qualified name.\n Returns true (1) if the cursor position was set successfully.\n"]
    pub move_to_attribute_byqname: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_xml_reader_t,
            qualifiedName: *const cef_string_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Moves the cursor to the attribute with the specified local name and\n namespace URI. Returns true (1) if the cursor position was set\n successfully.\n"]
    pub move_to_attribute_bylname: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_xml_reader_t,
            localName: *const cef_string_t,
            namespaceURI: *const cef_string_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Moves the cursor to the first attribute in the current element. Returns\n true (1) if the cursor position was set successfully.\n"]
    pub move_to_first_attribute: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_xml_reader_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Moves the cursor to the next attribute in the current element. Returns true\n (1) if the cursor position was set successfully.\n"]
    pub move_to_next_attribute: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_xml_reader_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Moves the cursor back to the carrying element. Returns true (1) if the\n cursor position was set successfully.\n"]
    pub move_to_carrying_element: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_xml_reader_t) -> ::core::ffi::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_xml_reader_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_xml_reader_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_xml_reader_t>(),
        272usize,
        concat!("Size of: ", stringify!(_cef_xml_reader_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_xml_reader_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_xml_reader_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_xml_reader_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).move_to_next_node) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_xml_reader_t),
            "::",
            stringify!(move_to_next_node)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_xml_reader_t),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_error) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_xml_reader_t),
            "::",
            stringify!(has_error)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_error) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_xml_reader_t),
            "::",
            stringify!(get_error)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_type) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_xml_reader_t),
            "::",
            stringify!(get_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_depth) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_xml_reader_t),
            "::",
            stringify!(get_depth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_local_name) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_xml_reader_t),
            "::",
            stringify!(get_local_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_prefix) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_xml_reader_t),
            "::",
            stringify!(get_prefix)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_qualified_name) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_xml_reader_t),
            "::",
            stringify!(get_qualified_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_namespace_uri) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_xml_reader_t),
            "::",
            stringify!(get_namespace_uri)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_base_uri) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_xml_reader_t),
            "::",
            stringify!(get_base_uri)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_xml_lang) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_xml_reader_t),
            "::",
            stringify!(get_xml_lang)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_empty_element) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_xml_reader_t),
            "::",
            stringify!(is_empty_element)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_value) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_xml_reader_t),
            "::",
            stringify!(has_value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_value) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_xml_reader_t),
            "::",
            stringify!(get_value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).has_attributes) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_xml_reader_t),
            "::",
            stringify!(has_attributes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_attribute_count) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_xml_reader_t),
            "::",
            stringify!(get_attribute_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_attribute_byindex) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_xml_reader_t),
            "::",
            stringify!(get_attribute_byindex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_attribute_byqname) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_xml_reader_t),
            "::",
            stringify!(get_attribute_byqname)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_attribute_bylname) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_xml_reader_t),
            "::",
            stringify!(get_attribute_bylname)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_inner_xml) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_xml_reader_t),
            "::",
            stringify!(get_inner_xml)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_outer_xml) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_xml_reader_t),
            "::",
            stringify!(get_outer_xml)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_line_number) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_xml_reader_t),
            "::",
            stringify!(get_line_number)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).move_to_attribute_byindex) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_xml_reader_t),
            "::",
            stringify!(move_to_attribute_byindex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).move_to_attribute_byqname) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_xml_reader_t),
            "::",
            stringify!(move_to_attribute_byqname)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).move_to_attribute_bylname) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_xml_reader_t),
            "::",
            stringify!(move_to_attribute_bylname)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).move_to_first_attribute) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_xml_reader_t),
            "::",
            stringify!(move_to_first_attribute)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).move_to_next_attribute) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_xml_reader_t),
            "::",
            stringify!(move_to_next_attribute)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).move_to_carrying_element) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_xml_reader_t),
            "::",
            stringify!(move_to_carrying_element)
        )
    );
}
#[doc = "\n Structure that supports the reading of XML data via the libxml streaming API.\n The functions of this structure should only be called on the thread that\n creates the object.\n"]
pub type cef_xml_reader_t = _cef_xml_reader_t;
#[doc = "\n Structure that supports the reading of zip archives via the zlib unzip API.\n The functions of this structure should only be called on the thread that\n creates the object.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_zip_reader_t {
    #[doc = "\n Base structure.\n"]
    pub base: cef_base_ref_counted_t,
    #[doc = "\n Moves the cursor to the first file in the archive. Returns true (1) if the\n cursor position was set successfully.\n"]
    pub move_to_first_file: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_zip_reader_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Moves the cursor to the next file in the archive. Returns true (1) if the\n cursor position was set successfully.\n"]
    pub move_to_next_file: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_zip_reader_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Moves the cursor to the specified file in the archive. If |caseSensitive|\n is true (1) then the search will be case sensitive. Returns true (1) if the\n cursor position was set successfully.\n"]
    pub move_to_file: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_zip_reader_t,
            fileName: *const cef_string_t,
            caseSensitive: ::core::ffi::c_int,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Closes the archive. This should be called directly to ensure that cleanup\n occurs on the correct thread.\n"]
    pub close: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_zip_reader_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the name of the file.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub get_file_name: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_zip_reader_t) -> cef_string_userfree_t,
    >,
    #[doc = "\n Returns the uncompressed size of the file.\n"]
    pub get_file_size:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_zip_reader_t) -> int64>,
    #[doc = "\n Returns the last modified timestamp for the file.\n"]
    pub get_file_last_modified:
        ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_zip_reader_t) -> cef_time_t>,
    #[doc = "\n Opens the file for reading of uncompressed data. A read password may\n optionally be specified.\n"]
    pub open_file: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_zip_reader_t,
            password: *const cef_string_t,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Closes the file.\n"]
    pub close_file: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_zip_reader_t) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Read uncompressed file contents into the specified buffer. Returns < 0 if\n an error occurred, 0 if at the end of file, or the number of bytes read.\n"]
    pub read_file: ::core::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_zip_reader_t,
            buffer: *mut ::core::ffi::c_void,
            bufferSize: usize,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = "\n Returns the current offset in the uncompressed file contents.\n"]
    pub tell: ::core::option::Option<unsafe extern "C" fn(self_: *mut _cef_zip_reader_t) -> int64>,
    #[doc = "\n Returns true (1) if at end of the file contents.\n"]
    pub eof: ::core::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_zip_reader_t) -> ::core::ffi::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_zip_reader_t() {
    const UNINIT: ::core::mem::MaybeUninit<_cef_zip_reader_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_cef_zip_reader_t>(),
        136usize,
        concat!("Size of: ", stringify!(_cef_zip_reader_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_cef_zip_reader_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_zip_reader_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_zip_reader_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).move_to_first_file) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_zip_reader_t),
            "::",
            stringify!(move_to_first_file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).move_to_next_file) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_zip_reader_t),
            "::",
            stringify!(move_to_next_file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).move_to_file) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_zip_reader_t),
            "::",
            stringify!(move_to_file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_zip_reader_t),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_file_name) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_zip_reader_t),
            "::",
            stringify!(get_file_name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_file_size) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_zip_reader_t),
            "::",
            stringify!(get_file_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_file_last_modified) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_zip_reader_t),
            "::",
            stringify!(get_file_last_modified)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).open_file) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_zip_reader_t),
            "::",
            stringify!(open_file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).close_file) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_zip_reader_t),
            "::",
            stringify!(close_file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).read_file) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_zip_reader_t),
            "::",
            stringify!(read_file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tell) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_zip_reader_t),
            "::",
            stringify!(tell)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).eof) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_cef_zip_reader_t),
            "::",
            stringify!(eof)
        )
    );
}
#[doc = "\n Structure that supports the reading of zip archives via the zlib unzip API.\n The functions of this structure should only be called on the thread that\n creates the object.\n"]
pub type cef_zip_reader_t = _cef_zip_reader_t;
extern "C" {
    #[doc = "\n These functions set string values. If |copy| is true (1) the value will be\n copied instead of referenced. It is up to the user to properly manage\n the lifespan of references.\n"]
    pub fn cef_string_wide_set(
        src: *const wchar_t,
        src_len: usize,
        output: *mut cef_string_wide_t,
        copy: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn cef_string_utf8_set(
        src: *const ::core::ffi::c_char,
        src_len: usize,
        output: *mut cef_string_utf8_t,
        copy: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    pub fn cef_string_utf16_set(
        src: *const char16,
        src_len: usize,
        output: *mut cef_string_utf16_t,
        copy: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    #[doc = "\n These functions clear string values. The structure itself is not freed.\n"]
    pub fn cef_string_wide_clear(str_: *mut cef_string_wide_t);
    pub fn cef_string_utf8_clear(str_: *mut cef_string_utf8_t);
    pub fn cef_string_utf16_clear(str_: *mut cef_string_utf16_t);
    #[doc = "\n These functions compare two string values with the same results as strcmp().\n"]
    pub fn cef_string_wide_cmp(
        str1: *const cef_string_wide_t,
        str2: *const cef_string_wide_t,
    ) -> ::core::ffi::c_int;
    pub fn cef_string_utf8_cmp(
        str1: *const cef_string_utf8_t,
        str2: *const cef_string_utf8_t,
    ) -> ::core::ffi::c_int;
    pub fn cef_string_utf16_cmp(
        str1: *const cef_string_utf16_t,
        str2: *const cef_string_utf16_t,
    ) -> ::core::ffi::c_int;
    #[doc = "\n These functions convert between UTF-8, -16, and -32 strings. They are\n potentially slow so unnecessary conversions should be avoided. The best\n possible result will always be written to |output| with the boolean return\n value indicating whether the conversion is 100% valid.\n"]
    pub fn cef_string_wide_to_utf8(
        src: *const wchar_t,
        src_len: usize,
        output: *mut cef_string_utf8_t,
    ) -> ::core::ffi::c_int;
    pub fn cef_string_utf8_to_wide(
        src: *const ::core::ffi::c_char,
        src_len: usize,
        output: *mut cef_string_wide_t,
    ) -> ::core::ffi::c_int;
    pub fn cef_string_wide_to_utf16(
        src: *const wchar_t,
        src_len: usize,
        output: *mut cef_string_utf16_t,
    ) -> ::core::ffi::c_int;
    pub fn cef_string_utf16_to_wide(
        src: *const char16,
        src_len: usize,
        output: *mut cef_string_wide_t,
    ) -> ::core::ffi::c_int;
    pub fn cef_string_utf8_to_utf16(
        src: *const ::core::ffi::c_char,
        src_len: usize,
        output: *mut cef_string_utf16_t,
    ) -> ::core::ffi::c_int;
    pub fn cef_string_utf16_to_utf8(
        src: *const char16,
        src_len: usize,
        output: *mut cef_string_utf8_t,
    ) -> ::core::ffi::c_int;
    #[doc = "\n These functions convert an ASCII string, typically a hardcoded constant, to a\n Wide/UTF16 string. Use instead of the UTF8 conversion routines if you know\n the string is ASCII.\n"]
    pub fn cef_string_ascii_to_wide(
        src: *const ::core::ffi::c_char,
        src_len: usize,
        output: *mut cef_string_wide_t,
    ) -> ::core::ffi::c_int;
    pub fn cef_string_ascii_to_utf16(
        src: *const ::core::ffi::c_char,
        src_len: usize,
        output: *mut cef_string_utf16_t,
    ) -> ::core::ffi::c_int;
    #[doc = "\n These functions allocate a new string structure. They must be freed by\n calling the associated free function.\n"]
    pub fn cef_string_userfree_wide_alloc() -> cef_string_userfree_wide_t;
    pub fn cef_string_userfree_utf8_alloc() -> cef_string_userfree_utf8_t;
    pub fn cef_string_userfree_utf16_alloc() -> cef_string_userfree_utf16_t;
    #[doc = "\n These functions free the string structure allocated by the associated\n alloc function. Any string contents will first be cleared.\n"]
    pub fn cef_string_userfree_wide_free(str_: cef_string_userfree_wide_t);
    pub fn cef_string_userfree_utf8_free(str_: cef_string_userfree_utf8_t);
    pub fn cef_string_userfree_utf16_free(str_: cef_string_userfree_utf16_t);
    #[doc = "\n These functions convert utf16 string case using the current ICU locale. This\n may change the length of the string in some cases.\n"]
    pub fn cef_string_utf16_to_lower(
        src: *const char16,
        src_len: usize,
        output: *mut cef_string_utf16_t,
    ) -> ::core::ffi::c_int;
    pub fn cef_string_utf16_to_upper(
        src: *const char16,
        src_len: usize,
        output: *mut cef_string_utf16_t,
    ) -> ::core::ffi::c_int;
    #[doc = "\n Allocate a new string map.\n"]
    pub fn cef_string_list_alloc() -> cef_string_list_t;
    #[doc = "\n Return the number of elements in the string list.\n"]
    pub fn cef_string_list_size(list: cef_string_list_t) -> usize;
    #[doc = "\n Retrieve the value at the specified zero-based string list index. Returns\n true (1) if the value was successfully retrieved.\n"]
    pub fn cef_string_list_value(
        list: cef_string_list_t,
        index: usize,
        value: *mut cef_string_t,
    ) -> ::core::ffi::c_int;
    #[doc = "\n Append a new value at the end of the string list.\n"]
    pub fn cef_string_list_append(list: cef_string_list_t, value: *const cef_string_t);
    #[doc = "\n Clear the string list.\n"]
    pub fn cef_string_list_clear(list: cef_string_list_t);
    #[doc = "\n Free the string list.\n"]
    pub fn cef_string_list_free(list: cef_string_list_t);
    #[doc = "\n Creates a copy of an existing string list.\n"]
    pub fn cef_string_list_copy(list: cef_string_list_t) -> cef_string_list_t;
    #[doc = "\n Allocate a new string map.\n"]
    pub fn cef_string_map_alloc() -> cef_string_map_t;
    #[doc = "\n Return the number of elements in the string map.\n"]
    pub fn cef_string_map_size(map: cef_string_map_t) -> usize;
    #[doc = "\n Return the value assigned to the specified key.\n"]
    pub fn cef_string_map_find(
        map: cef_string_map_t,
        key: *const cef_string_t,
        value: *mut cef_string_t,
    ) -> ::core::ffi::c_int;
    #[doc = "\n Return the key at the specified zero-based string map index.\n"]
    pub fn cef_string_map_key(
        map: cef_string_map_t,
        index: usize,
        key: *mut cef_string_t,
    ) -> ::core::ffi::c_int;
    #[doc = "\n Return the value at the specified zero-based string map index.\n"]
    pub fn cef_string_map_value(
        map: cef_string_map_t,
        index: usize,
        value: *mut cef_string_t,
    ) -> ::core::ffi::c_int;
    #[doc = "\n Append a new key/value pair at the end of the string map.\n"]
    pub fn cef_string_map_append(
        map: cef_string_map_t,
        key: *const cef_string_t,
        value: *const cef_string_t,
    ) -> ::core::ffi::c_int;
    #[doc = "\n Clear the string map.\n"]
    pub fn cef_string_map_clear(map: cef_string_map_t);
    #[doc = "\n Free the string map.\n"]
    pub fn cef_string_map_free(map: cef_string_map_t);
    #[doc = "\n Allocate a new string multimap.\n"]
    pub fn cef_string_multimap_alloc() -> cef_string_multimap_t;
    #[doc = "\n Return the number of elements in the string multimap.\n"]
    pub fn cef_string_multimap_size(map: cef_string_multimap_t) -> usize;
    #[doc = "\n Return the number of values with the specified key.\n"]
    pub fn cef_string_multimap_find_count(
        map: cef_string_multimap_t,
        key: *const cef_string_t,
    ) -> usize;
    #[doc = "\n Return the value_index-th value with the specified key.\n"]
    pub fn cef_string_multimap_enumerate(
        map: cef_string_multimap_t,
        key: *const cef_string_t,
        value_index: usize,
        value: *mut cef_string_t,
    ) -> ::core::ffi::c_int;
    #[doc = "\n Return the key at the specified zero-based string multimap index.\n"]
    pub fn cef_string_multimap_key(
        map: cef_string_multimap_t,
        index: usize,
        key: *mut cef_string_t,
    ) -> ::core::ffi::c_int;
    #[doc = "\n Return the value at the specified zero-based string multimap index.\n"]
    pub fn cef_string_multimap_value(
        map: cef_string_multimap_t,
        index: usize,
        value: *mut cef_string_t,
    ) -> ::core::ffi::c_int;
    #[doc = "\n Append a new key/value pair at the end of the string multimap.\n"]
    pub fn cef_string_multimap_append(
        map: cef_string_multimap_t,
        key: *const cef_string_t,
        value: *const cef_string_t,
    ) -> ::core::ffi::c_int;
    #[doc = "\n Clear the string multimap.\n"]
    pub fn cef_string_multimap_clear(map: cef_string_multimap_t);
    #[doc = "\n Free the string multimap.\n"]
    pub fn cef_string_multimap_free(map: cef_string_multimap_t);
    #[doc = "\n Converts cef_time_t to/from time_t. Returns true (1) on success and false (0)\n on failure.\n"]
    pub fn cef_time_to_timet(cef_time: *const cef_time_t, time: *mut time_t) -> ::core::ffi::c_int;
    pub fn cef_time_from_timet(time: time_t, cef_time: *mut cef_time_t) -> ::core::ffi::c_int;
    #[doc = "\n Converts cef_time_t to/from a double which is the number of seconds since\n epoch (Jan 1, 1970). Webkit uses this format to represent time. A value of 0\n means \"not initialized\". Returns true (1) on success and false (0) on\n failure.\n"]
    pub fn cef_time_to_doublet(cef_time: *const cef_time_t, time: *mut f64) -> ::core::ffi::c_int;
    pub fn cef_time_from_doublet(time: f64, cef_time: *mut cef_time_t) -> ::core::ffi::c_int;
    #[doc = "\n Retrieve the current system time.\n"]
    pub fn cef_time_now(cef_time: *mut cef_time_t) -> ::core::ffi::c_int;
    #[doc = "\n Retrieve the delta in milliseconds between two time values.\n"]
    pub fn cef_time_delta(
        cef_time1: *const cef_time_t,
        cef_time2: *const cef_time_t,
        delta: *mut ::core::ffi::c_longlong,
    ) -> ::core::ffi::c_int;
    #[doc = "\n Creates a new object.\n"]
    pub fn cef_value_create() -> *mut cef_value_t;
    #[doc = "\n Creates a new object that is not owned by any other object. The specified\n |data| will be copied.\n"]
    pub fn cef_binary_value_create(
        data: *const ::core::ffi::c_void,
        data_size: usize,
    ) -> *mut cef_binary_value_t;
    #[doc = "\n Creates a new object that is not owned by any other object.\n"]
    pub fn cef_dictionary_value_create() -> *mut cef_dictionary_value_t;
    #[doc = "\n Creates a new object that is not owned by any other object.\n"]
    pub fn cef_list_value_create() -> *mut cef_list_value_t;
    #[doc = "\n Create a new cef_image_t. It will initially be NULL. Use the Add*() functions\n to add representations at different scale factors.\n"]
    pub fn cef_image_create() -> *mut cef_image_t;
    #[doc = "\n Create a new cef_stream_reader_t object from a file.\n"]
    pub fn cef_stream_reader_create_for_file(
        fileName: *const cef_string_t,
    ) -> *mut cef_stream_reader_t;
    #[doc = "\n Create a new cef_stream_reader_t object from data.\n"]
    pub fn cef_stream_reader_create_for_data(
        data: *mut ::core::ffi::c_void,
        size: usize,
    ) -> *mut cef_stream_reader_t;
    #[doc = "\n Create a new cef_stream_reader_t object from a custom handler.\n"]
    pub fn cef_stream_reader_create_for_handler(
        handler: *mut cef_read_handler_t,
    ) -> *mut cef_stream_reader_t;
    #[doc = "\n Create a new cef_stream_writer_t object for a file.\n"]
    pub fn cef_stream_writer_create_for_file(
        fileName: *const cef_string_t,
    ) -> *mut cef_stream_writer_t;
    #[doc = "\n Create a new cef_stream_writer_t object for a custom handler.\n"]
    pub fn cef_stream_writer_create_for_handler(
        handler: *mut cef_write_handler_t,
    ) -> *mut cef_stream_writer_t;
    #[doc = "\n Create a new cef_drag_data_t object.\n"]
    pub fn cef_drag_data_create() -> *mut cef_drag_data_t;
    #[doc = "\n Create a new cef_process_message_t object with the specified name.\n"]
    pub fn cef_process_message_create(name: *const cef_string_t) -> *mut cef_process_message_t;
    #[doc = "\n Create a new cef_request_t object.\n"]
    pub fn cef_request_create() -> *mut cef_request_t;
    #[doc = "\n Create a new cef_post_data_t object.\n"]
    pub fn cef_post_data_create() -> *mut cef_post_data_t;
    #[doc = "\n Create a new cef_post_data_element_t object.\n"]
    pub fn cef_post_data_element_create() -> *mut cef_post_data_element_t;
    #[doc = "\n Returns the global cookie manager. By default data will be stored at\n CefSettings.cache_path if specified or in memory otherwise. If |callback| is\n non-NULL it will be executed asnychronously on the UI thread after the\n manager's storage has been initialized. Using this function is equivalent to\n calling cef_request_context_t::cef_request_context_get_global_context()->GetD\n efaultCookieManager().\n"]
    pub fn cef_cookie_manager_get_global_manager(
        callback: *mut _cef_completion_callback_t,
    ) -> *mut cef_cookie_manager_t;
    #[doc = "\n Returns the MediaRouter object associated with the global request context. If\n |callback| is non-NULL it will be executed asnychronously on the UI thread\n after the manager's storage has been initialized. Equivalent to calling cef_r\n equest_context_t::cef_request_context_get_global_context()->get_media_router(\n ).\n"]
    pub fn cef_media_router_get_global(
        callback: *mut _cef_completion_callback_t,
    ) -> *mut cef_media_router_t;
    #[doc = "\n Returns the global context object.\n"]
    pub fn cef_request_context_get_global_context() -> *mut cef_request_context_t;
    #[doc = "\n Creates a new context object with the specified |settings| and optional\n |handler|.\n"]
    pub fn cef_request_context_create_context(
        settings: *const _cef_request_context_settings_t,
        handler: *mut _cef_request_context_handler_t,
    ) -> *mut cef_request_context_t;
    #[doc = "\n Creates a new context object that shares storage with |other| and uses an\n optional |handler|.\n"]
    pub fn cef_create_context_shared(
        other: *mut cef_request_context_t,
        handler: *mut _cef_request_context_handler_t,
    ) -> *mut cef_request_context_t;
    #[doc = "\n Create a new browser window using the window parameters specified by\n |windowInfo|. All values will be copied internally and the actual window will\n be created on the UI thread. If |request_context| is NULL the global request\n context will be used. This function can be called on any browser process\n thread and will not block. The optional |extra_info| parameter provides an\n opportunity to specify extra information specific to the created browser that\n will be passed to cef_render_process_handler_t::on_browser_created() in the\n render process.\n"]
    pub fn cef_browser_host_create_browser(
        windowInfo: *const cef_window_info_t,
        client: *mut _cef_client_t,
        url: *const cef_string_t,
        settings: *const _cef_browser_settings_t,
        extra_info: *mut _cef_dictionary_value_t,
        request_context: *mut _cef_request_context_t,
    ) -> ::core::ffi::c_int;
    #[doc = "\n Create a new browser window using the window parameters specified by\n |windowInfo|. If |request_context| is NULL the global request context will be\n used. This function can only be called on the browser process UI thread. The\n optional |extra_info| parameter provides an opportunity to specify extra\n information specific to the created browser that will be passed to\n cef_render_process_handler_t::on_browser_created() in the render process.\n"]
    pub fn cef_browser_host_create_browser_sync(
        windowInfo: *const cef_window_info_t,
        client: *mut _cef_client_t,
        url: *const cef_string_t,
        settings: *const _cef_browser_settings_t,
        extra_info: *mut _cef_dictionary_value_t,
        request_context: *mut _cef_request_context_t,
    ) -> *mut cef_browser_t;
    #[doc = "\n Create a new MenuModel with the specified |delegate|.\n"]
    pub fn cef_menu_model_create(
        delegate: *mut _cef_menu_model_delegate_t,
    ) -> *mut cef_menu_model_t;
    #[doc = "\n Create a new cef_print_settings_t object.\n"]
    pub fn cef_print_settings_create() -> *mut cef_print_settings_t;
    #[doc = "\n Create a new cef_response_t object.\n"]
    pub fn cef_response_create() -> *mut cef_response_t;
    #[doc = "\n Returns true (1) if the certificate status represents an error.\n"]
    pub fn cef_is_cert_status_error(status: cef_cert_status_t) -> ::core::ffi::c_int;
    #[doc = "\n Create a new cef_command_line_t instance.\n"]
    pub fn cef_command_line_create() -> *mut cef_command_line_t;
    #[doc = "\n Returns the singleton global cef_command_line_t object. The returned object\n will be read-only.\n"]
    pub fn cef_command_line_get_global() -> *mut cef_command_line_t;
    #[doc = "\n Returns the task runner for the current thread. Only CEF threads will have\n task runners. An NULL reference will be returned if this function is called\n on an invalid thread.\n"]
    pub fn cef_task_runner_get_for_current_thread() -> *mut cef_task_runner_t;
    #[doc = "\n Returns the task runner for the specified CEF thread.\n"]
    pub fn cef_task_runner_get_for_thread(threadId: cef_thread_id_t) -> *mut cef_task_runner_t;
    #[doc = "\n Returns true (1) if called on the specified thread. Equivalent to using\n cef_task_runner_t::GetForThread(threadId)->belongs_to_current_thread().\n"]
    pub fn cef_currently_on(threadId: cef_thread_id_t) -> ::core::ffi::c_int;
    #[doc = "\n Post a task for execution on the specified thread. Equivalent to using\n cef_task_runner_t::GetForThread(threadId)->PostTask(task).\n"]
    pub fn cef_post_task(threadId: cef_thread_id_t, task: *mut cef_task_t) -> ::core::ffi::c_int;
    #[doc = "\n Post a task for delayed execution on the specified thread. Equivalent to\n using cef_task_runner_t::GetForThread(threadId)->PostDelayedTask(task,\n delay_ms).\n"]
    pub fn cef_post_delayed_task(
        threadId: cef_thread_id_t,
        task: *mut cef_task_t,
        delay_ms: int64,
    ) -> ::core::ffi::c_int;
    #[doc = "\n Returns the current (top) context object in the V8 context stack.\n"]
    pub fn cef_v8context_get_current_context() -> *mut cef_v8context_t;
    #[doc = "\n Returns the entered (bottom) context object in the V8 context stack.\n"]
    pub fn cef_v8context_get_entered_context() -> *mut cef_v8context_t;
    #[doc = "\n Returns true (1) if V8 is currently inside a context.\n"]
    pub fn cef_v8context_in_context() -> ::core::ffi::c_int;
    #[doc = "\n Create a new cef_v8value_t object of type undefined.\n"]
    pub fn cef_v8value_create_undefined() -> *mut cef_v8value_t;
    #[doc = "\n Create a new cef_v8value_t object of type null.\n"]
    pub fn cef_v8value_create_null() -> *mut cef_v8value_t;
    #[doc = "\n Create a new cef_v8value_t object of type bool.\n"]
    pub fn cef_v8value_create_bool(value: ::core::ffi::c_int) -> *mut cef_v8value_t;
    #[doc = "\n Create a new cef_v8value_t object of type int.\n"]
    pub fn cef_v8value_create_int(value: int32) -> *mut cef_v8value_t;
    #[doc = "\n Create a new cef_v8value_t object of type unsigned int.\n"]
    pub fn cef_v8value_create_uint(value: uint32) -> *mut cef_v8value_t;
    #[doc = "\n Create a new cef_v8value_t object of type double.\n"]
    pub fn cef_v8value_create_double(value: f64) -> *mut cef_v8value_t;
    #[doc = "\n Create a new cef_v8value_t object of type Date. This function should only be\n called from within the scope of a cef_render_process_handler_t,\n cef_v8handler_t or cef_v8accessor_t callback, or in combination with calling\n enter() and exit() on a stored cef_v8context_t reference.\n"]
    pub fn cef_v8value_create_date(date: *const cef_time_t) -> *mut cef_v8value_t;
    #[doc = "\n Create a new cef_v8value_t object of type string.\n"]
    pub fn cef_v8value_create_string(value: *const cef_string_t) -> *mut cef_v8value_t;
    #[doc = "\n Create a new cef_v8value_t object of type object with optional accessor\n and/or interceptor. This function should only be called from within the scope\n of a cef_render_process_handler_t, cef_v8handler_t or cef_v8accessor_t\n callback, or in combination with calling enter() and exit() on a stored\n cef_v8context_t reference.\n"]
    pub fn cef_v8value_create_object(
        accessor: *mut cef_v8accessor_t,
        interceptor: *mut cef_v8interceptor_t,
    ) -> *mut cef_v8value_t;
    #[doc = "\n Create a new cef_v8value_t object of type array with the specified |length|.\n If |length| is negative the returned array will have length 0. This function\n should only be called from within the scope of a\n cef_render_process_handler_t, cef_v8handler_t or cef_v8accessor_t callback,\n or in combination with calling enter() and exit() on a stored cef_v8context_t\n reference.\n"]
    pub fn cef_v8value_create_array(length: ::core::ffi::c_int) -> *mut cef_v8value_t;
    #[doc = "\n Create a new cef_v8value_t object of type ArrayBuffer which wraps the\n provided |buffer| of size |length| bytes. The ArrayBuffer is externalized,\n meaning that it does not own |buffer|. The caller is responsible for freeing\n |buffer| when requested via a call to cef_v8array_buffer_release_callback_t::\n ReleaseBuffer. This function should only be called from within the scope of a\n cef_render_process_handler_t, cef_v8handler_t or cef_v8accessor_t callback,\n or in combination with calling enter() and exit() on a stored cef_v8context_t\n reference.\n"]
    pub fn cef_v8value_create_array_buffer(
        buffer: *mut ::core::ffi::c_void,
        length: usize,
        release_callback: *mut cef_v8array_buffer_release_callback_t,
    ) -> *mut cef_v8value_t;
    #[doc = "\n Create a new cef_v8value_t object of type function. This function should only\n be called from within the scope of a cef_render_process_handler_t,\n cef_v8handler_t or cef_v8accessor_t callback, or in combination with calling\n enter() and exit() on a stored cef_v8context_t reference.\n"]
    pub fn cef_v8value_create_function(
        name: *const cef_string_t,
        handler: *mut cef_v8handler_t,
    ) -> *mut cef_v8value_t;
    #[doc = "\n Returns the stack trace for the currently active context. |frame_limit| is\n the maximum number of frames that will be captured.\n"]
    pub fn cef_v8stack_trace_get_current(
        frame_limit: ::core::ffi::c_int,
    ) -> *mut cef_v8stack_trace_t;
    #[doc = "\n Register a new V8 extension with the specified JavaScript extension code and\n handler. Functions implemented by the handler are prototyped using the\n keyword 'native'. The calling of a native function is restricted to the scope\n in which the prototype of the native function is defined. This function may\n only be called on the render process main thread.\n\n Example JavaScript extension code: <pre>\n   // create the 'example' global object if it doesn't already exist.\n   if (!example)\n     example = {};\n   // create the 'example.test' global object if it doesn't already exist.\n   if (!example.test)\n     example.test = {};\n   (function() {\n     // Define the function 'example.test.myfunction'.\n     example.test.myfunction = function() {\n       // Call CefV8Handler::Execute() with the function name 'MyFunction'\n       // and no arguments.\n       native function MyFunction();\n       return MyFunction();\n     };\n     // Define the getter function for parameter 'example.test.myparam'.\n     example.test.__defineGetter__('myparam', function() {\n       // Call CefV8Handler::Execute() with the function name 'GetMyParam'\n       // and no arguments.\n       native function GetMyParam();\n       return GetMyParam();\n     });\n     // Define the setter function for parameter 'example.test.myparam'.\n     example.test.__defineSetter__('myparam', function(b) {\n       // Call CefV8Handler::Execute() with the function name 'SetMyParam'\n       // and a single argument.\n       native function SetMyParam();\n       if(b) SetMyParam(b);\n     });\n\n     // Extension definitions can also contain normal JavaScript variables\n     // and functions.\n     var myint = 0;\n     example.test.increment = function() {\n       myint += 1;\n       return myint;\n     };\n   })();\n </pre> Example usage in the page: <pre>\n   // Call the function.\n   example.test.myfunction();\n   // Set the parameter.\n   example.test.myparam = value;\n   // Get the parameter.\n   value = example.test.myparam;\n   // Call another function.\n   example.test.increment();\n </pre>\n"]
    pub fn cef_register_extension(
        extension_name: *const cef_string_t,
        javascript_code: *const cef_string_t,
        handler: *mut cef_v8handler_t,
    ) -> ::core::ffi::c_int;
    #[doc = "\n Register a scheme handler factory with the global request context. An NULL\n |domain_name| value for a standard scheme will cause the factory to match all\n domain names. The |domain_name| value will be ignored for non-standard\n schemes. If |scheme_name| is a built-in scheme and no handler is returned by\n |factory| then the built-in scheme handler factory will be called. If\n |scheme_name| is a custom scheme then you must also implement the\n cef_app_t::on_register_custom_schemes() function in all processes. This\n function may be called multiple times to change or remove the factory that\n matches the specified |scheme_name| and optional |domain_name|. Returns false\n (0) if an error occurs. This function may be called on any thread in the\n browser process. Using this function is equivalent to calling cef_request_con\n text_t::cef_request_context_get_global_context()->register_scheme_handler_fac\n tory().\n"]
    pub fn cef_register_scheme_handler_factory(
        scheme_name: *const cef_string_t,
        domain_name: *const cef_string_t,
        factory: *mut cef_scheme_handler_factory_t,
    ) -> ::core::ffi::c_int;
    #[doc = "\n Clear all scheme handler factories registered with the global request\n context. Returns false (0) on error. This function may be called on any\n thread in the browser process. Using this function is equivalent to calling c\n ef_request_context_t::cef_request_context_get_global_context()->clear_scheme_\n handler_factories().\n"]
    pub fn cef_clear_scheme_handler_factories() -> ::core::ffi::c_int;
    #[doc = "\n This function should be called from the application entry point function to\n execute a secondary process. It can be used to run secondary processes from\n the browser client executable (default behavior) or from a separate\n executable specified by the CefSettings.browser_subprocess_path value. If\n called for the browser process (identified by no \"type\" command-line value)\n it will return immediately with a value of -1. If called for a recognized\n secondary process it will block until the process should exit and then return\n the process exit code. The |application| parameter may be NULL. The\n |windows_sandbox_info| parameter is only used on Windows and may be NULL (see\n cef_sandbox_win.h for details).\n"]
    pub fn cef_execute_process(
        args: *const _cef_main_args_t,
        application: *mut cef_app_t,
        windows_sandbox_info: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = "\n This function should be called on the main application thread to initialize\n the CEF browser process. The |application| parameter may be NULL. A return\n value of true (1) indicates that it succeeded and false (0) indicates that it\n failed. The |windows_sandbox_info| parameter is only used on Windows and may\n be NULL (see cef_sandbox_win.h for details).\n"]
    pub fn cef_initialize(
        args: *const _cef_main_args_t,
        settings: *const _cef_settings_t,
        application: *mut cef_app_t,
        windows_sandbox_info: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = "\n This function should be called on the main application thread to shut down\n the CEF browser process before the application exits.\n"]
    pub fn cef_shutdown();
    #[doc = "\n Perform a single iteration of CEF message loop processing. This function is\n provided for cases where the CEF message loop must be integrated into an\n existing application message loop. Use of this function is not recommended\n for most users; use either the cef_run_message_loop() function or\n CefSettings.multi_threaded_message_loop if possible. When using this function\n care must be taken to balance performance against excessive CPU usage. It is\n recommended to enable the CefSettings.external_message_pump option when using\n this function so that\n cef_browser_process_handler_t::on_schedule_message_pump_work() callbacks can\n facilitate the scheduling process. This function should only be called on the\n main application thread and only if cef_initialize() is called with a\n CefSettings.multi_threaded_message_loop value of false (0). This function\n will not block.\n"]
    pub fn cef_do_message_loop_work();
    #[doc = "\n Run the CEF message loop. Use this function instead of an application-\n provided message loop to get the best balance between performance and CPU\n usage. This function should only be called on the main application thread and\n only if cef_initialize() is called with a\n CefSettings.multi_threaded_message_loop value of false (0). This function\n will block until a quit message is received by the system.\n"]
    pub fn cef_run_message_loop();
    #[doc = "\n Quit the CEF message loop that was started by calling cef_run_message_loop().\n This function should only be called on the main application thread and only\n if cef_run_message_loop() was used.\n"]
    pub fn cef_quit_message_loop();
    #[doc = "\n Set to true (1) before calling Windows APIs like TrackPopupMenu that enter a\n modal message loop. Set to false (0) after exiting the modal message loop.\n"]
    pub fn cef_set_osmodal_loop(osModalLoop: ::core::ffi::c_int);
    #[doc = "\n Call during process startup to enable High-DPI support on Windows 7 or newer.\n Older versions of Windows should be left DPI-unaware because they do not\n support DirectWrite and GDI fonts are kerned very badly.\n"]
    pub fn cef_enable_highdpi_support();
    #[doc = "\n Crash reporting is configured using an INI-style config file named\n \"crash_reporter.cfg\". On Windows and Linux this file must be placed next to\n the main application executable. On macOS this file must be placed in the\n top-level app bundle Resources directory (e.g.\n \"<appname>.app/Contents/Resources\"). File contents are as follows:\n\n  # Comments start with a hash character and must be on their own line.\n\n  [Config]\n  ProductName=<Value of the \"prod\" crash key; defaults to \"cef\">\n  ProductVersion=<Value of the \"ver\" crash key; defaults to the CEF version>\n  AppName=<Windows only; App-specific folder name component for storing crash\n           information; default to \"CEF\">\n  ExternalHandler=<Windows only; Name of the external handler exe to use\n                   instead of re-launching the main exe; default to empty>\n  BrowserCrashForwardingEnabled=<macOS only; True if browser process crashes\n                                 should be forwarded to the system crash\n                                 reporter; default to false>\n  ServerURL=<crash server URL; default to empty>\n  RateLimitEnabled=<True if uploads should be rate limited; default to true>\n  MaxUploadsPerDay=<Max uploads per 24 hours, used if rate limit is enabled;\n                    default to 5>\n  MaxDatabaseSizeInMb=<Total crash report disk usage greater than this value\n                       will cause older reports to be deleted; default to 20>\n  MaxDatabaseAgeInDays=<Crash reports older than this value will be deleted;\n                        default to 5>\n\n  [CrashKeys]\n  my_key1=<small|medium|large>\n  my_key2=<small|medium|large>\n\n Config section:\n\n If \"ProductName\" and/or \"ProductVersion\" are set then the specified values\n will be included in the crash dump metadata. On macOS if these values are set\n to NULL then they will be retrieved from the Info.plist file using the\n \"CFBundleName\" and \"CFBundleShortVersionString\" keys respectively.\n\n If \"AppName\" is set on Windows then crash report information (metrics,\n database and dumps) will be stored locally on disk under the\n \"C:\\Users\\[CurrentUser]\\AppData\\Local\\[AppName]\\User Data\" folder. On other\n platforms the CefSettings.user_data_path value will be used.\n\n If \"ExternalHandler\" is set on Windows then the specified exe will be\n launched as the crashpad-handler instead of re-launching the main process\n exe. The value can be an absolute path or a path relative to the main exe\n directory. On Linux the CefSettings.browser_subprocess_path value will be\n used. On macOS the existing subprocess app bundle will be used.\n\n If \"BrowserCrashForwardingEnabled\" is set to true (1) on macOS then browser\n process crashes will be forwarded to the system crash reporter. This results\n in the crash UI dialog being displayed to the user and crash reports being\n logged under \"~/Library/Logs/DiagnosticReports\". Forwarding of crash reports\n from non-browser processes and Debug builds is always disabled.\n\n If \"ServerURL\" is set then crashes will be uploaded as a multi-part POST\n request to the specified URL. Otherwise, reports will only be stored locally\n on disk.\n\n If \"RateLimitEnabled\" is set to true (1) then crash report uploads will be\n rate limited as follows:\n  1. If \"MaxUploadsPerDay\" is set to a positive value then at most the\n     specified number of crashes will be uploaded in each 24 hour period.\n  2. If crash upload fails due to a network or server error then an\n     incremental backoff delay up to a maximum of 24 hours will be applied for\n     retries.\n  3. If a backoff delay is applied and \"MaxUploadsPerDay\" is > 1 then the\n     \"MaxUploadsPerDay\" value will be reduced to 1 until the client is\n     restarted. This helps to avoid an upload flood when the network or\n     server error is resolved.\n Rate limiting is not supported on Linux.\n\n If \"MaxDatabaseSizeInMb\" is set to a positive value then crash report storage\n on disk will be limited to that size in megabytes. For example, on Windows\n each dump is about 600KB so a \"MaxDatabaseSizeInMb\" value of 20 equates to\n about 34 crash reports stored on disk. Not supported on Linux.\n\n If \"MaxDatabaseAgeInDays\" is set to a positive value then crash reports older\n than the specified age in days will be deleted. Not supported on Linux.\n\n CrashKeys section:\n\n A maximum of 26 crash keys of each size can be specified for use by the\n application. Crash key values will be truncated based on the specified size\n (small = 64 bytes, medium = 256 bytes, large = 1024 bytes). The value of\n crash keys can be set from any thread or process using the\n CefSetCrashKeyValue function. These key/value pairs will be sent to the crash\n server along with the crash dump file.\n"]
    pub fn cef_crash_reporting_enabled() -> ::core::ffi::c_int;
    #[doc = "\n Sets or clears a specific key-value pair from the crash metadata.\n"]
    pub fn cef_set_crash_key_value(key: *const cef_string_t, value: *const cef_string_t);
    #[doc = "\n Creates a directory and all parent directories if they don't already exist.\n Returns true (1) on successful creation or if the directory already exists.\n The directory is only readable by the current user. Calling this function on\n the browser process UI or IO threads is not allowed.\n"]
    pub fn cef_create_directory(full_path: *const cef_string_t) -> ::core::ffi::c_int;
    #[doc = "\n Get the temporary directory provided by the system.\n\n WARNING: In general, you should use the temp directory variants below instead\n of this function. Those variants will ensure that the proper permissions are\n set so that other users on the system can't edit them while they're open\n (which could lead to security issues).\n"]
    pub fn cef_get_temp_directory(temp_dir: *mut cef_string_t) -> ::core::ffi::c_int;
    #[doc = "\n Creates a new directory. On Windows if |prefix| is provided the new directory\n name is in the format of \"prefixyyyy\". Returns true (1) on success and sets\n |new_temp_path| to the full path of the directory that was created. The\n directory is only readable by the current user. Calling this function on the\n browser process UI or IO threads is not allowed.\n"]
    pub fn cef_create_new_temp_directory(
        prefix: *const cef_string_t,
        new_temp_path: *mut cef_string_t,
    ) -> ::core::ffi::c_int;
    #[doc = "\n Creates a directory within another directory. Extra characters will be\n appended to |prefix| to ensure that the new directory does not have the same\n name as an existing directory. Returns true (1) on success and sets |new_dir|\n to the full path of the directory that was created. The directory is only\n readable by the current user. Calling this function on the browser process UI\n or IO threads is not allowed.\n"]
    pub fn cef_create_temp_directory_in_directory(
        base_dir: *const cef_string_t,
        prefix: *const cef_string_t,
        new_dir: *mut cef_string_t,
    ) -> ::core::ffi::c_int;
    #[doc = "\n Returns true (1) if the given path exists and is a directory. Calling this\n function on the browser process UI or IO threads is not allowed.\n"]
    pub fn cef_directory_exists(path: *const cef_string_t) -> ::core::ffi::c_int;
    #[doc = "\n Deletes the given path whether it's a file or a directory. If |path| is a\n directory all contents will be deleted.  If |recursive| is true (1) any sub-\n directories and their contents will also be deleted (equivalent to executing\n \"rm -rf\", so use with caution). On POSIX environments if |path| is a symbolic\n link then only the symlink will be deleted. Returns true (1) on successful\n deletion or if |path| does not exist. Calling this function on the browser\n process UI or IO threads is not allowed.\n"]
    pub fn cef_delete_file(
        path: *const cef_string_t,
        recursive: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    #[doc = "\n Writes the contents of |src_dir| into a zip archive at |dest_file|. If\n |include_hidden_files| is true (1) files starting with \".\" will be included.\n Returns true (1) on success.  Calling this function on the browser process UI\n or IO threads is not allowed.\n"]
    pub fn cef_zip_directory(
        src_dir: *const cef_string_t,
        dest_file: *const cef_string_t,
        include_hidden_files: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    #[doc = "\n Loads the existing \"Certificate Revocation Lists\" file that is managed by\n Google Chrome. This file can generally be found in Chrome's User Data\n directory (e.g. \"C:\\Users\\[User]\\AppData\\Local\\Google\\Chrome\\User Data\\\" on\n Windows) and is updated periodically by Chrome's component updater service.\n Must be called in the browser process after the context has been initialized.\n See https://dev.chromium.org/Home/chromium-security/crlsets for background.\n"]
    pub fn cef_load_crlsets_file(path: *const cef_string_t);
    #[doc = "\n Add an entry to the cross-origin access whitelist.\n\n The same-origin policy restricts how scripts hosted from different origins\n (scheme + domain + port) can communicate. By default, scripts can only access\n resources with the same origin. Scripts hosted on the HTTP and HTTPS schemes\n (but no other schemes) can use the \"Access-Control-Allow-Origin\" header to\n allow cross-origin requests. For example, https://source.example.com can make\n XMLHttpRequest requests on http://target.example.com if the\n http://target.example.com request returns an \"Access-Control-Allow-Origin:\n https://source.example.com\" response header.\n\n Scripts in separate frames or iframes and hosted from the same protocol and\n domain suffix can execute cross-origin JavaScript if both pages set the\n document.domain value to the same domain suffix. For example,\n scheme://foo.example.com and scheme://bar.example.com can communicate using\n JavaScript if both domains set document.domain=\"example.com\".\n\n This function is used to allow access to origins that would otherwise violate\n the same-origin policy. Scripts hosted underneath the fully qualified\n |source_origin| URL (like http://www.example.com) will be allowed access to\n all resources hosted on the specified |target_protocol| and |target_domain|.\n If |target_domain| is non-NULL and |allow_target_subdomains| if false (0)\n only exact domain matches will be allowed. If |target_domain| contains a top-\n level domain component (like \"example.com\") and |allow_target_subdomains| is\n true (1) sub-domain matches will be allowed. If |target_domain| is NULL and\n |allow_target_subdomains| if true (1) all domains and IP addresses will be\n allowed.\n\n This function cannot be used to bypass the restrictions on local or display\n isolated schemes. See the comments on CefRegisterCustomScheme for more\n information.\n\n This function may be called on any thread. Returns false (0) if\n |source_origin| is invalid or the whitelist cannot be accessed.\n"]
    pub fn cef_add_cross_origin_whitelist_entry(
        source_origin: *const cef_string_t,
        target_protocol: *const cef_string_t,
        target_domain: *const cef_string_t,
        allow_target_subdomains: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    #[doc = "\n Remove an entry from the cross-origin access whitelist. Returns false (0) if\n |source_origin| is invalid or the whitelist cannot be accessed.\n"]
    pub fn cef_remove_cross_origin_whitelist_entry(
        source_origin: *const cef_string_t,
        target_protocol: *const cef_string_t,
        target_domain: *const cef_string_t,
        allow_target_subdomains: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
    #[doc = "\n Remove all entries from the cross-origin access whitelist. Returns false (0)\n if the whitelist cannot be accessed.\n"]
    pub fn cef_clear_cross_origin_whitelist() -> ::core::ffi::c_int;
    #[doc = "\n Parse the specified |url| into its component parts. Returns false (0) if the\n URL is NULL or invalid.\n"]
    pub fn cef_parse_url(
        url: *const cef_string_t,
        parts: *mut _cef_urlparts_t,
    ) -> ::core::ffi::c_int;
    #[doc = "\n Creates a URL from the specified |parts|, which must contain a non-NULL spec\n or a non-NULL host and path (at a minimum), but not both. Returns false (0)\n if |parts| isn't initialized as described.\n"]
    pub fn cef_create_url(
        parts: *const _cef_urlparts_t,
        url: *mut cef_string_t,
    ) -> ::core::ffi::c_int;
    #[doc = "\n This is a convenience function for formatting a URL in a concise and human-\n friendly way to help users make security-related decisions (or in other\n circumstances when people need to distinguish sites, origins, or otherwise-\n simplified URLs from each other). Internationalized domain names (IDN) may be\n presented in Unicode if the conversion is considered safe. The returned value\n will (a) omit the path for standard schemes, excepting file and filesystem,\n and (b) omit the port if it is the default for the scheme. Do not use this\n for URLs which will be parsed or sent to other applications.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub fn cef_format_url_for_security_display(
        origin_url: *const cef_string_t,
    ) -> cef_string_userfree_t;
    #[doc = "\n Returns the mime type for the specified file extension or an NULL string if\n unknown.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub fn cef_get_mime_type(extension: *const cef_string_t) -> cef_string_userfree_t;
    #[doc = "\n Get the extensions associated with the given mime type. This should be passed\n in lower case. There could be multiple extensions for a given mime type, like\n \"html,htm\" for \"text/html\", or \"txt,text,html,...\" for \"text/*\". Any existing\n elements in the provided vector will not be erased.\n"]
    pub fn cef_get_extensions_for_mime_type(
        mime_type: *const cef_string_t,
        extensions: cef_string_list_t,
    );
    #[doc = "\n Encodes |data| as a base64 string.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub fn cef_base64encode(
        data: *const ::core::ffi::c_void,
        data_size: usize,
    ) -> cef_string_userfree_t;
    #[doc = "\n Decodes the base64 encoded string |data|. The returned value will be NULL if\n the decoding fails.\n"]
    pub fn cef_base64decode(data: *const cef_string_t) -> *mut _cef_binary_value_t;
    #[doc = "\n Escapes characters in |text| which are unsuitable for use as a query\n parameter value. Everything except alphanumerics and -_.!~*'() will be\n converted to \"%XX\". If |use_plus| is true (1) spaces will change to \"+\". The\n result is basically the same as encodeURIComponent in Javacript.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub fn cef_uriencode(
        text: *const cef_string_t,
        use_plus: ::core::ffi::c_int,
    ) -> cef_string_userfree_t;
    #[doc = "\n Unescapes |text| and returns the result. Unescaping consists of looking for\n the exact pattern \"%XX\" where each X is a hex digit and converting to the\n character with the numerical value of those digits (e.g. \"i%20=%203%3b\"\n unescapes to \"i = 3;\"). If |convert_to_utf8| is true (1) this function will\n attempt to interpret the initial decoded result as UTF-8. If the result is\n convertable into UTF-8 it will be returned as converted. Otherwise the\n initial decoded result will be returned.  The |unescape_rule| parameter\n supports further customization the decoding process.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub fn cef_uridecode(
        text: *const cef_string_t,
        convert_to_utf8: ::core::ffi::c_int,
        unescape_rule: cef_uri_unescape_rule_t,
    ) -> cef_string_userfree_t;
    #[doc = "\n Parses the specified |json_string| and returns a dictionary or list\n representation. If JSON parsing fails this function returns NULL.\n"]
    pub fn cef_parse_json(
        json_string: *const cef_string_t,
        options: cef_json_parser_options_t,
    ) -> *mut _cef_value_t;
    #[doc = "\n Parses the specified UTF8-encoded |json| buffer of size |json_size| and\n returns a dictionary or list representation. If JSON parsing fails this\n function returns NULL.\n"]
    pub fn cef_parse_json_buffer(
        json: *const ::core::ffi::c_void,
        json_size: usize,
        options: cef_json_parser_options_t,
    ) -> *mut _cef_value_t;
    #[doc = "\n Parses the specified |json_string| and returns a dictionary or list\n representation. If JSON parsing fails this function returns NULL and\n populates |error_msg_out| with a formatted error message.\n"]
    pub fn cef_parse_jsonand_return_error(
        json_string: *const cef_string_t,
        options: cef_json_parser_options_t,
        error_msg_out: *mut cef_string_t,
    ) -> *mut _cef_value_t;
    #[doc = "\n Generates a JSON string from the specified root |node| which should be a\n dictionary or list value. Returns an NULL string on failure. This function\n requires exclusive access to |node| including any underlying data.\n\n The resulting string must be freed by calling cef_string_userfree_free()."]
    pub fn cef_write_json(
        node: *mut _cef_value_t,
        options: cef_json_writer_options_t,
    ) -> cef_string_userfree_t;
    #[doc = "\n Retrieve the path associated with the specified |key|. Returns true (1) on\n success. Can be called on any thread in the browser process.\n"]
    pub fn cef_get_path(key: cef_path_key_t, path: *mut cef_string_t) -> ::core::ffi::c_int;
    #[doc = "\n Launches the process specified via |command_line|. Returns true (1) upon\n success. Must be called on the browser process TID_PROCESS_LAUNCHER thread.\n\n Unix-specific notes: - All file descriptors open in the parent process will\n be closed in the\n   child process except for stdin, stdout, and stderr.\n - If the first argument on the command line does not contain a slash,\n   PATH will be searched. (See man execvp.)\n"]
    pub fn cef_launch_process(command_line: *mut _cef_command_line_t) -> ::core::ffi::c_int;
    #[doc = "\n Visit web plugin information. Can be called on any thread in the browser\n process.\n"]
    pub fn cef_visit_web_plugin_info(visitor: *mut cef_web_plugin_info_visitor_t);
    #[doc = "\n Cause the plugin list to refresh the next time it is accessed regardless of\n whether it has already been loaded. Can be called on any thread in the\n browser process.\n"]
    pub fn cef_refresh_web_plugins();
    #[doc = "\n Unregister an internal plugin. This may be undone the next time\n cef_refresh_web_plugins() is called. Can be called on any thread in the\n browser process.\n"]
    pub fn cef_unregister_internal_web_plugin(path: *const cef_string_t);
    #[doc = "\n Register a plugin crash. Can be called on any thread in the browser process\n but will be executed on the IO thread.\n"]
    pub fn cef_register_web_plugin_crash(path: *const cef_string_t);
    #[doc = "\n Query if a plugin is unstable. Can be called on any thread in the browser\n process.\n"]
    pub fn cef_is_web_plugin_unstable(
        path: *const cef_string_t,
        callback: *mut cef_web_plugin_unstable_callback_t,
    );
    #[doc = "\n Register the Widevine CDM plugin.\n\n The client application is responsible for downloading an appropriate\n platform-specific CDM binary distribution from Google, extracting the\n contents, and building the required directory structure on the local machine.\n The cef_browser_host_t::StartDownload function and CefZipArchive structure\n can be used to implement this functionality in CEF. Contact Google via\n https://www.widevine.com/contact.html for details on CDM download.\n\n |path| is a directory that must contain the following files:\n   1. manifest.json file from the CDM binary distribution (see below).\n   2. widevinecdm file from the CDM binary distribution (e.g.\n      widevinecdm.dll on on Windows, libwidevinecdm.dylib on OS X,\n      libwidevinecdm.so on Linux).\n\n If any of these files are missing or if the manifest file has incorrect\n contents the registration will fail and |callback| will receive a |result|\n value of CEF_CDM_REGISTRATION_ERROR_INCORRECT_CONTENTS.\n\n The manifest.json file must contain the following keys:\n   A. \"os\": Supported OS (e.g. \"mac\", \"win\" or \"linux\").\n   B. \"arch\": Supported architecture (e.g. \"ia32\" or \"x64\").\n   C. \"x-cdm-module-versions\": Module API version (e.g. \"4\").\n   D. \"x-cdm-interface-versions\": Interface API version (e.g. \"8\").\n   E. \"x-cdm-host-versions\": Host API version (e.g. \"8\").\n   F. \"version\": CDM version (e.g. \"1.4.8.903\").\n   G. \"x-cdm-codecs\": List of supported codecs (e.g. \"vp8,vp09,avc1\").\n\n A through E are used to verify compatibility with the current Chromium\n version. If the CDM is not compatible the registration will fail and\n |callback| will receive a |result| value of\n CEF_CDM_REGISTRATION_ERROR_INCOMPATIBLE.\n\n |callback| will be executed asynchronously once registration is complete.\n\n On Linux this function must be called before cef_initialize() and the\n registration cannot be changed during runtime. If registration is not\n supported at the time that cef_register_widevine_cdm() is called then\n |callback| will receive a |result| value of\n CEF_CDM_REGISTRATION_ERROR_NOT_SUPPORTED.\n"]
    pub fn cef_register_widevine_cdm(
        path: *const cef_string_t,
        callback: *mut cef_register_cdm_callback_t,
    );
    #[doc = "\n Returns the global resource bundle instance.\n"]
    pub fn cef_resource_bundle_get_global() -> *mut cef_resource_bundle_t;
    #[doc = "\n Create a new server that binds to |address| and |port|. |address| must be a\n valid IPv4 or IPv6 address (e.g. 127.0.0.1 or ::1) and |port| must be a port\n number outside of the reserved range (e.g. between 1025 and 65535 on most\n platforms). |backlog| is the maximum number of pending connections. A new\n thread will be created for each CreateServer call (the \"dedicated server\n thread\"). It is therefore recommended to use a different cef_server_handler_t\n instance for each CreateServer call to avoid thread safety issues in the\n cef_server_handler_t implementation. The\n cef_server_handler_t::OnServerCreated function will be called on the\n dedicated server thread to report success or failure. See\n cef_server_handler_t::OnServerCreated documentation for a description of\n server lifespan.\n"]
    pub fn cef_server_create(
        address: *const cef_string_t,
        port: uint16,
        backlog: ::core::ffi::c_int,
        handler: *mut _cef_server_handler_t,
    );
    #[doc = "\n Returns the current platform thread ID.\n"]
    pub fn cef_get_current_platform_thread_id() -> cef_platform_thread_id_t;
    #[doc = "\n Returns the current platform thread handle.\n"]
    pub fn cef_get_current_platform_thread_handle() -> cef_platform_thread_handle_t;
    #[doc = "\n Create and start a new thread. This function does not block waiting for the\n thread to run initialization. |display_name| is the name that will be used to\n identify the thread. |priority| is the thread execution priority.\n |message_loop_type| indicates the set of asynchronous events that the thread\n can process. If |stoppable| is true (1) the thread will stopped and joined on\n destruction or when stop() is called; otherwise, the thread cannot be stopped\n and will be leaked on shutdown. On Windows the |com_init_mode| value\n specifies how COM will be initialized for the thread. If |com_init_mode| is\n set to COM_INIT_MODE_STA then |message_loop_type| must be set to ML_TYPE_UI.\n"]
    pub fn cef_thread_create(
        display_name: *const cef_string_t,
        priority: cef_thread_priority_t,
        message_loop_type: cef_message_loop_type_t,
        stoppable: ::core::ffi::c_int,
        com_init_mode: cef_com_init_mode_t,
    ) -> *mut cef_thread_t;
    #[doc = "\n Start tracing events on all processes. Tracing is initialized asynchronously\n and |callback| will be executed on the UI thread after initialization is\n complete.\n\n If CefBeginTracing was called previously, or if a CefEndTracingAsync call is\n pending, CefBeginTracing will fail and return false (0).\n\n |categories| is a comma-delimited list of category wildcards. A category can\n have an optional '-' prefix to make it an excluded category. Having both\n included and excluded categories in the same list is not supported.\n\n Example: \"test_MyTest*\" Example: \"test_MyTest*,test_OtherStuff\" Example:\n \"-excluded_category1,-excluded_category2\"\n\n This function must be called on the browser process UI thread.\n"]
    pub fn cef_begin_tracing(
        categories: *const cef_string_t,
        callback: *mut _cef_completion_callback_t,
    ) -> ::core::ffi::c_int;
    #[doc = "\n Stop tracing events on all processes.\n\n This function will fail and return false (0) if a previous call to\n CefEndTracingAsync is already pending or if CefBeginTracing was not called.\n\n |tracing_file| is the path at which tracing data will be written and\n |callback| is the callback that will be executed once all processes have sent\n their trace data. If |tracing_file| is NULL a new temporary file path will be\n used. If |callback| is NULL no trace data will be written.\n\n This function must be called on the browser process UI thread.\n"]
    pub fn cef_end_tracing(
        tracing_file: *const cef_string_t,
        callback: *mut cef_end_tracing_callback_t,
    ) -> ::core::ffi::c_int;
    #[doc = "\n Returns the current system trace time or, if none is defined, the current\n high-res time. Can be used by clients to synchronize with the time\n information in trace events.\n"]
    pub fn cef_now_from_system_trace_time() -> int64;
    #[doc = "\n Create a new URL request that is not associated with a specific browser or\n frame. Use cef_frame_t::CreateURLRequest instead if you want the request to\n have this association, in which case it may be handled differently (see\n documentation on that function). A request created with this function may\n only originate from the browser process, and will behave as follows:\n   - It may be intercepted by the client via CefResourceRequestHandler or\n     CefSchemeHandlerFactory.\n   - POST data may only contain only a single element of type PDE_TYPE_FILE\n     or PDE_TYPE_BYTES.\n   - If |request_context| is empty the global request context will be used.\n\n The |request| object will be marked as read-only after calling this function.\n"]
    pub fn cef_urlrequest_create(
        request: *mut _cef_request_t,
        client: *mut _cef_urlrequest_client_t,
        request_context: *mut _cef_request_context_t,
    ) -> *mut cef_urlrequest_t;
    #[doc = "\n Create a new waitable event. If |automatic_reset| is true (1) then the event\n state is automatically reset to un-signaled after a single waiting thread has\n been released; otherwise, the state remains signaled until reset() is called\n manually. If |initially_signaled| is true (1) then the event will start in\n the signaled state.\n"]
    pub fn cef_waitable_event_create(
        automatic_reset: ::core::ffi::c_int,
        initially_signaled: ::core::ffi::c_int,
    ) -> *mut cef_waitable_event_t;
    #[doc = "\n Create a new cef_xml_reader_t object. The returned object's functions can\n only be called from the thread that created the object.\n"]
    pub fn cef_xml_reader_create(
        stream: *mut _cef_stream_reader_t,
        encodingType: cef_xml_encoding_type_t,
        URI: *const cef_string_t,
    ) -> *mut cef_xml_reader_t;
    #[doc = "\n Create a new cef_zip_reader_t object. The returned object's functions can\n only be called from the thread that created the object.\n"]
    pub fn cef_zip_reader_create(stream: *mut _cef_stream_reader_t) -> *mut cef_zip_reader_t;
}
